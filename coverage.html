
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ryabkov82/shortener/api/shortener.pb.go (58.4%)</option>
				
				<option value="file1">github.com/ryabkov82/shortener/api/shortener_grpc.pb.go (79.3%)</option>
				
				<option value="file2">github.com/ryabkov82/shortener/cmd/client/main.go (0.0%)</option>
				
				<option value="file3">github.com/ryabkov82/shortener/cmd/genserver/genserver.go (0.0%)</option>
				
				<option value="file4">github.com/ryabkov82/shortener/cmd/shortener/main.go (0.0%)</option>
				
				<option value="file5">github.com/ryabkov82/shortener/cmd/staticlint/main.go (93.1%)</option>
				
				<option value="file6">github.com/ryabkov82/shortener/cmd/staticlint/noosexit/analyzer.go (83.3%)</option>
				
				<option value="file7">github.com/ryabkov82/shortener/internal/app/config/config.go (75.3%)</option>
				
				<option value="file8">github.com/ryabkov82/shortener/internal/app/handlers/grpc/base/handler.go (50.0%)</option>
				
				<option value="file9">github.com/ryabkov82/shortener/internal/app/handlers/grpc/batch/batch.go (75.0%)</option>
				
				<option value="file10">github.com/ryabkov82/shortener/internal/app/handlers/grpc/deluserurls/deluserurls.go (60.0%)</option>
				
				<option value="file11">github.com/ryabkov82/shortener/internal/app/handlers/grpc/ping/ping.go (100.0%)</option>
				
				<option value="file12">github.com/ryabkov82/shortener/internal/app/handlers/grpc/redirect/redirect.go (62.5%)</option>
				
				<option value="file13">github.com/ryabkov82/shortener/internal/app/handlers/grpc/server_gen.go (82.1%)</option>
				
				<option value="file14">github.com/ryabkov82/shortener/internal/app/handlers/grpc/shorturl/shorturl.go (77.8%)</option>
				
				<option value="file15">github.com/ryabkov82/shortener/internal/app/handlers/grpc/stats/stats.go (100.0%)</option>
				
				<option value="file16">github.com/ryabkov82/shortener/internal/app/handlers/grpc/userurls/userurls.go (85.7%)</option>
				
				<option value="file17">github.com/ryabkov82/shortener/internal/app/handlers/http/batch/batch.go (71.4%)</option>
				
				<option value="file18">github.com/ryabkov82/shortener/internal/app/handlers/http/deluserurls/deluserurls.go (54.5%)</option>
				
				<option value="file19">github.com/ryabkov82/shortener/internal/app/handlers/http/ping/ping.go (100.0%)</option>
				
				<option value="file20">github.com/ryabkov82/shortener/internal/app/handlers/http/redirect/redirect.go (61.1%)</option>
				
				<option value="file21">github.com/ryabkov82/shortener/internal/app/handlers/http/shortenapi/shortenapi.go (66.7%)</option>
				
				<option value="file22">github.com/ryabkov82/shortener/internal/app/handlers/http/shorturl/shorturl.go (67.7%)</option>
				
				<option value="file23">github.com/ryabkov82/shortener/internal/app/handlers/http/stats/stats.go (91.7%)</option>
				
				<option value="file24">github.com/ryabkov82/shortener/internal/app/handlers/http/userurls/userurls.go (76.5%)</option>
				
				<option value="file25">github.com/ryabkov82/shortener/internal/app/httpgzip/httpgzip.go (92.6%)</option>
				
				<option value="file26">github.com/ryabkov82/shortener/internal/app/jwtauth/jwtauth.go (100.0%)</option>
				
				<option value="file27">github.com/ryabkov82/shortener/internal/app/logger/logger.go (80.0%)</option>
				
				<option value="file28">github.com/ryabkov82/shortener/internal/app/pprof/routes.go (77.4%)</option>
				
				<option value="file29">github.com/ryabkov82/shortener/internal/app/server/grpc/interceptors/jwt_auth.go (34.8%)</option>
				
				<option value="file30">github.com/ryabkov82/shortener/internal/app/server/grpc/interceptors/logger.go (100.0%)</option>
				
				<option value="file31">github.com/ryabkov82/shortener/internal/app/server/grpc/interceptors/trusted_subnet.go (61.8%)</option>
				
				<option value="file32">github.com/ryabkov82/shortener/internal/app/server/grpc/server.go (0.0%)</option>
				
				<option value="file33">github.com/ryabkov82/shortener/internal/app/server/http/middleware/auth/auth.go (77.4%)</option>
				
				<option value="file34">github.com/ryabkov82/shortener/internal/app/server/http/middleware/logger/logger.go (100.0%)</option>
				
				<option value="file35">github.com/ryabkov82/shortener/internal/app/server/http/middleware/mwgzip/mwgzip.go (89.5%)</option>
				
				<option value="file36">github.com/ryabkov82/shortener/internal/app/server/http/middleware/trustednet/trustednet.go (77.8%)</option>
				
				<option value="file37">github.com/ryabkov82/shortener/internal/app/server/http/server.go (0.0%)</option>
				
				<option value="file38">github.com/ryabkov82/shortener/internal/app/server/run.go (0.0%)</option>
				
				<option value="file39">github.com/ryabkov82/shortener/internal/app/service/mocks/Repository.go (48.7%)</option>
				
				<option value="file40">github.com/ryabkov82/shortener/internal/app/service/service.go (87.2%)</option>
				
				<option value="file41">github.com/ryabkov82/shortener/internal/app/storage/inmemory/inmemory.go (63.0%)</option>
				
				<option value="file42">github.com/ryabkov82/shortener/internal/app/storage/postgres/migrate.go (66.7%)</option>
				
				<option value="file43">github.com/ryabkov82/shortener/internal/app/storage/postgres/postgres.go (64.6%)</option>
				
				<option value="file44">github.com/ryabkov82/shortener/internal/app/workers/deleteurls/deleteworker.go (63.1%)</option>
				
				<option value="file45">github.com/ryabkov82/shortener/test/testconfig/postgres.go (75.0%)</option>
				
				<option value="file46">github.com/ryabkov82/shortener/test/testhandlers/batch_grpc_tests.go (77.8%)</option>
				
				<option value="file47">github.com/ryabkov82/shortener/test/testhandlers/batch_http_tests.go (100.0%)</option>
				
				<option value="file48">github.com/ryabkov82/shortener/test/testhandlers/common_cases.go (84.6%)</option>
				
				<option value="file49">github.com/ryabkov82/shortener/test/testhandlers/deluserurls_tests.go (95.1%)</option>
				
				<option value="file50">github.com/ryabkov82/shortener/test/testhandlers/redirect_grpc_tests.go (95.5%)</option>
				
				<option value="file51">github.com/ryabkov82/shortener/test/testhandlers/redirect_http_tests.go (100.0%)</option>
				
				<option value="file52">github.com/ryabkov82/shortener/test/testhandlers/shortenapi_tests.go (100.0%)</option>
				
				<option value="file53">github.com/ryabkov82/shortener/test/testhandlers/shorturl_grpc_tests.go (94.7%)</option>
				
				<option value="file54">github.com/ryabkov82/shortener/test/testhandlers/shorturl_http_tests.go (100.0%)</option>
				
				<option value="file55">github.com/ryabkov82/shortener/test/testhandlers/userurls_tests.go (96.3%)</option>
				
				<option value="file56">github.com/ryabkov82/shortener/test/testutils/auth.go (29.6%)</option>
				
				<option value="file57">github.com/ryabkov82/shortener/test/testutils/client.go (100.0%)</option>
				
				<option value="file58">github.com/ryabkov82/shortener/test/testutils/grpc_client.go (88.6%)</option>
				
				<option value="file59">github.com/ryabkov82/shortener/test/testutils/inmemory.go (77.8%)</option>
				
				<option value="file60">github.com/ryabkov82/shortener/test/testutils/paths.go (75.0%)</option>
				
				<option value="file61">github.com/ryabkov82/shortener/test/testutils/status.go (42.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v6.31.1
// source: api/shortener.proto

package api

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OriginalUrl   string                 `protobuf:"bytes,1,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateRequest) Reset() <span class="cov3" title="3">{
        *x = CreateRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateRequest) String() string <span class="cov3" title="3">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateRequest) ProtoReflect() protoreflect.Message <span class="cov7" title="12">{
        mi := &amp;file_api_shortener_proto_msgTypes[0]
        if x != nil </span><span class="cov7" title="12">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov5" title="6">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov7" title="12">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateRequest.ProtoReflect.Descriptor instead.
func (*CreateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateRequest) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortUrl      string                 `protobuf:"bytes,1,opt,name=short_url,json=shortUrl,proto3" json:"short_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateResponse) Reset() <span class="cov1" title="1">{
        *x = CreateResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateResponse) ProtoReflect() protoreflect.Message <span class="cov2" title="2">{
        mi := &amp;file_api_shortener_proto_msgTypes[1]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateResponse.ProtoReflect.Descriptor instead.
func (*CreateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateResponse) GetShortUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortUrl      string                 `protobuf:"bytes,1,opt,name=short_url,json=shortUrl,proto3" json:"short_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() <span class="cov6" title="7">{
        *x = GetRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetRequest) String() string <span class="cov6" title="7">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetRequest) ProtoReflect() protoreflect.Message <span class="cov10" title="28">{
        mi := &amp;file_api_shortener_proto_msgTypes[2]
        if x != nil </span><span class="cov10" title="28">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="14">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov10" title="28">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetRequest) GetShortUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OriginalUrl   string                 `protobuf:"bytes,1,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        Deleted       bool                   `protobuf:"varint,2,opt,name=deleted,proto3" json:"deleted,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() <span class="cov2" title="2">{
        *x = GetResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetResponse) ProtoReflect() protoreflect.Message <span class="cov4" title="4">{
        mi := &amp;file_api_shortener_proto_msgTypes[3]
        if x != nil </span><span class="cov4" title="4">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov4" title="4">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov4" title="4">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetResponse) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetResponse) GetDeleted() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Deleted
        }</span>
        <span class="cov0" title="0">return false</span>
}

type PingRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PingRequest) Reset() <span class="cov2" title="2">{
        *x = PingRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingRequest) String() string <span class="cov2" title="2">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingRequest) ProtoReflect() protoreflect.Message <span class="cov7" title="10">{
        mi := &amp;file_api_shortener_proto_msgTypes[4]
        if x != nil </span><span class="cov7" title="10">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov4" title="4">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov7" title="10">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingRequest.ProtoReflect.Descriptor instead.
func (*PingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{4}
}</span>

type PingResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Ok            bool                   `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PingResponse) Reset() <span class="cov1" title="1">{
        *x = PingResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingResponse) ProtoReflect() protoreflect.Message <span class="cov2" title="2">{
        mi := &amp;file_api_shortener_proto_msgTypes[5]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingResponse.ProtoReflect.Descriptor instead.
func (*PingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{5}
}</span>

func (x *PingResponse) GetOk() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ok
        }</span>
        <span class="cov0" title="0">return false</span>
}

type StatsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatsRequest) Reset() <span class="cov4" title="4">{
        *x = StatsRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsRequest) String() string <span class="cov4" title="4">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsRequest) ProtoReflect() protoreflect.Message <span class="cov9" title="20">{
        mi := &amp;file_api_shortener_proto_msgTypes[6]
        if x != nil </span><span class="cov9" title="20">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov6" title="8">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov9" title="20">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsRequest.ProtoReflect.Descriptor instead.
func (*StatsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{6}
}</span>

type StatsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Urls          int64                  `protobuf:"varint,1,opt,name=urls,proto3" json:"urls,omitempty"`
        Users         int64                  `protobuf:"varint,2,opt,name=users,proto3" json:"users,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatsResponse) Reset() <span class="cov1" title="1">{
        *x = StatsResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsResponse) ProtoReflect() protoreflect.Message <span class="cov2" title="2">{
        mi := &amp;file_api_shortener_proto_msgTypes[7]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsResponse.ProtoReflect.Descriptor instead.
func (*StatsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{7}
}</span>

func (x *StatsResponse) GetUrls() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Urls
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetUsers() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Users
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UserURLsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UserURLsRequest) Reset() <span class="cov2" title="2">{
        *x = UserURLsRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserURLsRequest) String() string <span class="cov2" title="2">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserURLsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserURLsRequest) ProtoReflect() protoreflect.Message <span class="cov7" title="10">{
        mi := &amp;file_api_shortener_proto_msgTypes[8]
        if x != nil </span><span class="cov7" title="10">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov4" title="4">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov7" title="10">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserURLsRequest.ProtoReflect.Descriptor instead.
func (*UserURLsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{8}
}</span>

type UserURLsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Urls          []*UserURL             `protobuf:"bytes,1,rep,name=urls,proto3" json:"urls,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UserURLsResponse) Reset() <span class="cov2" title="2">{
        *x = UserURLsResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserURLsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserURLsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserURLsResponse) ProtoReflect() protoreflect.Message <span class="cov5" title="5">{
        mi := &amp;file_api_shortener_proto_msgTypes[9]
        if x != nil </span><span class="cov5" title="5">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov4" title="4">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov5" title="5">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserURLsResponse.ProtoReflect.Descriptor instead.
func (*UserURLsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{9}
}</span>

func (x *UserURLsResponse) GetUrls() []*UserURL <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Urls
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UserURL struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortUrl      string                 `protobuf:"bytes,1,opt,name=short_url,json=shortUrl,proto3" json:"short_url,omitempty"`
        OriginalUrl   string                 `protobuf:"bytes,2,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UserURL) Reset() <span class="cov0" title="0">{
        *x = UserURL{}
        mi := &amp;file_api_shortener_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserURL) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserURL) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserURL) ProtoReflect() protoreflect.Message <span class="cov3" title="3">{
        mi := &amp;file_api_shortener_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov3" title="3">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserURL.ProtoReflect.Descriptor instead.
func (*UserURL) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{10}
}</span>

func (x *UserURL) GetShortUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserURL) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortUrls     []string               `protobuf:"bytes,1,rep,name=short_urls,json=shortUrls,proto3" json:"short_urls,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteRequest) Reset() <span class="cov4" title="4">{
        *x = DeleteRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteRequest) String() string <span class="cov4" title="4">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteRequest) ProtoReflect() protoreflect.Message <span class="cov8" title="16">{
        mi := &amp;file_api_shortener_proto_msgTypes[11]
        if x != nil </span><span class="cov8" title="16">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov6" title="8">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="16">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteRequest.ProtoReflect.Descriptor instead.
func (*DeleteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{11}
}</span>

func (x *DeleteRequest) GetShortUrls() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrls
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteResponse) Reset() <span class="cov4" title="4">{
        *x = DeleteResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteResponse) ProtoReflect() protoreflect.Message <span class="cov7" title="12">{
        mi := &amp;file_api_shortener_proto_msgTypes[12]
        if x != nil </span><span class="cov7" title="12">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov6" title="8">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov7" title="12">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteResponse.ProtoReflect.Descriptor instead.
func (*DeleteResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{12}
}</span>

type BatchCreateRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*BatchCreateItem     `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchCreateRequest) Reset() <span class="cov1" title="1">{
        *x = BatchCreateRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchCreateRequest) String() string <span class="cov1" title="1">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchCreateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchCreateRequest) ProtoReflect() protoreflect.Message <span class="cov4" title="4">{
        mi := &amp;file_api_shortener_proto_msgTypes[13]
        if x != nil </span><span class="cov4" title="4">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov4" title="4">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchCreateRequest.ProtoReflect.Descriptor instead.
func (*BatchCreateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{13}
}</span>

func (x *BatchCreateRequest) GetItems() []*BatchCreateItem <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchCreateItem struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        CorrelationId string                 `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
        OriginalUrl   string                 `protobuf:"bytes,2,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchCreateItem) Reset() <span class="cov0" title="0">{
        *x = BatchCreateItem{}
        mi := &amp;file_api_shortener_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchCreateItem) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchCreateItem) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchCreateItem) ProtoReflect() protoreflect.Message <span class="cov5" title="5">{
        mi := &amp;file_api_shortener_proto_msgTypes[14]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov3" title="3">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchCreateItem.ProtoReflect.Descriptor instead.
func (*BatchCreateItem) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{14}
}</span>

func (x *BatchCreateItem) GetCorrelationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CorrelationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BatchCreateItem) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BatchCreateResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*BatchCreateResult   `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchCreateResponse) Reset() <span class="cov1" title="1">{
        *x = BatchCreateResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchCreateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchCreateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchCreateResponse) ProtoReflect() protoreflect.Message <span class="cov2" title="2">{
        mi := &amp;file_api_shortener_proto_msgTypes[15]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchCreateResponse.ProtoReflect.Descriptor instead.
func (*BatchCreateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{15}
}</span>

func (x *BatchCreateResponse) GetItems() []*BatchCreateResult <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchCreateResult struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        CorrelationId string                 `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
        ShortUrl      string                 `protobuf:"bytes,2,opt,name=short_url,json=shortUrl,proto3" json:"short_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchCreateResult) Reset() <span class="cov0" title="0">{
        *x = BatchCreateResult{}
        mi := &amp;file_api_shortener_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchCreateResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchCreateResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchCreateResult) ProtoReflect() protoreflect.Message <span class="cov3" title="3">{
        mi := &amp;file_api_shortener_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov3" title="3">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchCreateResult.ProtoReflect.Descriptor instead.
func (*BatchCreateResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{16}
}</span>

func (x *BatchCreateResult) GetCorrelationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CorrelationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BatchCreateResult) GetShortUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_api_shortener_proto protoreflect.FileDescriptor

const file_api_shortener_proto_rawDesc = "" +
        "\n" +
        "\x13api/shortener.proto\x12\tshortener\"2\n" +
        "\rCreateRequest\x12!\n" +
        "\foriginal_url\x18\x01 \x01(\tR\voriginalUrl\"-\n" +
        "\x0eCreateResponse\x12\x1b\n" +
        "\tshort_url\x18\x01 \x01(\tR\bshortUrl\")\n" +
        "\n" +
        "GetRequest\x12\x1b\n" +
        "\tshort_url\x18\x01 \x01(\tR\bshortUrl\"J\n" +
        "\vGetResponse\x12!\n" +
        "\foriginal_url\x18\x01 \x01(\tR\voriginalUrl\x12\x18\n" +
        "\adeleted\x18\x02 \x01(\bR\adeleted\"\r\n" +
        "\vPingRequest\"\x1e\n" +
        "\fPingResponse\x12\x0e\n" +
        "\x02ok\x18\x01 \x01(\bR\x02ok\"\x0e\n" +
        "\fStatsRequest\"9\n" +
        "\rStatsResponse\x12\x12\n" +
        "\x04urls\x18\x01 \x01(\x03R\x04urls\x12\x14\n" +
        "\x05users\x18\x02 \x01(\x03R\x05users\"\x11\n" +
        "\x0fUserURLsRequest\":\n" +
        "\x10UserURLsResponse\x12&amp;\n" +
        "\x04urls\x18\x01 \x03(\v2\x12.shortener.UserURLR\x04urls\"I\n" +
        "\aUserURL\x12\x1b\n" +
        "\tshort_url\x18\x01 \x01(\tR\bshortUrl\x12!\n" +
        "\foriginal_url\x18\x02 \x01(\tR\voriginalUrl\".\n" +
        "\rDeleteRequest\x12\x1d\n" +
        "\n" +
        "short_urls\x18\x01 \x03(\tR\tshortUrls\"\x10\n" +
        "\x0eDeleteResponse\"F\n" +
        "\x12BatchCreateRequest\x120\n" +
        "\x05items\x18\x01 \x03(\v2\x1a.shortener.BatchCreateItemR\x05items\"[\n" +
        "\x0fBatchCreateItem\x12%\n" +
        "\x0ecorrelation_id\x18\x01 \x01(\tR\rcorrelationId\x12!\n" +
        "\foriginal_url\x18\x02 \x01(\tR\voriginalUrl\"I\n" +
        "\x13BatchCreateResponse\x122\n" +
        "\x05items\x18\x01 \x03(\v2\x1c.shortener.BatchCreateResultR\x05items\"W\n" +
        "\x11BatchCreateResult\x12%\n" +
        "\x0ecorrelation_id\x18\x01 \x01(\tR\rcorrelationId\x12\x1b\n" +
        "\tshort_url\x18\x02 \x01(\tR\bshortUrl2\xe8\x03\n" +
        "\tShortener\x12E\n" +
        "\x0eCreateShortURL\x12\x18.shortener.CreateRequest\x1a\x19.shortener.CreateResponse\x12?\n" +
        "\x0eGetOriginalURL\x12\x15.shortener.GetRequest\x1a\x16.shortener.GetResponse\x127\n" +
        "\x04Ping\x12\x16.shortener.PingRequest\x1a\x17.shortener.PingResponse\x12=\n" +
        "\bGetStats\x12\x17.shortener.StatsRequest\x1a\x18.shortener.StatsResponse\x12F\n" +
        "\vGetUserURLs\x12\x1a.shortener.UserURLsRequest\x1a\x1b.shortener.UserURLsResponse\x12E\n" +
        "\x0eDeleteUserURLs\x12\x18.shortener.DeleteRequest\x1a\x19.shortener.DeleteResponse\x12L\n" +
        "\vBatchCreate\x12\x1d.shortener.BatchCreateRequest\x1a\x1e.shortener.BatchCreateResponseB(Z&amp;github.com/ryabkov82/shortener/api;apib\x06proto3"

var (
        file_api_shortener_proto_rawDescOnce sync.Once
        file_api_shortener_proto_rawDescData []byte
)

func file_api_shortener_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_shortener_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_shortener_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_shortener_proto_rawDesc), len(file_api_shortener_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_api_shortener_proto_rawDescData</span>
}

var file_api_shortener_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_api_shortener_proto_goTypes = []any{
        (*CreateRequest)(nil),       // 0: shortener.CreateRequest
        (*CreateResponse)(nil),      // 1: shortener.CreateResponse
        (*GetRequest)(nil),          // 2: shortener.GetRequest
        (*GetResponse)(nil),         // 3: shortener.GetResponse
        (*PingRequest)(nil),         // 4: shortener.PingRequest
        (*PingResponse)(nil),        // 5: shortener.PingResponse
        (*StatsRequest)(nil),        // 6: shortener.StatsRequest
        (*StatsResponse)(nil),       // 7: shortener.StatsResponse
        (*UserURLsRequest)(nil),     // 8: shortener.UserURLsRequest
        (*UserURLsResponse)(nil),    // 9: shortener.UserURLsResponse
        (*UserURL)(nil),             // 10: shortener.UserURL
        (*DeleteRequest)(nil),       // 11: shortener.DeleteRequest
        (*DeleteResponse)(nil),      // 12: shortener.DeleteResponse
        (*BatchCreateRequest)(nil),  // 13: shortener.BatchCreateRequest
        (*BatchCreateItem)(nil),     // 14: shortener.BatchCreateItem
        (*BatchCreateResponse)(nil), // 15: shortener.BatchCreateResponse
        (*BatchCreateResult)(nil),   // 16: shortener.BatchCreateResult
}
var file_api_shortener_proto_depIdxs = []int32{
        10, // 0: shortener.UserURLsResponse.urls:type_name -&gt; shortener.UserURL
        14, // 1: shortener.BatchCreateRequest.items:type_name -&gt; shortener.BatchCreateItem
        16, // 2: shortener.BatchCreateResponse.items:type_name -&gt; shortener.BatchCreateResult
        0,  // 3: shortener.Shortener.CreateShortURL:input_type -&gt; shortener.CreateRequest
        2,  // 4: shortener.Shortener.GetOriginalURL:input_type -&gt; shortener.GetRequest
        4,  // 5: shortener.Shortener.Ping:input_type -&gt; shortener.PingRequest
        6,  // 6: shortener.Shortener.GetStats:input_type -&gt; shortener.StatsRequest
        8,  // 7: shortener.Shortener.GetUserURLs:input_type -&gt; shortener.UserURLsRequest
        11, // 8: shortener.Shortener.DeleteUserURLs:input_type -&gt; shortener.DeleteRequest
        13, // 9: shortener.Shortener.BatchCreate:input_type -&gt; shortener.BatchCreateRequest
        1,  // 10: shortener.Shortener.CreateShortURL:output_type -&gt; shortener.CreateResponse
        3,  // 11: shortener.Shortener.GetOriginalURL:output_type -&gt; shortener.GetResponse
        5,  // 12: shortener.Shortener.Ping:output_type -&gt; shortener.PingResponse
        7,  // 13: shortener.Shortener.GetStats:output_type -&gt; shortener.StatsResponse
        9,  // 14: shortener.Shortener.GetUserURLs:output_type -&gt; shortener.UserURLsResponse
        12, // 15: shortener.Shortener.DeleteUserURLs:output_type -&gt; shortener.DeleteResponse
        15, // 16: shortener.Shortener.BatchCreate:output_type -&gt; shortener.BatchCreateResponse
        10, // [10:17] is the sub-list for method output_type
        3,  // [3:10] is the sub-list for method input_type
        3,  // [3:3] is the sub-list for extension type_name
        3,  // [3:3] is the sub-list for extension extendee
        0,  // [0:3] is the sub-list for field type_name
}

func init() <span class="cov8" title="14">{ file_api_shortener_proto_init() }</span>
func file_api_shortener_proto_init() <span class="cov8" title="14">{
        if File_api_shortener_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="14">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_shortener_proto_rawDesc), len(file_api_shortener_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   17,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_shortener_proto_goTypes,
                DependencyIndexes: file_api_shortener_proto_depIdxs,
                MessageInfos:      file_api_shortener_proto_msgTypes,
        }.Build()
        File_api_shortener_proto = out.File
        file_api_shortener_proto_goTypes = nil
        file_api_shortener_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: api/shortener.proto

package api

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Shortener_CreateShortURL_FullMethodName = "/shortener.Shortener/CreateShortURL"
        Shortener_GetOriginalURL_FullMethodName = "/shortener.Shortener/GetOriginalURL"
        Shortener_Ping_FullMethodName           = "/shortener.Shortener/Ping"
        Shortener_GetStats_FullMethodName       = "/shortener.Shortener/GetStats"
        Shortener_GetUserURLs_FullMethodName    = "/shortener.Shortener/GetUserURLs"
        Shortener_DeleteUserURLs_FullMethodName = "/shortener.Shortener/DeleteUserURLs"
        Shortener_BatchCreate_FullMethodName    = "/shortener.Shortener/BatchCreate"
)

// ShortenerClient is the client API for Shortener service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShortenerClient interface {
        CreateShortURL(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
        GetOriginalURL(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
        Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
        GetStats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error)
        GetUserURLs(ctx context.Context, in *UserURLsRequest, opts ...grpc.CallOption) (*UserURLsResponse, error)
        DeleteUserURLs(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
        BatchCreate(ctx context.Context, in *BatchCreateRequest, opts ...grpc.CallOption) (*BatchCreateResponse, error)
}

type shortenerClient struct {
        cc grpc.ClientConnInterface
}

func NewShortenerClient(cc grpc.ClientConnInterface) ShortenerClient <span class="cov10" title="10">{
        return &amp;shortenerClient{cc}
}</span>

func (c *shortenerClient) CreateShortURL(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) <span class="cov5" title="3">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateResponse)
        err := c.cc.Invoke(ctx, Shortener_CreateShortURL_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return out, nil</span>
}

func (c *shortenerClient) GetOriginalURL(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) <span class="cov8" title="7">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetResponse)
        err := c.cc.Invoke(ctx, Shortener_GetOriginalURL_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov7" title="5">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return out, nil</span>
}

func (c *shortenerClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) <span class="cov3" title="2">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PingResponse)
        err := c.cc.Invoke(ctx, Shortener_Ping_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return out, nil</span>
}

func (c *shortenerClient) GetStats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error) <span class="cov6" title="4">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatsResponse)
        err := c.cc.Invoke(ctx, Shortener_GetStats_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov5" title="3">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return out, nil</span>
}

func (c *shortenerClient) GetUserURLs(ctx context.Context, in *UserURLsRequest, opts ...grpc.CallOption) (*UserURLsResponse, error) <span class="cov3" title="2">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UserURLsResponse)
        err := c.cc.Invoke(ctx, Shortener_GetUserURLs_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return out, nil</span>
}

func (c *shortenerClient) DeleteUserURLs(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) <span class="cov6" title="4">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteResponse)
        err := c.cc.Invoke(ctx, Shortener_DeleteUserURLs_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="4">return out, nil</span>
}

func (c *shortenerClient) BatchCreate(ctx context.Context, in *BatchCreateRequest, opts ...grpc.CallOption) (*BatchCreateResponse, error) <span class="cov1" title="1">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(BatchCreateResponse)
        err := c.cc.Invoke(ctx, Shortener_BatchCreate_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return out, nil</span>
}

// ShortenerServer is the server API for Shortener service.
// All implementations must embed UnimplementedShortenerServer
// for forward compatibility.
type ShortenerServer interface {
        CreateShortURL(context.Context, *CreateRequest) (*CreateResponse, error)
        GetOriginalURL(context.Context, *GetRequest) (*GetResponse, error)
        Ping(context.Context, *PingRequest) (*PingResponse, error)
        GetStats(context.Context, *StatsRequest) (*StatsResponse, error)
        GetUserURLs(context.Context, *UserURLsRequest) (*UserURLsResponse, error)
        DeleteUserURLs(context.Context, *DeleteRequest) (*DeleteResponse, error)
        BatchCreate(context.Context, *BatchCreateRequest) (*BatchCreateResponse, error)
        mustEmbedUnimplementedShortenerServer()
}

// UnimplementedShortenerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedShortenerServer struct{}

func (UnimplementedShortenerServer) CreateShortURL(context.Context, *CreateRequest) (*CreateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateShortURL not implemented")
}</span>
func (UnimplementedShortenerServer) GetOriginalURL(context.Context, *GetRequest) (*GetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOriginalURL not implemented")
}</span>
func (UnimplementedShortenerServer) Ping(context.Context, *PingRequest) (*PingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}</span>
func (UnimplementedShortenerServer) GetStats(context.Context, *StatsRequest) (*StatsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}</span>
func (UnimplementedShortenerServer) GetUserURLs(context.Context, *UserURLsRequest) (*UserURLsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserURLs not implemented")
}</span>
func (UnimplementedShortenerServer) DeleteUserURLs(context.Context, *DeleteRequest) (*DeleteResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteUserURLs not implemented")
}</span>
func (UnimplementedShortenerServer) BatchCreate(context.Context, *BatchCreateRequest) (*BatchCreateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}</span>
func (UnimplementedShortenerServer) mustEmbedUnimplementedShortenerServer() {<span class="cov0" title="0">}</span>
func (UnimplementedShortenerServer) testEmbeddedByValue()                   {<span class="cov10" title="10">}</span>

// UnsafeShortenerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShortenerServer will
// result in compilation errors.
type UnsafeShortenerServer interface {
        mustEmbedUnimplementedShortenerServer()
}

func RegisterShortenerServer(s grpc.ServiceRegistrar, srv ShortenerServer) <span class="cov10" title="10">{
        // If the following call pancis, it indicates UnimplementedShortenerServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov10" title="10">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov10" title="10">s.RegisterService(&amp;Shortener_ServiceDesc, srv)</span>
}

func _Shortener_CreateShortURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov5" title="3">{
        in := new(CreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="3">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).CreateShortURL(ctx, in)
        }</span>
        <span class="cov5" title="3">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_CreateShortURL_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov5" title="3">{
                return srv.(ShortenerServer).CreateShortURL(ctx, req.(*CreateRequest))
        }</span>
        <span class="cov5" title="3">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_GetOriginalURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="7">{
        in := new(GetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="7">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).GetOriginalURL(ctx, in)
        }</span>
        <span class="cov8" title="7">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_GetOriginalURL_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="7">{
                return srv.(ShortenerServer).GetOriginalURL(ctx, req.(*GetRequest))
        }</span>
        <span class="cov8" title="7">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov3" title="2">{
        in := new(PingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).Ping(ctx, in)
        }</span>
        <span class="cov3" title="2">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_Ping_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov3" title="2">{
                return srv.(ShortenerServer).Ping(ctx, req.(*PingRequest))
        }</span>
        <span class="cov3" title="2">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov6" title="4">{
        in := new(StatsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="4">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).GetStats(ctx, in)
        }</span>
        <span class="cov6" title="4">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_GetStats_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov5" title="3">{
                return srv.(ShortenerServer).GetStats(ctx, req.(*StatsRequest))
        }</span>
        <span class="cov6" title="4">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_GetUserURLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov3" title="2">{
        in := new(UserURLsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).GetUserURLs(ctx, in)
        }</span>
        <span class="cov3" title="2">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_GetUserURLs_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov3" title="2">{
                return srv.(ShortenerServer).GetUserURLs(ctx, req.(*UserURLsRequest))
        }</span>
        <span class="cov3" title="2">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_DeleteUserURLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov6" title="4">{
        in := new(DeleteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="4">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).DeleteUserURLs(ctx, in)
        }</span>
        <span class="cov6" title="4">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_DeleteUserURLs_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov6" title="4">{
                return srv.(ShortenerServer).DeleteUserURLs(ctx, req.(*DeleteRequest))
        }</span>
        <span class="cov6" title="4">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov1" title="1">{
        in := new(BatchCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).BatchCreate(ctx, in)
        }</span>
        <span class="cov1" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_BatchCreate_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov1" title="1">{
                return srv.(ShortenerServer).BatchCreate(ctx, req.(*BatchCreateRequest))
        }</span>
        <span class="cov1" title="1">return interceptor(ctx, in, info, handler)</span>
}

// Shortener_ServiceDesc is the grpc.ServiceDesc for Shortener service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Shortener_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "shortener.Shortener",
        HandlerType: (*ShortenerServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateShortURL",
                        Handler:    _Shortener_CreateShortURL_Handler,
                },
                {
                        MethodName: "GetOriginalURL",
                        Handler:    _Shortener_GetOriginalURL_Handler,
                },
                {
                        MethodName: "Ping",
                        Handler:    _Shortener_Ping_Handler,
                },
                {
                        MethodName: "GetStats",
                        Handler:    _Shortener_GetStats_Handler,
                },
                {
                        MethodName: "GetUserURLs",
                        Handler:    _Shortener_GetUserURLs_Handler,
                },
                {
                        MethodName: "DeleteUserURLs",
                        Handler:    _Shortener_DeleteUserURLs_Handler,
                },
                {
                        MethodName: "BatchCreate",
                        Handler:    _Shortener_BatchCreate_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/shortener.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bufio"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "strings"
)

func main() <span class="cov0" title="0">{
        endpoint := "http://localhost:8080/"
        // контейнер данных для запроса
        data := url.Values{}
        // приглашение в консоли
        fmt.Println("Введите длинный URL")
        // открываем потоковое чтение из консоли
        reader := bufio.NewReader(os.Stdin)
        // читаем строку из консоли
        long, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">long = strings.TrimSuffix(long, "\n")
        long = strings.TrimSuffix(long, "\r")
        // заполняем контейнер данными
        data.Set("url", long)
        // добавляем HTTP-клиент
        client := &amp;http.Client{}
        // пишем запрос
        // запрос методом POST должен, помимо заголовков, содержать тело
        // тело должно быть источником потокового чтения io.Reader
        request, err := http.NewRequest(http.MethodPost, endpoint, strings.NewReader(long))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // в заголовках запроса указываем кодировку
        // request.Header.Add("Content-Type", "application/x-www-form-urlencoded")
        // отправляем запрос и получаем ответ
        <span class="cov0" title="0">response, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // выводим код ответа
        <span class="cov0" title="0">fmt.Println("Статус-код ", response.Status)
        defer response.Body.Close()
        // читаем поток из тела ответа
        body, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // и печатаем его
        <span class="cov0" title="0">fmt.Println(string(body))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bufio"
        "fmt"
        "log"
        "os"
        "regexp"
        "strings"
        "text/template"
)

type Method struct {
        Name       string
        Request    string
        Response   string
        HandlerVar string
}

const tmpl = `// Code generated by genserver from proto; DO NOT EDIT.

package grpchandlers

import (
        "context"

        "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type ServerOption func(s *Server)

{{range .}}
type {{.Name}}Endpoint interface {
        {{.Name}}(ctx context.Context, req *api.{{.Request}}) (*api.{{.Response}}, error)
}

func With{{.Name}}Endpoint(h {{.Name}}Endpoint) ServerOption {
        return func(s *Server) {
                s.{{.HandlerVar}} = h
        }
}
{{end}}

type Server struct {
        api.UnimplementedShortenerServer
        *base.BaseHandler

        {{range .}}{{.HandlerVar}} {{.Name}}Endpoint
        {{end}}
}

func NewServer(baseHandler *base.BaseHandler, opts ...ServerOption) *Server {
        s := &amp;Server{BaseHandler: baseHandler}
        for _, opt := range opts {
                opt(s)
        }
        return s
}

{{range .}}
func (s *Server) {{.Name}}(ctx context.Context, req *api.{{.Request}}) (*api.{{.Response}}, error) {
        if s.{{.HandlerVar}} == nil {
                return nil, status.Error(codes.Unimplemented, "{{.Name}} handler not provided")
        }
        return s.{{.HandlerVar}}.{{.Name}}(ctx, req)
}
{{end}}
`

func main() <span class="cov0" title="0">{
        protoFile := "./api/shortener.proto"

        f, err := os.Open(protoFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to open proto file: %v", err)
        }</span>
        <span class="cov0" title="0">defer f.Close()

        rpcRe := regexp.MustCompile(`rpc\s+(\w+)\s*\(\s*(\w+)\s*\)\s+returns\s*\(\s*(\w+)\s*\);`)
        serviceStartRe := regexp.MustCompile(`service\s+(\w+)\s*{`)

        var inService bool
        var methods []Method

        scanner := bufio.NewScanner(f)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                if !inService </span><span class="cov0" title="0">{
                        if serviceStartRe.MatchString(line) </span><span class="cov0" title="0">{
                                inService = true
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if line == "}" </span><span class="cov0" title="0">{
                        inService = false
                        break</span>
                }

                <span class="cov0" title="0">matches := rpcRe.FindStringSubmatch(line)
                if len(matches) == 4 </span><span class="cov0" title="0">{
                        name := matches[1]
                        req := matches[2]
                        resp := matches[3]

                        methods = append(methods, Method{
                                Name:       name,
                                Request:    req,
                                Response:   resp,
                                HandlerVar: name + "Handler",
                        })
                }</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("reading proto file error: %v", err)
        }</span>

        // Генерируем файл
        <span class="cov0" title="0">t := template.Must(template.New("server").Parse(tmpl))
        outFile := "./internal/app/handlers/grpc/server_gen.go"
        out, err := os.Create(outFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot create output file: %v", err)
        }</span>
        <span class="cov0" title="0">defer out.Close()

        if err := t.Execute(out, methods); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("template execution failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("server_gen.go успешно сгенерирован: %s\n", outFile)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Пакет main предоставляет точку входа для сервиса сокращения URL.
//
// Основные функции:
//
//   - Инициализация конфигурации системы
//   - Настройка логгера
//   - Запуск HTTP сервера
package main

import (
        "fmt"
        "os"

        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/logger"
        "github.com/ryabkov82/shortener/internal/app/server"
)

var (
        buildVersion string
        buildDate    string
        buildCommit  string
)

func main() <span class="cov0" title="0">{

        printBuildInfo()

        cfg := config.Load()

        if err := logger.Initialize(cfg.LogLevel); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Запуск сервера с использованием конфигурации
        // log.Printf("Starting server on %s with base URL %s", cfg.HTTPServerAddr, cfg.BaseURL)
        <span class="cov0" title="0">server.StartServers(logger.Log, cfg)</span>

}

func printBuildInfo() <span class="cov0" title="0">{
        // Set default value "N/A" if variables are empty
        if buildVersion == "" </span><span class="cov0" title="0">{
                buildVersion = "N/A"
        }</span>
        <span class="cov0" title="0">if buildDate == "" </span><span class="cov0" title="0">{
                buildDate = "N/A"
        }</span>
        <span class="cov0" title="0">if buildCommit == "" </span><span class="cov0" title="0">{
                buildCommit = "N/A"
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(os.Stdout, "Build version: %s\n", buildVersion)
        fmt.Fprintf(os.Stdout, "Build date: %s\n", buildDate)
        fmt.Fprintf(os.Stdout, "Build commit: %s\n", buildCommit)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package staticlint представляет собой комплексный статический анализатор для проекта Shortener.
// Он объединяет:
// - стандартные анализаторы go/analysis
// - анализаторы staticcheck
// - дополнительные сторонние анализаторы
//
// Для запуска:
//
//        go run cmd/staticlint/main.go ./...
//
// Для установки и использования как standalone-инструмента:
//
//        go install github.com/ryabkov82/shortener/cmd/staticlint
//        staticlint ./...
package main

import (
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/asmdecl"
        "golang.org/x/tools/go/analysis/passes/assign"
        "golang.org/x/tools/go/analysis/passes/atomic"
        "golang.org/x/tools/go/analysis/passes/bools"
        "golang.org/x/tools/go/analysis/passes/buildtag"
        "golang.org/x/tools/go/analysis/passes/cgocall"
        "golang.org/x/tools/go/analysis/passes/composite"
        "golang.org/x/tools/go/analysis/passes/copylock"
        "golang.org/x/tools/go/analysis/passes/deepequalerrors"
        "golang.org/x/tools/go/analysis/passes/errorsas"
        "golang.org/x/tools/go/analysis/passes/fieldalignment"
        "golang.org/x/tools/go/analysis/passes/httpresponse"
        "golang.org/x/tools/go/analysis/passes/ifaceassert"
        "golang.org/x/tools/go/analysis/passes/loopclosure"
        "golang.org/x/tools/go/analysis/passes/lostcancel"
        "golang.org/x/tools/go/analysis/passes/nilfunc"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/shift"
        "golang.org/x/tools/go/analysis/passes/sigchanyzer"
        "golang.org/x/tools/go/analysis/passes/stdmethods"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "golang.org/x/tools/go/analysis/passes/testinggoroutine"
        "golang.org/x/tools/go/analysis/passes/unmarshal"
        "golang.org/x/tools/go/analysis/passes/unreachable"
        "golang.org/x/tools/go/analysis/passes/unsafeptr"
        "golang.org/x/tools/go/analysis/passes/unusedresult"

        "honnef.co/go/tools/quickfix"
        "honnef.co/go/tools/simple"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck"

        "github.com/go-critic/go-critic/checkers/analyzer"
        "github.com/timakin/bodyclose/passes/bodyclose"

        "github.com/ryabkov82/shortener/cmd/staticlint/noosexit"
)

func main() <span class="cov0" title="0">{
        analyzers := setupAnalyzers()
        multichecker.Main(analyzers...)
}</span>

func setupAnalyzers() []*analysis.Analyzer <span class="cov1" title="1">{

        // Стандартные анализаторы из golang.org/x/tools/go/analysis/passes
        standardAnalyzers := []*analysis.Analyzer{
                asmdecl.Analyzer,          // проверяет корректность объявлений ассемблерного кода
                assign.Analyzer,           // обнаруживает бесполезные присваивания
                atomic.Analyzer,           // проверяет правильность использования sync/atomic
                bools.Analyzer,            // обнаруживает распространенные ошибки с булевыми операторами
                buildtag.Analyzer,         // проверяет корректность build тегов
                cgocall.Analyzer,          // проверяет корректность вызовов CGO
                composite.Analyzer,        // проверяет композитные литералы без ключей
                copylock.Analyzer,         // проверяет копирование мьютексов
                deepequalerrors.Analyzer,  // проверяет использование deep equal с ошибками
                errorsas.Analyzer,         // проверяет правильность использования errors.As
                fieldalignment.Analyzer,   // предлагает оптимальное выравнивание полей структур
                httpresponse.Analyzer,     // проверяет закрытие HTTP response bodies
                ifaceassert.Analyzer,      // обнаруживает бессмысленные type assertions
                loopclosure.Analyzer,      // проверяет захват переменных в замыканиях
                lostcancel.Analyzer,       // проверяет утечку контекста
                nilfunc.Analyzer,          // обнаруживает сравнения функций с nil
                printf.Analyzer,           // проверяет формат строки в Printf-функциях
                shadow.Analyzer,           // обнаруживает затенение переменных
                shift.Analyzer,            // проверяет сдвиги превышающие размер типа
                sigchanyzer.Analyzer,      // проверяет неправильное использование каналов в signal.Notify
                stdmethods.Analyzer,       // проверяет соответствие стандартным интерфейсам
                structtag.Analyzer,        // проверяет корректность тегов структур
                testinggoroutine.Analyzer, // обнаруживает утечку горутин в тестах
                unmarshal.Analyzer,        // проверяет правильность передачи указателей в Unmarshal
                unreachable.Analyzer,      // обнаруживает недостижимый код
                unsafeptr.Analyzer,        // проверяет корректность преобразований unsafe.Pointer
                unusedresult.Analyzer,     // проверяет неиспользованные результаты функций
        }

        // Анализаторы класса SA из staticcheck.io (Static Analysis)
        var saAnalyzers []*analysis.Analyzer
        for _, v := range staticcheck.Analyzers </span><span class="cov10" title="90">{
                if v.Analyzer.Name[:2] == "SA" </span><span class="cov10" title="90">{
                        saAnalyzers = append(saAnalyzers, v.Analyzer)
                }</span>
        }

        // Дополнительные анализаторы из других классов staticcheck
        <span class="cov1" title="1">var otherStaticcheckAnalyzers []*analysis.Analyzer

        // Добавляем анализаторы из stylecheck
        for _, a := range stylecheck.Analyzers </span><span class="cov3" title="3">{
                if a.Analyzer.Name == "ST1000" </span><span class="cov1" title="1">{ // проверка документации пакета
                        otherStaticcheckAnalyzers = append(otherStaticcheckAnalyzers, a.Analyzer)
                        break</span>
                }
        }

        // Добавляем анализаторы из simple
        <span class="cov1" title="1">for _, a := range simple.Analyzers </span><span class="cov7" title="33">{
                if a.Analyzer.Name == "S1002" </span><span class="cov1" title="1">{ // предлагает упрощение булевых выражений
                        otherStaticcheckAnalyzers = append(otherStaticcheckAnalyzers, a.Analyzer)
                        break</span>
                }
        }

        // Добавляем анализаторы из quickfix
        <span class="cov1" title="1">for _, a := range quickfix.Analyzers </span><span class="cov4" title="7">{
                if a.Analyzer.Name == "QF1001" </span><span class="cov1" title="1">{ // применяет законы Де Моргана
                        otherStaticcheckAnalyzers = append(otherStaticcheckAnalyzers, a.Analyzer)
                        break</span>
                }
        }

        // Сторонние анализаторы
        <span class="cov1" title="1">externalAnalyzers := []*analysis.Analyzer{
                bodyclose.Analyzer, // проверяет закрытие response.Body
                analyzer.Analyzer,  // go-critic, выявляет потенциальные ошибки, неэффективности и плохие практики программирования
        }

        // Собственные анализаторы
        customAnalyzers := []*analysis.Analyzer{
                noosexit.NoOsExitAnalyzer,
        }

        // Объединяем все анализаторы
        var analyzers []*analysis.Analyzer
        analyzers = append(analyzers, standardAnalyzers...)
        analyzers = append(analyzers, saAnalyzers...)
        analyzers = append(analyzers, otherStaticcheckAnalyzers...)
        analyzers = append(analyzers, externalAnalyzers...)
        analyzers = append(analyzers, customAnalyzers...)

        return analyzers</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package noosexit проверяет отсутствие прямых вызовов os.Exit в функции main пакета main
package noosexit

import (
        "go/ast"
        "path/filepath"
        "strings"

        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/ast/inspector"
)

const doc = `noosexit проверяет отсутствие прямых вызовов os.Exit в функции main пакета main

Анализатор запрещает использование os.Exit() в функции main() основного пакета,
рекомендуя вместо этого возвращать ошибки или использовать log.Fatal().`

// NoOsExitAnalyzer анализатор для проверки вызовов os.Exit
var NoOsExitAnalyzer = &amp;analysis.Analyzer{
        Name:     "noosexit",
        Doc:      doc,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
        Run:      run,
}

func run(pass *analysis.Pass) (interface{}, error) <span class="cov10" title="2">{

        // Проверяем, что пакет находится в директории cmd
        if !isCmdPackage(pass.Pkg.Path()) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Используем inspector для более эффективного обхода AST
        <span class="cov10" title="2">inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

        // Фильтруем только вызовы функций
        nodeFilter := []ast.Node{
                (*ast.CallExpr)(nil),
        }

        // Проверяем, находимся ли мы в пакете main и функции main
        inspect.Preorder(nodeFilter, func(n ast.Node) </span><span class="cov10" title="2">{
                call := n.(*ast.CallExpr)
                fun, ok := call.Fun.(*ast.SelectorExpr)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                // Проверяем что это вызов os.Exit
                <span class="cov10" title="2">if ident, ok := fun.X.(*ast.Ident); ok </span><span class="cov10" title="2">{
                        if ident.Name == "os" &amp;&amp; fun.Sel.Name == "Exit" </span><span class="cov1" title="1">{
                                // Проверяем что находимся в функции main пакета main
                                if pass.Pkg.Name() == "main" </span><span class="cov1" title="1">{
                                        // Проверяем что находимся внутри функции main
                                        for _, f := range pass.Files </span><span class="cov1" title="1">{
                                                for _, decl := range f.Decls </span><span class="cov10" title="2">{
                                                        if fd, ok := decl.(*ast.FuncDecl); ok &amp;&amp; fd.Name.Name == "main" </span><span class="cov1" title="1">{
                                                                pass.Reportf(call.Pos(), "прямой вызов os.Exit в функции main запрещен, используйте log.Fatal() или возврат ошибки")
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        })

        <span class="cov10" title="2">return nil, nil</span>
}

// isCmdPackage проверяет, находится ли пакет в директории cmd
var isCmdPackage = func(pkgPath string) bool <span class="cov0" title="0">{
        return strings.Contains(filepath.ToSlash(pkgPath), "/cmd/")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Package config предоставляет загрузку и валидацию конфигурации приложения.

Поддерживает несколько источников конфигурации:
- Аргументы командной строки
- Переменные окружения
- JSON-файлы конфигурации
- Значения по умолчанию

Приоритет настроек (от высшего к низшему):
1. Аргументы командной строки
2. Переменные окружения
3. JSON-файл конфигурации (если указан)
4. Значения по умолчанию

Формат JSON-конфигурации:

        {
            "server_address": "localhost:8080",
            "base_url": "http://localhost",
            "file_storage_path": "/path/to/file.db",
            "database_dsn": "",
            "enable_https": true,
            "jwt_secret": "secret_key",
            "pprof": {
                "enabled": true,
                "auth_user": "admin",
                "auth_pass": "password"
            }
        }

Путь к JSON-файлу конфигурации можно указать:
- Через флаг -c или --config
- Через переменную окружения CONFIG
*/
package config

import (
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "log"
        "net"
        "net/url"
        "os"
        "strconv"
        "strings"
)

// Config содержит все параметры конфигурации приложения.
type Config struct {
        HTTPServerAddr string      `json:"server_address"`      // Адрес HTTP-сервера в формате host:port
        GRPCServerAddr string      `json:"grpc_server_address"` // Адрес gRPC-сервера
        BaseURL        string      `json:"base_url"`            // Базовый URL для сокращённых ссылок
        LogLevel       string      `json:"log_level"`           // Уровень логирования (debug, info, warn, error)
        FileStorage    string      `json:"file_storage_path"`   // Путь к файлу хранилища
        DBConnect      string      `json:"database_dsn"`        // Строка подключения к БД
        JwtKey         string      `json:"jwt_secret"`          // Секретный ключ для JWT
        ConfigPProf    PProfConfig `json:"pprof"`               // Настройки pprof
        EnableHTTPS    bool        `json:"enable_https"`        // Включение HTTPS
        SSLCertFile    string      `json:"ssl_cert_file"`       // Путь к SSL сертификату
        SSLKeyFile     string      `json:"ssl_key_file"`        // Путь к SSL ключу
        TrustedSubnet  string      `json:"trusted_subnet"`      // Доверенная подсеть
}

// PProfConfig содержит настройки профилирования pprof.
type PProfConfig struct {
        AuthUser string `json:"auth_user"`
        AuthPass string `json:"auth_pass"`
        Endpoint string `json:"endpoint"`
        BindAddr string `json:"bind_addr"`
        Enabled  bool   `json:"enabled"`
}

// validateHTTPServerAddr проверяет корректность адреса сервера.
//
// Формат адреса: host:port
// Где port должен быть числом от 1 до 65535
//
// Возвращает:
//
//        error - ошибка валидации или nil
func validateHTTPServerAddr(addr string) error <span class="cov10" title="7">{
        hp := strings.Split(addr, ":")
        if len(hp) != 2 </span><span class="cov1" title="1">{
                return errors.New("address must be in host:port format")
        }</span>

        <span class="cov9" title="6">port, err := strconv.Atoi(hp[1])
        if err != nil || port &lt; 1 || port &gt; 65535 </span><span class="cov1" title="1">{
                return errors.New("port must be a number between 1 and 65535")
        }</span>

        <span class="cov8" title="5">return nil</span>
}

// validateBaseURL проверяет корректность базового URL.
//
// URL должен быть:
// - Абсолютным (содержать схему)
// - Валидным согласно net/url.Parse
//
// Возвращает:
//
//        error - ошибка валидации или nil
func validateBaseURL(baseURL string) error <span class="cov6" title="3">{
        u, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="3">if u.Scheme == "" || u.Host == "" </span><span class="cov1" title="1">{
                return errors.New("URL must be absolute with scheme and host")
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// validateCertFiles проверяет существование файлов сертификатов.
// Возвращает:
//
//        error - ошибка или nil
func validateCertFiles(certFile, keyFile string) error <span class="cov6" title="3">{
        if _, err := os.Stat(certFile); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return errors.New("SSL certificate file not found")
        }</span>
        <span class="cov4" title="2">if _, err := os.Stat(keyFile); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return errors.New("SSL key file not found")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func validateGRPCServerAddr(addr string) error <span class="cov10" title="7">{
        if addr == "" </span><span class="cov1" title="1">{
                return errors.New("gRPC server address cannot be empty")
        }</span>

        <span class="cov9" title="6">_, port, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid address format: %w", err)
        }</span>

        // Проверка порта
        <span class="cov8" title="5">portNum, err := strconv.Atoi(port)
        if err != nil || portNum &lt; 1 || portNum &gt; 65535 </span><span class="cov1" title="1">{
                return errors.New("port must be between 1 and 65535")
        }</span>

        <span class="cov7" title="4">return nil</span>
}

// Load загружает конфигурацию из разных источников.
//
// Порядок загрузки:
// 1. Устанавливает значения по умолчанию
// 2. Читает JSON-конфиг (если указан)
// 3. Читает аргументы командной строки
// 4. Перезаписывает переменными окружения
//
// Возвращает:
// *Config - загруженную конфигурацию
func Load() *Config <span class="cov10" title="7">{
        cfg := &amp;Config{
                HTTPServerAddr: "localhost:8080",
                GRPCServerAddr: "localhost:50051",
                BaseURL:        "http://localhost:8080",
                LogLevel:       "info",
                FileStorage:    "storage.dat",
                JwtKey:         "your_strong_secret_here",
                EnableHTTPS:    false,
                SSLCertFile:    "cert.pem",
                SSLKeyFile:     "key.pem",
                ConfigPProf: PProfConfig{
                        Enabled:  true,
                        AuthUser: "admin",
                        AuthPass: "admin",
                        Endpoint: "/debug/pprof",
                        BindAddr: ":6060",
                },
        }

        // Загрузка из JSON-файла если указан
        configFile := getConfigFilePath()
        if configFile != "" </span><span class="cov6" title="3">{
                fileCfg, err := loadFromJSON(configFile)
                if err != nil </span><span class="cov1" title="1">{
                        log.Printf("Ошибка загрузки JSON-конфига: %v", err)
                }</span> else<span class="cov4" title="2"> {
                        // Объединяем конфиги, сохраняя значения по умолчанию для незаполненных полей
                        mergeConfigs(cfg, fileCfg)
                }</span>
        }

        // Загрузка из аргументов командной строки
        <span class="cov10" title="7">loadFromFlags(cfg)

        // Переопределение переменными окружения
        loadFromEnv(cfg)

        // Дополнительная обработка
        cfg.BaseURL = strings.TrimSuffix(cfg.BaseURL, "/")

        // Валидация SSL файлов если HTTPS включен
        if cfg.EnableHTTPS </span><span class="cov0" title="0">{
                if err := validateCertFiles(cfg.SSLCertFile, cfg.SSLKeyFile); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("HTTPS configuration error: %v", err)
                }</span>
        }

        <span class="cov10" title="7">return cfg</span>
}

// getConfigFilePath возвращает путь к файлу конфигурации из флагов или переменных окружения
func getConfigFilePath() string <span class="cov10" title="7">{

        for i, arg := range os.Args[1:] </span><span class="cov9" title="6">{
                if arg == "-c" || arg == "--config" </span><span class="cov0" title="0">{
                        if i+1 &lt; len(os.Args) </span><span class="cov0" title="0">{
                                return os.Args[i+2]
                        }</span>
                }
                <span class="cov9" title="6">if strings.HasPrefix(arg, "-c=") </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(arg, "-c=")
                }</span>
                <span class="cov9" title="6">if strings.HasPrefix(arg, "--config=") </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(arg, "--config=")
                }</span>
        }

        <span class="cov10" title="7">if envConfig := os.Getenv("CONFIG"); envConfig != "" </span><span class="cov6" title="3">{
                return envConfig
        }</span>
        <span class="cov7" title="4">return ""</span>
}

// loadFromJSON загружает конфигурацию из JSON-файла
func loadFromJSON(path string) (*Config, error) <span class="cov6" title="3">{
        file, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">var cfg Config
        if err := json.Unmarshal(file, &amp;cfg); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;cfg, nil</span>
}

// mergeConfigs объединяет две конфигурации, сохраняя оригинальные значения для пустых полей
func mergeConfigs(original, new *Config) <span class="cov6" title="3">{
        if new.HTTPServerAddr != "" </span><span class="cov6" title="3">{
                original.HTTPServerAddr = new.HTTPServerAddr
        }</span>
        <span class="cov6" title="3">if new.BaseURL != "" </span><span class="cov4" title="2">{
                original.BaseURL = new.BaseURL
        }</span>
        <span class="cov6" title="3">if new.LogLevel != "" </span><span class="cov6" title="3">{
                original.LogLevel = new.LogLevel
        }</span>
        <span class="cov6" title="3">if new.FileStorage != "" </span><span class="cov4" title="2">{
                original.FileStorage = new.FileStorage
        }</span>
        <span class="cov6" title="3">if new.DBConnect != "" </span><span class="cov0" title="0">{
                original.DBConnect = new.DBConnect
        }</span>
        <span class="cov6" title="3">if new.JwtKey != "" </span><span class="cov4" title="2">{
                original.JwtKey = new.JwtKey
        }</span>
        <span class="cov6" title="3">if new.EnableHTTPS </span><span class="cov0" title="0">{
                original.EnableHTTPS = new.EnableHTTPS
        }</span>
        <span class="cov6" title="3">if new.SSLCertFile != "" </span><span class="cov0" title="0">{
                original.SSLCertFile = new.SSLCertFile
        }</span>
        <span class="cov6" title="3">if new.SSLKeyFile != "" </span><span class="cov0" title="0">{
                original.SSLKeyFile = new.SSLKeyFile
        }</span>
        <span class="cov6" title="3">if new.TrustedSubnet != "" </span><span class="cov0" title="0">{
                original.TrustedSubnet = new.TrustedSubnet
        }</span>
        <span class="cov6" title="3">if new.GRPCServerAddr != "" </span><span class="cov0" title="0">{
                original.GRPCServerAddr = new.GRPCServerAddr
        }</span>

        // Объединение PProfConfig
        <span class="cov6" title="3">if new.ConfigPProf.AuthUser != "" </span><span class="cov4" title="2">{
                original.ConfigPProf.AuthUser = new.ConfigPProf.AuthUser
        }</span>
        <span class="cov6" title="3">if new.ConfigPProf.AuthPass != "" </span><span class="cov0" title="0">{
                original.ConfigPProf.AuthPass = new.ConfigPProf.AuthPass
        }</span>
        <span class="cov6" title="3">if new.ConfigPProf.Endpoint != "" </span><span class="cov0" title="0">{
                original.ConfigPProf.Endpoint = new.ConfigPProf.Endpoint
        }</span>
        <span class="cov6" title="3">if new.ConfigPProf.BindAddr != "" </span><span class="cov0" title="0">{
                original.ConfigPProf.BindAddr = new.ConfigPProf.BindAddr
        }</span>
        <span class="cov6" title="3">if new.ConfigPProf.Enabled </span><span class="cov4" title="2">{
                original.ConfigPProf.Enabled = new.ConfigPProf.Enabled
        }</span>
}

// loadFromFlags загружает значения из флагов командной строки
func loadFromFlags(cfg *Config) <span class="cov10" title="7">{
        flag.Func("a", "Server address in host:port format", func(flagValue string) error </span><span class="cov4" title="2">{
                if err := validateHTTPServerAddr(flagValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="2">cfg.HTTPServerAddr = flagValue
                return nil</span>
        })

        <span class="cov10" title="7">flag.Func("b", "Base URL for shortened links (e.g. http://example.com)", func(flagValue string) error </span><span class="cov0" title="0">{
                if err := validateBaseURL(flagValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cfg.BaseURL = strings.TrimSuffix(flagValue, "/")
                return nil</span>
        })

        <span class="cov10" title="7">flag.StringVar(&amp;cfg.LogLevel, "l", cfg.LogLevel, "Log level (debug, info, warn, error)")
        flag.StringVar(&amp;cfg.FileStorage, "f", cfg.FileStorage, "Path to file storage")
        flag.StringVar(&amp;cfg.DBConnect, "d", cfg.DBConnect, "Database connection string")
        flag.BoolVar(&amp;cfg.EnableHTTPS, "s", cfg.EnableHTTPS, "Enable HTTPS server")
        flag.StringVar(&amp;cfg.TrustedSubnet, "t", "", "trusted subnet in CIDR notation")

        flag.Func("ga", "gRPC server address in host:port format", func(flagValue string) error </span><span class="cov0" title="0">{
                if err := validateGRPCServerAddr(flagValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cfg.GRPCServerAddr = flagValue
                return nil</span>
        })

        <span class="cov10" title="7">flag.Parse()</span>
}

// loadFromEnv загружает значения из переменных окружения.
func loadFromEnv(cfg *Config) <span class="cov10" title="7">{
        if envAddr := os.Getenv("SERVER_ADDRESS"); envAddr != "" </span><span class="cov4" title="2">{
                if err := validateHTTPServerAddr(envAddr); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("invalid SERVER_ADDRESS: %v", err)
                }</span>
                <span class="cov4" title="2">cfg.HTTPServerAddr = envAddr</span>
        }

        <span class="cov10" title="7">if envURL := os.Getenv("BASE_URL"); envURL != "" </span><span class="cov0" title="0">{
                if err := validateBaseURL(envURL); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("invalid BASE_URL: %v", err)
                }</span>
                <span class="cov0" title="0">cfg.BaseURL = envURL</span>
        }

        <span class="cov10" title="7">if envFile := os.Getenv("FILE_STORAGE_PATH"); envFile != "" </span><span class="cov0" title="0">{
                cfg.FileStorage = envFile
        }</span>

        <span class="cov10" title="7">if envDB := os.Getenv("DATABASE_DSN"); envDB != "" </span><span class="cov10" title="7">{
                cfg.DBConnect = envDB
        }</span>

        <span class="cov10" title="7">if envJWT := os.Getenv("JWT_SECRET"); envJWT != "" </span><span class="cov1" title="1">{
                if len(envJWT) &lt; 32 </span><span class="cov0" title="0">{
                        log.Fatal("JWT_SECRET must be at least 32 characters long")
                }</span>
                <span class="cov1" title="1">cfg.JwtKey = envJWT</span>
        }

        <span class="cov10" title="7">if envLogLevel := os.Getenv("LOG_LEVEL"); envLogLevel != "" </span><span class="cov1" title="1">{
                cfg.LogLevel = envLogLevel
        }</span>

        // Обработка HTTPS настроек
        <span class="cov10" title="7">if envEnableHTTPS := os.Getenv("SSL_ENABLE"); envEnableHTTPS != "" </span><span class="cov0" title="0">{
                if v, err := strconv.ParseBool(envEnableHTTPS); err == nil </span><span class="cov0" title="0">{
                        cfg.EnableHTTPS = v
                }</span>
        }

        <span class="cov10" title="7">if envCert := os.Getenv("SSL_CERT_FILE"); envCert != "" </span><span class="cov10" title="7">{
                cfg.SSLCertFile = envCert
        }</span>

        <span class="cov10" title="7">if envKey := os.Getenv("SSL_KEY_FILE"); envKey != "" </span><span class="cov10" title="7">{
                cfg.SSLKeyFile = envKey
        }</span>

        <span class="cov10" title="7">if envSubnet := os.Getenv("TRUSTED_SUBNET"); envSubnet != "" </span><span class="cov10" title="7">{
                cfg.TrustedSubnet = envSubnet
        }</span>

        <span class="cov10" title="7">if envGRPCAddr := os.Getenv("GRPC_SERVER_ADDRESS"); envGRPCAddr != "" </span><span class="cov0" title="0">{
                if err := validateGRPCServerAddr(envGRPCAddr); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("invalid GRPC_SERVER_ADDRESS: %v", err)
                }</span>
                <span class="cov0" title="0">cfg.GRPCServerAddr = envGRPCAddr</span>
        }

        // Обработка pprof настроек
        <span class="cov10" title="7">if user := os.Getenv("PPROF_USER"); user != "" </span><span class="cov1" title="1">{
                cfg.ConfigPProf.AuthUser = user
        }</span>
        <span class="cov10" title="7">if pass := os.Getenv("PPROF_PASS"); pass != "" </span><span class="cov1" title="1">{
                cfg.ConfigPProf.AuthPass = pass
        }</span>
        <span class="cov10" title="7">if enabled := os.Getenv("PPROF_ENABLED"); enabled != "" </span><span class="cov1" title="1">{
                if v, err := strconv.ParseBool(enabled); err == nil </span><span class="cov1" title="1">{
                        cfg.ConfigPProf.Enabled = v
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package base

import (
        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/server/grpc/interceptors"
        "google.golang.org/grpc"

        "go.uber.org/zap"
)

// BaseHandler содержит общие зависимости для всех обработчиков
type BaseHandler struct {
        Logger *zap.Logger // Общий логгер
}

// NewBaseHandler создает базовый обработчик
func NewBaseHandler(logger *zap.Logger) *BaseHandler <span class="cov0" title="0">{
        return &amp;BaseHandler{
                Logger: logger,
        }
}</span>

// CommonInterceptors возвращает цепочку общих интерцепторов
func (h *BaseHandler) CommonInterceptors(cfg *config.Config) []grpc.UnaryServerInterceptor <span class="cov10" title="5">{
        return []grpc.UnaryServerInterceptor{
                interceptors.LoggingInterceptor(h.Logger),
                interceptors.JWTAutoIssueGRPC([]byte(cfg.JwtKey)),
                interceptors.TrustedSubnetInterceptor(interceptors.TrustedSubnetConfig{
                        TrustedSubnet: cfg.TrustedSubnet,
                        ProtectedMethods: map[string]bool{
                                "/shortener.Shortener/GetStats": true,
                        },
                        DenyIfNotConfigured: true, // Блокировать если подсеть не настроена
                }),
        }

}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package batch

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/models"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler определяет контракт для обработки пакетных запросов.
type URLHandler interface {
        Batch(ctx context.Context, requests []models.BatchRequest, baseURL string) ([]models.BatchResponse, error)
}

type Handler struct {
        *base.BaseHandler // Встраиваем базовый обработчик
        service           URLHandler
        baseURL           string
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
        baseURL string,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, // Инициализация базовых зависимостей
                service:     service,
                baseURL:     baseURL,
        }
}</span>

func (h *Handler) BatchCreate(
        ctx context.Context,
        req *pb.BatchCreateRequest,
) (*pb.BatchCreateResponse, error) <span class="cov1" title="1">{
        if len(req.Items) == 0 </span><span class="cov0" title="0">{
                h.Logger.Error("Empty batch request")
                return nil, status.Error(codes.InvalidArgument, "Request contains no items")
        }</span>

        // Преобразуем в []models.BatchRequest
        <span class="cov1" title="1">batchReq := make([]models.BatchRequest, 0, len(req.Items))
        for _, item := range req.Items </span><span class="cov10" title="2">{
                batchReq = append(batchReq, models.BatchRequest{
                        CorrelationID: item.CorrelationId,
                        OriginalURL:   item.OriginalUrl,
                })
        }</span>

        // Обработка
        <span class="cov1" title="1">batchResp, err := h.service.Batch(ctx, batchReq, h.baseURL)
        if err != nil </span><span class="cov0" title="0">{
                h.Logger.Error("Failed to process batch create", zap.Error(err))
                return nil, status.Error(codes.Internal, "Failed to process batch create")
        }</span>

        // Формируем ответ
        <span class="cov1" title="1">resp := &amp;pb.BatchCreateResponse{}
        for _, item := range batchResp </span><span class="cov10" title="2">{
                resp.Items = append(resp.Items, &amp;pb.BatchCreateResult{
                        CorrelationId: item.CorrelationID,
                        ShortUrl:      item.ShortURL,
                })
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("Batch create processed", zap.Int("count", len(resp.Items)))
        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package deluserurls

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler определяет контракт для обработки удаления URL.
type URLHandler interface {
        DeleteUserUrls(ctx context.Context, ids []string) error
}

type Handler struct {
        *base.BaseHandler // Встраиваем базовый обработчик
        service           URLHandler
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, // Инициализация базовых зависимостей
                service:     service,
        }
}</span>

func (h *Handler) DeleteUserURLs(
        ctx context.Context,
        req *pb.DeleteRequest,
) (*pb.DeleteResponse, error) <span class="cov10" title="4">{
        if len(req.ShortUrls) == 0 </span><span class="cov0" title="0">{
                h.Logger.Error("No short URLs provided for deletion")
                return nil, status.Error(codes.InvalidArgument, "No short URLs provided")
        }</span>

        <span class="cov10" title="4">h.Logger.Debug("Processing DeleteUserURLs request",
                zap.Int("url_count", len(req.ShortUrls)))

        err := h.service.DeleteUserUrls(ctx, req.ShortUrls)
        if err != nil </span><span class="cov0" title="0">{
                h.Logger.Error("Failed to delete user URLs", zap.Error(err))
                return nil, status.Error(codes.Internal, "Failed to delete user URLs")
        }</span>

        // 202 Accepted, но в gRPC нет статус-кодов как в HTTP — просто возвращаем OK
        <span class="cov10" title="4">return &amp;pb.DeleteResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package ping

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler определяет контракт для проверки соединения с БД.
type URLHandler interface {
        // Ping проверяет соединение с базой данных.
        //
        // Параметры:
        //   ctx - контекст выполнения с таймаутом
        //
        // Возвращает:
        //   error - ошибка соединения или nil при успехе
        Ping(ctx context.Context) error
}

type Handler struct {
        *base.BaseHandler // Встраиваем базовый обработчик
        service           URLHandler
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, // Инициализация базовых зависимостей
                service:     service,
        }
}</span>

func (h *Handler) Ping(
        ctx context.Context,
        req *pb.PingRequest,
) (*pb.PingResponse, error) <span class="cov10" title="2">{
        err := h.service.Ping(ctx)
        if err != nil </span><span class="cov1" title="1">{
                h.Logger.Error("Failed to connect to database",
                        zap.Error(err),
                )
                return nil, status.Error(codes.Internal, "Failed to connect to database")
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("Database connection check successful")

        return &amp;pb.PingResponse{
                Ok: true,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package redirect

import (
        "context"
        "errors"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/storage"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler определяет контракт для получения оригинального URL.
type URLHandler interface {
        // GetRedirectURL возвращает оригинальный URL для перенаправления.
        //
        // Параметры:
        //   ctx - контекст выполнения
        //   id - короткий идентификатор URL
        //
        // Возвращает:
        //   string - оригинальный URL
        //   error - возможные ошибки:
        //     - storage.ErrURLNotFound: URL не существует
        //     - storage.ErrURLDeleted: URL был удален
        //     - другие внутренние ошибки
        GetRedirectURL(ctx context.Context, id string) (string, error)
}

type Handler struct {
        *base.BaseHandler // Встраиваем базовый обработчик
        service           URLHandler
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, // Инициализация базовых зависимостей
                service:     service,
        }
}</span>

// GetOriginalURL обработчик gRPC для получения оригинального URL
func (h *Handler) GetOriginalURL(
        ctx context.Context,
        req *pb.GetRequest,
) (*pb.GetResponse, error) <span class="cov10" title="2">{
        // Валидация ID
        if req.ShortUrl == "" </span><span class="cov0" title="0">{
                h.Logger.Error("Empty ID in request")
                return nil, status.Error(codes.InvalidArgument, "ID parameter is missing")
        }</span>

        <span class="cov10" title="2">h.Logger.Debug("Processing URL lookup",
                zap.String("shortID", req.ShortUrl))

        // Получаем оригинальный URL
        originalURL, err := h.service.GetRedirectURL(ctx, req.ShortUrl)
        if err != nil </span><span class="cov1" title="1">{
                switch </span>{
                case errors.Is(err, storage.ErrURLNotFound):<span class="cov1" title="1">
                        h.Logger.Info("Shortened key not found",
                                zap.String("shortKey", req.ShortUrl))
                        return nil, status.Error(codes.NotFound, "Shortened key not found")</span>
                case errors.Is(err, storage.ErrURLDeleted):<span class="cov0" title="0">
                        h.Logger.Info("URL has been deleted",
                                zap.String("shortKey", req.ShortUrl))
                        return nil, status.Error(codes.NotFound, "URL has been deleted")</span>
                default:<span class="cov0" title="0">
                        h.Logger.Error("Failed to get redirect URL",
                                zap.Error(err),
                                zap.String("shortKey", req.ShortUrl))
                        return nil, status.Error(codes.Internal, "Failed to get redirect URL")</span>
                }
        }

        <span class="cov1" title="1">h.Logger.Info("Shortened key found",
                zap.String("shortKey", req.ShortUrl),
                zap.String("redirect", originalURL))

        // Формируем ответ
        return &amp;pb.GetResponse{
                OriginalUrl: originalURL,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by genserver from proto; DO NOT EDIT.

package grpchandlers

import (
        "context"

        "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type ServerOption func(s *Server)


type CreateShortURLEndpoint interface {
        CreateShortURL(ctx context.Context, req *api.CreateRequest) (*api.CreateResponse, error)
}

func WithCreateShortURLEndpoint(h CreateShortURLEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.CreateShortURLHandler = h
        }</span>
}

type GetOriginalURLEndpoint interface {
        GetOriginalURL(ctx context.Context, req *api.GetRequest) (*api.GetResponse, error)
}

func WithGetOriginalURLEndpoint(h GetOriginalURLEndpoint) ServerOption <span class="cov3" title="2">{
        return func(s *Server) </span><span class="cov3" title="2">{
                s.GetOriginalURLHandler = h
        }</span>
}

type PingEndpoint interface {
        Ping(ctx context.Context, req *api.PingRequest) (*api.PingResponse, error)
}

func WithPingEndpoint(h PingEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.PingHandler = h
        }</span>
}

type GetStatsEndpoint interface {
        GetStats(ctx context.Context, req *api.StatsRequest) (*api.StatsResponse, error)
}

func WithGetStatsEndpoint(h GetStatsEndpoint) ServerOption <span class="cov6" title="4">{
        return func(s *Server) </span><span class="cov6" title="4">{
                s.GetStatsHandler = h
        }</span>
}

type GetUserURLsEndpoint interface {
        GetUserURLs(ctx context.Context, req *api.UserURLsRequest) (*api.UserURLsResponse, error)
}

func WithGetUserURLsEndpoint(h GetUserURLsEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.GetUserURLsHandler = h
        }</span>
}

type DeleteUserURLsEndpoint interface {
        DeleteUserURLs(ctx context.Context, req *api.DeleteRequest) (*api.DeleteResponse, error)
}

func WithDeleteUserURLsEndpoint(h DeleteUserURLsEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.DeleteUserURLsHandler = h
        }</span>
}

type BatchCreateEndpoint interface {
        BatchCreate(ctx context.Context, req *api.BatchCreateRequest) (*api.BatchCreateResponse, error)
}

func WithBatchCreateEndpoint(h BatchCreateEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.BatchCreateHandler = h
        }</span>
}


type Server struct {
        api.UnimplementedShortenerServer
        *base.BaseHandler

        CreateShortURLHandler CreateShortURLEndpoint
        GetOriginalURLHandler GetOriginalURLEndpoint
        PingHandler PingEndpoint
        GetStatsHandler GetStatsEndpoint
        GetUserURLsHandler GetUserURLsEndpoint
        DeleteUserURLsHandler DeleteUserURLsEndpoint
        BatchCreateHandler BatchCreateEndpoint
        
}

func NewServer(baseHandler *base.BaseHandler, opts ...ServerOption) *Server <span class="cov9" title="10">{
        s := &amp;Server{BaseHandler: baseHandler}
        for _, opt := range opts </span><span class="cov10" title="11">{
                opt(s)
        }</span>
        <span class="cov9" title="10">return s</span>
}


func (s *Server) CreateShortURL(ctx context.Context, req *api.CreateRequest) (*api.CreateResponse, error) <span class="cov5" title="3">{
        if s.CreateShortURLHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "CreateShortURL handler not provided")
        }</span>
        <span class="cov5" title="3">return s.CreateShortURLHandler.CreateShortURL(ctx, req)</span>
}

func (s *Server) GetOriginalURL(ctx context.Context, req *api.GetRequest) (*api.GetResponse, error) <span class="cov8" title="7">{
        if s.GetOriginalURLHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "GetOriginalURL handler not provided")
        }</span>
        <span class="cov8" title="7">return s.GetOriginalURLHandler.GetOriginalURL(ctx, req)</span>
}

func (s *Server) Ping(ctx context.Context, req *api.PingRequest) (*api.PingResponse, error) <span class="cov3" title="2">{
        if s.PingHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "Ping handler not provided")
        }</span>
        <span class="cov3" title="2">return s.PingHandler.Ping(ctx, req)</span>
}

func (s *Server) GetStats(ctx context.Context, req *api.StatsRequest) (*api.StatsResponse, error) <span class="cov5" title="3">{
        if s.GetStatsHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "GetStats handler not provided")
        }</span>
        <span class="cov5" title="3">return s.GetStatsHandler.GetStats(ctx, req)</span>
}

func (s *Server) GetUserURLs(ctx context.Context, req *api.UserURLsRequest) (*api.UserURLsResponse, error) <span class="cov3" title="2">{
        if s.GetUserURLsHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "GetUserURLs handler not provided")
        }</span>
        <span class="cov3" title="2">return s.GetUserURLsHandler.GetUserURLs(ctx, req)</span>
}

func (s *Server) DeleteUserURLs(ctx context.Context, req *api.DeleteRequest) (*api.DeleteResponse, error) <span class="cov6" title="4">{
        if s.DeleteUserURLsHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "DeleteUserURLs handler not provided")
        }</span>
        <span class="cov6" title="4">return s.DeleteUserURLsHandler.DeleteUserURLs(ctx, req)</span>
}

func (s *Server) BatchCreate(ctx context.Context, req *api.BatchCreateRequest) (*api.BatchCreateResponse, error) <span class="cov1" title="1">{
        if s.BatchCreateHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "BatchCreate handler not provided")
        }</span>
        <span class="cov1" title="1">return s.BatchCreateHandler.BatchCreate(ctx, req)</span>
}

</pre>
		
		<pre class="file" id="file14" style="display: none">package shorturl

import (
        "context"
        "errors"
        "net/url"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/storage"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler определяет контракт для генерации коротких URL.
type URLHandler interface {
        // GetShortKey возвращает короткий ключ для оригинального URL.
        //
        // Параметры:
        //   ctx - контекст выполнения (должен включать таймаут)
        //   originalURL - валидный URL для сокращения
        //
        // Возвращает:
        //   string - короткий ключ
        //   error - возможные ошибки:
        //     - storage.ErrURLExists: URL уже существует
        //     - другие внутренние ошибки
        GetShortKey(ctx context.Context, originalURL string) (string, error)
}

type Handler struct {
        *base.BaseHandler // Встраиваем базовый обработчик
        service           URLHandler
        baseURL           string
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
        baseURL string,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, // Инициализация базовых зависимостей
                service:     service,
                baseURL:     baseURL,
        }
}</span>

// CreateShortURL обработчик gRPC для создания короткой ссылки
func (h *Handler) CreateShortURL(
        ctx context.Context,
        req *pb.CreateRequest,
) (*pb.CreateResponse, error) <span class="cov10" title="3">{
        // Валидация URL
        if req.OriginalUrl == "" </span><span class="cov0" title="0">{
                h.Logger.Error("Empty URL in request")
                return nil, status.Error(codes.InvalidArgument, "URL parameter is missing")
        }</span>

        <span class="cov10" title="3">if _, err := url.ParseRequestURI(req.OriginalUrl); err != nil </span><span class="cov1" title="1">{
                h.Logger.Error("Invalid URL in request",
                        zap.String("url", req.OriginalUrl),
                        zap.Error(err))
                return nil, status.Error(codes.InvalidArgument, "Invalid URL format")
        }</span>

        <span class="cov6" title="2">h.Logger.Debug("Processing URL shortening",
                zap.String("originalURL", req.OriginalUrl))

        // Генерация короткого ключа
        shortKey, err := h.service.GetShortKey(ctx, req.OriginalUrl)
        if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                h.Logger.Error("Short URL generation failed",
                        zap.Error(err),
                        zap.String("originalURL", req.OriginalUrl))
                return nil, status.Error(codes.Internal, "Failed to generate short URL")
        }</span>

        // Формирование ответа
        <span class="cov6" title="2">response := &amp;pb.CreateResponse{
                ShortUrl: h.baseURL + "/" + shortKey,
        }

        if errors.Is(err, storage.ErrURLExists) </span><span class="cov1" title="1">{
                h.Logger.Debug("URL already exists",
                        zap.String("shortKey", shortKey),
                        zap.String("originalURL", req.OriginalUrl))
                return response, status.Error(codes.AlreadyExists, "URL already exists")
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("URL successfully shortened",
                zap.String("shortKey", shortKey),
                zap.String("originalURL", req.OriginalUrl))

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package stats

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/models"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler определяет интерфейс для получения статистики сервиса.
// Реализации этого интерфейса должны предоставлять данные о количестве URL и пользователей.
type URLHandler interface {
        // GetStats возвращает статистику сервиса.
        // Возвращает:
        //   - models.StatsResponse с количеством URL и пользователей
        //   - error в случае ошибки при получении данных
        GetStats(ctx context.Context) (models.StatsResponse, error)
}

type Handler struct {
        *base.BaseHandler // Встраиваем базовый обработчик
        service           URLHandler
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
) *Handler <span class="cov10" title="4">{
        return &amp;Handler{
                BaseHandler: baseHandler, // Инициализация базовых зависимостей
                service:     service,
        }
}</span>

// GetStats реализует gRPC хендлер получения статистики
func (h *Handler) GetStats(
        ctx context.Context,
        _ *pb.StatsRequest,
) (*pb.StatsResponse, error) <span class="cov8" title="3">{

        // Получение статистики из сервиса
        stats, err := h.service.GetStats(ctx)
        if err != nil </span><span class="cov5" title="2">{
                h.Logger.Error("Failed to get stats", zap.Error(err))
                return nil, status.Error(codes.Internal, "failed to get stats")
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("Stats received successfully")

        // Формирование и возврат ответа
        return &amp;pb.StatsResponse{
                Urls:  int64(stats.URLs),
                Users: int64(stats.Users),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package userurls

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/models"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler определяет контракт для получения URL пользователя.
type URLHandler interface {
        GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error)
}

type Handler struct {
        *base.BaseHandler // Встраиваем базовый обработчик
        service           URLHandler
        baseURL           string
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
        baseURL string,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, // Инициализация базовых зависимостей
                service:     service,
                baseURL:     baseURL,
        }
}</span>

func (h *Handler) GetUserURLs(
        ctx context.Context,
        _ *pb.UserURLsRequest,
) (*pb.UserURLsResponse, error) <span class="cov10" title="2">{

        h.Logger.Debug("Processing GetUserURLs request")

        // Получение URL пользователя
        urls, err := h.service.GetUserUrls(ctx, h.baseURL)
        if err != nil </span><span class="cov0" title="0">{
                h.Logger.Error("Failed to retrieve user URLs",
                        zap.Error(err))
                return nil, status.Error(codes.Internal, "Failed to retrieve user URLs")
        }</span>

        // Если нет данных — возвращаем пустой ответ
        <span class="cov10" title="2">if len(urls) == 0 </span><span class="cov1" title="1">{
                h.Logger.Debug("No URLs found for user")
                return &amp;pb.UserURLsResponse{Urls: []*pb.UserURL{}}, nil
        }</span>

        // Формирование ответа
        <span class="cov1" title="1">var pbUrls []*pb.UserURL
        for _, u := range urls </span><span class="cov10" title="2">{
                pbUrls = append(pbUrls, &amp;pb.UserURL{
                        ShortUrl:    u.ShortURL,
                        OriginalUrl: u.OriginalURL,
                })
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("Successfully returned user URLs", zap.Int("count", len(pbUrls)))

        return &amp;pb.UserURLsResponse{
                Urls: pbUrls,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package batch предоставляет обработчик для пакетного создания сокращённых URL.
//
// Пакет реализует:
// - Приём массива URL в JSON-формате
// - Параллельную обработку запросов
// - Возврат результатов в коррелируемом формате
package batch

import (
        "context"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/models"
)

// URLHandler определяет контракт для обработки пакетных запросов.
type URLHandler interface {
        // Batch обрабатывает массив запросов на сокращение URL.
        //
        // Параметры:
        //   ctx - контекст выполнения
        //   requests - массив запросов
        //   baseURL - базовый URL для генерации коротких ссылок
        //
        // Возвращает:
        //   []models.BatchResponse - массив результатов
        //   error - ошибка выполнения
        Batch(ctx context.Context, requests []models.BatchRequest, baseURL string) ([]models.BatchResponse, error)
}

// GetHandler создаёт HTTP-обработчик для пакетного создания URL.
//
// Спецификация API:
//
//        Метод: POST
//        Content-Type: application/json
//        Путь: /api/shorten/batch
//
// Формат запроса:
//
//        [
//          {
//            "correlation_id": "уникальный_идентификатор",
//            "original_url": "https://example.com"
//          },
//          ...
//        ]
//
// Формат ответа:
//
//        [
//          {
//            "correlation_id": "уникальный_идентификатор",
//            "short_url": "http://short.ly/abc"
//          },
//          ...
//        ]
//
// Коды ответа:
//   - 201 Created - успешная обработка
//   - 400 Bad Request - невалидный JSON
//   - 500 Internal Server Error - внутренняя ошибка сервера
//
// Параметры:
//
//        urlHandler - сервис для обработки URL
//        baseURL - базовый адрес для коротких ссылок
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov5" title="2">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="4">{
                // Декодируем тело запроса
                var requestData []models.BatchRequest
                decoder := json.NewDecoder(req.Body)
                err := decoder.Decode(&amp;requestData)
                if err != nil </span><span class="cov5" title="2">{
                        http.Error(res, "Failed to read request body", http.StatusBadRequest)
                        log.Error("Failed to read request body", zap.Error(err))
                        return
                }</span>

                <span class="cov5" title="2">responseData, err := urlHandler.Batch(req.Context(), requestData, baseURL)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to proccessing request data", http.StatusBadRequest)
                        log.Error("Failed to proccessing request data", zap.Error(err))
                        return
                }</span>

                <span class="cov5" title="2">res.Header().Set("content-type", "application/json")
                // устанавливаем код 201
                res.WriteHeader(http.StatusCreated)
                // пишем тело ответа
                resp, err := json.Marshal(responseData)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        log.Error("Failed to encode response data", zap.Error(err))
                        return
                }</span>
                <span class="cov5" title="2">res.Write(resp)</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package deluserurls предоставляет обработчик для массового удаления URL пользователя.
//
// Пакет реализует:
// - Приём списка URL для удаления в JSON-формате
// - Асинхронное удаление URL
// - Подтверждение принятия запроса
package deluserurls

import (
        "context"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"
)

// URLHandler определяет контракт для обработки удаления URL.
type URLHandler interface {
        // DeleteUserUrls удаляет указанные URL, принадлежащие пользователю.
        //
        // Параметры:
        //   ctx - контекст выполнения
        //   urls - список коротких URL для удаления (только идентификаторы)
        //
        // Возвращает:
        //   error - ошибка выполнения (не влияет на HTTP-статус ответа)
        DeleteUserUrls(ctx context.Context, urls []string) error
}

// GetHandler создаёт HTTP-обработчик для массового удаления URL пользователя.
//
// Спецификация API:
//
//        Метод: DELETE
//        Content-Type: application/json
//        Путь: /api/user/urls
//
// Формат запроса:
//
//        ["url1", "url2", ...]
//
// Формат ответа:
//
//        Тело ответа пустое
//
// Коды ответа:
//   - 202 Accepted - запрос принят в обработку
//   - 400 Bad Request - невалидный JSON
//   - 401 Unauthorized - пользователь не аутентифицирован
//   - 500 Internal Server Error - внутренняя ошибка сервера
//
// Особенности:
//   - Удаление происходит асинхронно
//   - Ответ 202 не гарантирует успешного удаления
//   - Для аутентификации используется JWT-токен в Cookie
//
// Параметры:
//
//        urlHandler - сервис для обработки URL
//        baseURL - базовый адрес сервиса (не используется в текущей реализации)
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="4">{
                var shortURLs []string
                if err := json.NewDecoder(req.Body).Decode(&amp;shortURLs); err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Invalid request body", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov10" title="4">err := urlHandler.DeleteUserUrls(req.Context(), shortURLs)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to delete user urls", http.StatusBadRequest)
                        log.Error("Failed to delete user urls", zap.Error(err))
                        return
                }</span>

                <span class="cov10" title="4">res.WriteHeader(http.StatusAccepted)</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package ping предоставляет обработчик для проверки доступности базы данных.
//
// Пакет реализует:
// - Проверку соединения с базой данных
// - Возврат статуса доступности сервиса
// - Логирование результатов проверки
package ping

import (
        "context"
        "net/http"

        "go.uber.org/zap"
)

// URLHandler определяет контракт для проверки соединения с БД.
type URLHandler interface {
        // Ping проверяет соединение с базой данных.
        //
        // Параметры:
        //   ctx - контекст выполнения с таймаутом
        //
        // Возвращает:
        //   error - ошибка соединения или nil при успехе
        Ping(ctx context.Context) error
}

// GetHandler создаёт HTTP-обработчик для проверки доступности БД.
//
// Спецификация API:
//
//        Метод: GET
//        Путь: /ping
//
// Формат ответа:
//   - При успехе: текст "Connect to database is successful"
//   - При ошибке: текст ошибки
//
// Коды ответа:
//   - 200 OK - соединение с БД установлено
//   - 500 Internal Server Error - ошибка соединения с БД
//   - 503 Service Unavailable - сервис недоступен (может добавляться в будущих версиях)
//
// Параметры:
//
//        urlHandler - сервис для проверки соединения
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="2">{
                err := urlHandler.Ping(req.Context())
                if err != nil </span><span class="cov1" title="1">{
                        http.Error(res, "Failed to connect to database", http.StatusInternalServerError)
                        log.Error("Failed to connect to database",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov1" title="1">log.Debug("Database connection check successful",
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                res.WriteHeader(http.StatusOK)
                res.Write([]byte("Connect to database is successful"))</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package redirect предоставляет обработчик для перенаправления по коротким URL.
//
// Пакет реализует:
// - Поиск оригинального URL по короткому идентификатору
// - Обработку различных статусов URL (активен, удален, не найден)
// - Логирование всех операций перенаправления
package redirect

import (
        "context"
        "errors"
        "net/http"

        "go.uber.org/zap"

        "github.com/go-chi/chi/v5"

        "github.com/ryabkov82/shortener/internal/app/storage"
)

// URLHandler определяет контракт для получения оригинального URL.
type URLHandler interface {
        // GetRedirectURL возвращает оригинальный URL для перенаправления.
        //
        // Параметры:
        //   ctx - контекст выполнения
        //   id - короткий идентификатор URL
        //
        // Возвращает:
        //   string - оригинальный URL
        //   error - возможные ошибки:
        //     - storage.ErrURLNotFound: URL не существует
        //     - storage.ErrURLDeleted: URL был удален
        //     - другие внутренние ошибки
        GetRedirectURL(ctx context.Context, id string) (string, error)
}

// GetHandler создаёт HTTP-обработчик для перенаправления по коротким URL.
//
// Спецификация API:
//
//        Метод: GET
//        Путь: /{id}
//
// Параметры пути:
//
//        id - короткий идентификатор URL (a-z, A-Z, 0-9)
//
// Ответы:
//   - 307 Temporary Redirect: успешное перенаправление (с Location header)
//   - 404 Not Found: короткий URL не существует
//   - 410 Gone: URL был удален
//   - 500 Internal Server Error: внутренняя ошибка сервера
//
// Особенности:
//   - Все запросы логируются с указанием shortKey
//   - Для удаленных URL возвращается специальный статус 410
//   - Поддерживается контекст для отмены операций
//
// Параметры:
//
//        urlHandler - сервис для получения URL
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="2">{
                id := chi.URLParam(req, "id")

                // Получаем адрес перенаправления
                originalURL, err := urlHandler.GetRedirectURL(req.Context(), id)
                if err != nil </span><span class="cov1" title="1">{
                        if errors.Is(err, storage.ErrURLNotFound) </span><span class="cov1" title="1">{
                                http.Error(res, "Shortened key not found", http.StatusNotFound)
                                log.Info("Shortened key not found",
                                        zap.String("shortKey", id),
                                        zap.String("method", req.Method),
                                        zap.String("path", req.URL.Path))
                                return
                        }</span>
                        <span class="cov0" title="0">if errors.Is(err, storage.ErrURLDeleted) </span><span class="cov0" title="0">{
                                http.Error(res, "URL has been deleted", http.StatusGone)
                                log.Info("URL has been deleted",
                                        zap.String("shortKey", id),
                                        zap.String("method", req.Method),
                                        zap.String("path", req.URL.Path))
                                return
                        }</span>
                        <span class="cov0" title="0">http.Error(res, "failed get redirect URL", http.StatusInternalServerError)
                        log.Error("failed get redirect URL",
                                zap.Error(err),
                                zap.String("shortKey", id),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return</span>
                }

                <span class="cov1" title="1">log.Info("Shortened key found",
                        zap.String("shortKey", id),
                        zap.String("redirect", originalURL),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                // Устанавливаем заголовок ответа Location
                res.Header().Set("Location", originalURL)
                // устанавливаем код 307
                res.WriteHeader(http.StatusTemporaryRedirect)</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package shortenapi предоставляет JSON API для создания сокращённых URL.
//
// Пакет реализует:
// - Приём оригинального URL в JSON-формате
// - Валидацию входящего URL
// - Генерацию короткого ключа
// - Возврат результата в стандартизированном JSON-формате
package shortenapi

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"
        "net/url"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/storage"
)

// URLHandler определяет контракт для генерации коротких URL.
type URLHandler interface {
        // GetShortKey возвращает короткий ключ для оригинального URL.
        //
        // Параметры:
        //   ctx - контекст выполнения
        //   originalURL - URL для сокращения (должен быть валидным)
        //
        // Возвращает:
        //   string - короткий ключ
        //   error - возможные ошибки:
        //     - storage.ErrURLExists: URL уже существует
        //     - другие внутренние ошибки
        GetShortKey(ctx context.Context, originalURL string) (string, error)
}

// Request представляет структуру входящего JSON-запроса.
type Request struct {
        URL string `json:"url"` // Оригинальный URL для сокращения
}

// Response представляет структуру исходящего JSON-ответа.
type Response struct {
        Result string `json:"result"` // Полный сокращённый URL
}

// GetHandler создаёт HTTP-обработчик для API сокращения URL.
//
// Спецификация API:
//
//        Метод: POST
//        Content-Type: application/json
//        Путь: /api/shorten
//
// Формат запроса:
//
//        {
//          "url": "https://example.com/very/long/url"
//        }
//
// Формат ответа:
//
//        {
//          "result": "http://short.ly/abc123"
//        }
//
// Коды ответа:
//   - 201 Created: URL успешно сокращён
//   - 400 Bad Request: невалидный запрос
//   - 409 Conflict: URL уже существует
//   - 500 Internal Server Error: внутренняя ошибка сервера
//
// Параметры:
//
//        urlHandler - сервис для генерации коротких ключей
//        baseURL - базовый адрес для построения полного короткого URL
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="3">{
                var request Request

                // Декодируем JSON-тело запроса
                if err := json.NewDecoder(req.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to read request body", http.StatusBadRequest)
                        log.Error("Failed to decode request body",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov10" title="3">originalURL := request.URL

                // Валидация обязательного поля URL
                if originalURL == "" </span><span class="cov0" title="0">{
                        http.Error(res, "URL parameter is missing", http.StatusBadRequest)
                        log.Error("Empty URL in request",
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Проверка валидности URL
                <span class="cov10" title="3">if _, err := url.ParseRequestURI(originalURL); err != nil </span><span class="cov1" title="1">{
                        http.Error(res, "Invalid URL format", http.StatusBadRequest)
                        log.Error("Invalid URL in request",
                                zap.String("url", originalURL),
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov6" title="2">log.Debug("Processing URL shortening",
                        zap.String("originalURL", originalURL),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                // Генерация короткого ключа
                shortKey, err := urlHandler.GetShortKey(req.Context(), originalURL)

                // Обработка ошибок
                if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to generate short URL", http.StatusInternalServerError)
                        log.Error("Short URL generation failed",
                                zap.Error(err),
                                zap.String("originalURL", originalURL),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Формирование ответа
                <span class="cov6" title="2">response := Response{
                        Result: baseURL + "/" + shortKey,
                }

                res.Header().Set("Content-Type", "application/json")

                // Установка соответствующего HTTP-статуса
                if errors.Is(err, storage.ErrURLExists) </span><span class="cov1" title="1">{
                        res.WriteHeader(http.StatusConflict)
                        log.Debug("URL already exists",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span> else<span class="cov1" title="1"> {
                        res.WriteHeader(http.StatusCreated)
                        log.Debug("URL successfully shortened",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span>

                // Кодирование и отправка ответа
                <span class="cov6" title="2">if err := json.NewEncoder(res).Encode(response); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to encode response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package shorturl предоставляет обработчик для создания сокращённых URL через текстовый интерфейс.
//
// Пакет реализует:
// - Приём оригинального URL в текстовом формате
// - Валидацию входящего URL
// - Генерацию короткого ключа
// - Возврат результата в текстовом формате
package shorturl

import (
        "context"
        "errors"
        "io"
        "net/http"
        "net/url"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/storage"
)

// URLHandler определяет контракт для генерации коротких URL.
type URLHandler interface {
        // GetShortKey возвращает короткий ключ для оригинального URL.
        //
        // Параметры:
        //   ctx - контекст выполнения (должен включать таймаут)
        //   originalURL - валидный URL для сокращения
        //
        // Возвращает:
        //   string - короткий ключ
        //   error - возможные ошибки:
        //     - storage.ErrURLExists: URL уже существует
        //     - другие внутренние ошибки
        GetShortKey(ctx context.Context, originalURL string) (string, error)
}

// GetHandler создаёт HTTP-обработчик для текстового интерфейса сокращения URL.
//
// Спецификация API:
//
//        Метод: POST
//        Content-Type: text/plain
//        Путь: /
//
// Формат запроса:
//
//        Текстовое тело с оригинальным URL (например: "https://example.com/long/url")
//
// Формат ответа:
//
//        Текстовое тело с сокращённым URL (например: "http://short.ly/abc123")
//
// Коды ответа:
//   - 201 Created: URL успешно сокращён
//   - 400 Bad Request: невалидный запрос
//   - 409 Conflict: URL уже существует
//   - 500 Internal Server Error: внутренняя ошибка сервера
//
// Параметры:
//
//        urlHandler - сервис для генерации коротких ключей
//        baseURL - базовый адрес для построения полного короткого URL
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="3">{
                // Чтение и валидация тела запроса
                // Использование io.LimitReader, минимизация аллокаций
                body, err := io.ReadAll(io.LimitReader(req.Body, 1&lt;&lt;20)) // Ограничение 1MB
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to read request body", http.StatusBadRequest)
                        log.Error("Failed to read request body",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>
                <span class="cov10" title="3">defer req.Body.Close()

                originalURL := string(body)
                if originalURL == "" </span><span class="cov0" title="0">{
                        http.Error(res, "URL parameter is missing", http.StatusBadRequest)
                        log.Error("Empty URL in request",
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Валидация URL
                <span class="cov10" title="3">if _, err = url.ParseRequestURI(originalURL); err != nil </span><span class="cov1" title="1">{
                        http.Error(res, "Invalid URL format", http.StatusBadRequest)
                        log.Error("Invalid URL in request",
                                zap.String("url", originalURL),
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov6" title="2">log.Debug("Processing URL shortening",
                        zap.String("originalURL", originalURL),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                // Генерация короткого ключа
                shortKey, err := urlHandler.GetShortKey(req.Context(), originalURL)
                if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to generate short URL", http.StatusInternalServerError)
                        log.Error("Short URL generation failed",
                                zap.Error(err),
                                zap.String("originalURL", originalURL),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Формирование ответа
                <span class="cov6" title="2">res.Header().Set("Content-Type", "text/plain; charset=utf-8")
                shortURL := baseURL + "/" + shortKey

                if errors.Is(err, storage.ErrURLExists) </span><span class="cov1" title="1">{
                        res.WriteHeader(http.StatusConflict)
                        log.Debug("URL already exists",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span> else<span class="cov1" title="1"> {
                        res.WriteHeader(http.StatusCreated)
                        log.Debug("URL successfully shortened",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span>

                <span class="cov6" title="2">if _, err := res.Write([]byte(shortURL)); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to write response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package stats предоставляет обработчики HTTP для получения статистики сервиса.
package stats

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/ryabkov82/shortener/internal/app/models"
        "go.uber.org/zap"
)

// URLHandler определяет интерфейс для получения статистики сервиса.
// Реализации этого интерфейса должны предоставлять данные о количестве URL и пользователей.
type URLHandler interface {
        // GetStats возвращает статистику сервиса.
        // Возвращает:
        //   - models.StatsResponse с количеством URL и пользователей
        //   - error в случае ошибки при получении данных
        GetStats(ctx context.Context) (models.StatsResponse, error)
}

// GetHandler создает HTTP-обработчик для получения статистики сервиса.
//
// Параметры:
//   - urlHandler: реализация интерфейса URLHandler для получения данных статистики
//   - log: логгер для записи событий и ошибок
//
// Возвращает:
//   - http.HandlerFunc, который обрабатывает GET-запросы по пути /api/internal/stats
//
// Поведение обработчика:
//   - Проверяет доступ по trusted_subnet (должен быть установлен через middleware)
//   - Возвращает:
//   - 200 OK и JSON с статистикой при успешном выполнении
//   - 403 Forbidden если IP не в доверенной подсети
//   - 500 Internal Server Error при ошибках получения данных
//   - Логирует все ошибки и успешные выполнения
//
// Пример ответа при успехе:
//
//        {
//          "urls": 100,
//          "users": 50
//        }
//
// Middleware:
//   - Должен быть установлен trustednet.CheckTrustedSubnet перед этим обработчиком
//   - Рекомендуется добавить mwlogger.RequestLogging для логирования запросов
func GetHandler(urlHandler URLHandler, log *zap.Logger) http.HandlerFunc <span class="cov6" title="2">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="3">{

                ctx := req.Context()

                stats, err := urlHandler.GetStats(ctx)

                if err != nil </span><span class="cov6" title="2">{
                        http.Error(res, "Failed to get stats", http.StatusInternalServerError)
                        log.Error("Failed to get stats",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov1" title="1">log.Debug("Stats received successfully",
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                res.Header().Set("Content-Type", "application/json")
                res.WriteHeader(http.StatusOK)
                // Кодирование и отправка ответа
                if err := json.NewEncoder(res).Encode(stats); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to encode response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package userurls предоставляет обработчик для получения списка URL пользователя.
//
// Пакет реализует:
// - Получение всех сокращённых URL авторизованного пользователя
// - Возврат данных в JSON-формате
// - Обработку случая отсутствия URL
package userurls

import (
        "context"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/models"
)

// URLHandler определяет контракт для получения URL пользователя.
type URLHandler interface {
        // GetUserUrls возвращает все сокращённые URL пользователя.
        //
        // Параметры:
        //   ctx - контекст выполнения (должен содержать идентификатор пользователя)
        //   baseURL - базовый адрес для построения полных коротких URL
        //
        // Возвращает:
        //   []models.URLMapping - список сопоставлений оригинальных и коротких URL
        //   error - ошибка выполнения (например, проблемы с хранилищем)
        GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error)
}

// GetHandler создаёт HTTP-обработчик для получения URL пользователя.
//
// Спецификация API:
//
//        Метод: GET
//        Путь: /api/user/urls
//        Требуется: JWT-аутентификация
//
// Формат ответа:
//
//        [
//          {
//            "short_url": "http://short.ly/abc123",
//            "original_url": "https://example.com/long/url"
//          },
//          ...
//        ]
//
// Коды ответа:
//   - 200 OK: успешный запрос (возвращает список URL)
//   - 204 No Content: у пользователя нет сохранённых URL
//   - 400 Bad Request: ошибка аутентификации
//   - 500 Internal Server Error: внутренняя ошибка сервера
//
// Параметры:
//
//        urlHandler - сервис для получения URL
//        baseURL - базовый адрес сервиса
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="2">{
                // Получение данных из хранилища
                responseData, err := urlHandler.GetUserUrls(req.Context(), baseURL)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to get user URLs", http.StatusInternalServerError)
                        log.Error("Failed to retrieve user URLs",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Обработка случая отсутствия URL
                <span class="cov10" title="2">if len(responseData) == 0 </span><span class="cov1" title="1">{
                        res.WriteHeader(http.StatusNoContent)
                        log.Debug("No URLs found for user",
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Формирование JSON-ответа
                <span class="cov1" title="1">res.Header().Set("Content-Type", "application/json")
                res.WriteHeader(http.StatusOK)

                encoder := json.NewEncoder(res)
                encoder.SetIndent("", "  ") // Форматирование JSON для читаемости
                if err := encoder.Encode(responseData); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to encode response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>

                <span class="cov1" title="1">log.Debug("Successfully returned user URLs",
                        zap.Int("count", len(responseData)),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package httpgzip предоставляет инструменты для сжатия и распаковки HTTP-трафика в формате gzip.
// Реализует пул объектов gzip.Writer и gzip.Reader для оптимизации производительности.
package httpgzip

import (
        "compress/gzip"
        "io"
        "net/http"
        "sync"
)

// Пул gzip.Writer для повторного использования объектов
var writerPool = sync.Pool{
        New: func() interface{} <span class="cov10" title="105">{
                return gzip.NewWriter(io.Discard)
        }</span>,
}

// Пул gzip.Reader для повторного использования объектов
var readerPool = sync.Pool{
        New: func() interface{} <span class="cov9" title="101">{
                return new(gzip.Reader)
        }</span>,
}

// init инициализирует пулы объектов предварительным заполнением.
//
// Опционально вызывается при старте приложения для уменьшения
// накладных расходов на создание объектов при первой нагрузке.
func init() <span class="cov5" title="9">{
        for i := 0; i &lt; 10; i++ </span><span class="cov9" title="90">{
                writerPool.Put(writerPool.New())
                readerPool.Put(readerPool.New())
        }</span>
}

// PutWriter возвращает gzip.Writer в пул для повторного использования.
//
// Параметры:
//   - zw: gzip.Writer для возврата в пул
func PutWriter(zw *gzip.Writer) <span class="cov8" title="48">{
        writerPool.Put(zw)
}</span>

// PutReader возвращает gzip.Reader в пул для повторного использования.
//
// Параметры:
//   - zr: gzip.Reader для возврата в пул
func PutReader(zr *gzip.Reader) <span class="cov6" title="20">{
        readerPool.Put(zr)
}</span>

// compressWriter реализует http.ResponseWriter с поддержкой gzip-сжатия.
type compressWriter struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

// NewCompressWriter создает новый compressWriter.
//
// Параметры:
//   - w: оригинальный http.ResponseWriter
//
// Возвращает:
//   - *compressWriter: обертку с поддержкой сжатия
func NewCompressWriter(w http.ResponseWriter) *compressWriter <span class="cov8" title="48">{
        zw := writerPool.Get().(*gzip.Writer)
        zw.Reset(w)
        return &amp;compressWriter{
                w:  w,
                zw: zw,
        }
}</span>

// Header возвращает HTTP-заголовки ответа.
func (c *compressWriter) Header() http.Header <span class="cov8" title="43">{
        return c.w.Header()
}</span>

// Write записывает сжатые данные в ответ.
func (c *compressWriter) Write(p []byte) (int, error) <span class="cov7" title="34">{
        c.w.Header().Del("Content-Length")
        return c.zw.Write(p)
}</span>

// WriteHeader устанавливает код статуса и заголовки ответа.
func (c *compressWriter) WriteHeader(statusCode int) <span class="cov8" title="48">{
        c.w.Header().Set("Content-Encoding", "gzip")
        c.w.WriteHeader(statusCode)
}</span>

// Close закрывает writer и возвращает его в пул.
func (c *compressWriter) Close() error <span class="cov8" title="48">{
        err := c.zw.Close()
        PutWriter(c.zw)
        return err
}</span>

// compressReader реализует io.ReadCloser с поддержкой gzip-распаковки.
type compressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

// NewCompressReader создает новый compressReader.
//
// Параметры:
//   - r: оригинальный io.ReadCloser
//
// Возвращает:
//   - *compressReader: обертку с поддержкой распаковки
//   - error: ошибка инициализации
func NewCompressReader(r io.ReadCloser) (*compressReader, error) <span class="cov6" title="20">{
        zr := readerPool.Get().(*gzip.Reader)
        if err := zr.Reset(r); err != nil </span><span class="cov0" title="0">{
                readerPool.Put(zr)
                return nil, err
        }</span>
        <span class="cov6" title="20">return &amp;compressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

// Read читает и распаковывает данные.
func (c compressReader) Read(p []byte) (n int, err error) <span class="cov6" title="20">{
        return c.zr.Read(p)
}</span>

// Close закрывает reader и возвращает его в пул.
func (c *compressReader) Close() error <span class="cov6" title="20">{
        err := c.r.Close()
        PutReader(c.zr)
        return err
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package jwtauth предоставляет функционал для работы с JWT токенами аутентификации.
package jwtauth

import (
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// Claims представляет кастомные claims JWT токена.
// Содержит идентификатор пользователя и стандартные claims.
type Claims struct {
        UserID               string `json:"user_id"` // Уникальный идентификатор пользователя
        jwt.RegisteredClaims        // Стандартные claims JWT
}

// ContextKey тип для ключей контекста.
// Используется для безопасного доступа к значениям в context.Context.
type ContextKey string

// UserIDContextKey ключ для хранения ID пользователя в контексте.
const UserIDContextKey ContextKey = "userID"

// GenerateNewToken генерирует новый JWT токен для пользователя.
//
// Параметры:
//   - jwtKey: секретный ключ для подписи токена
//
// Возвращает:
//   - string: подписанный JWT токен
//   - string: сгенерированный ID пользователя
//   - error: ошибка генерации токена
//
// Пример использования:
//
//        token, userID, err := GenerateNewToken([]byte("secret"))
func GenerateNewToken(jwtKey []byte) (string, string, error) <span class="cov10" title="30">{
        userID := uuid.New().String() // Генерация уникального ID пользователя

        claims := &amp;Claims{
                UserID: userID,
                // При необходимости можно добавить время экспирации:
                // RegisteredClaims: jwt.RegisteredClaims{
                //     ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
                // },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString(jwtKey)
        return tokenString, userID, err
}</span>

// CreateToken генерирует JWT по userID
func CreateToken(jwtKey []byte, userID string) (string, error) <span class="cov5" title="6">{

        claims := &amp;Claims{
                UserID: userID,
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtKey)

}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package logger предоставляет централизованную систему логирования для приложения
// на основе zap.Logger. Реализует паттерн синглтона для глобального доступа к логеру.
package logger

import (
        "go.uber.org/zap"
)

// Log - глобальный экземпляр логера, инициализированный no-op логером по умолчанию.
// No-op логер не производит никакого вывода и не аллоцирует ресурсы.
var Log *zap.Logger = zap.NewNop()

// Initialize настраивает глобальный логер с указанным уровнем логирования.
//
// Параметры:
//   - level: строка, определяющая уровень логирования (debug, info, warn, error, dpanic, panic, fatal)
//
// Возвращает:
//   - error: ошибка, если передан некорректный уровень логирования или возникла проблема при создании логера
//
// Пример использования:
//
//        err := logger.Initialize("debug")
//        if err != nil {
//            // обработка ошибки инициализации
//        }
//        logger.Log.Info("Логер успешно инициализирован")
func Initialize(level string) error <span class="cov10" title="13">{
        // Преобразование строкового уровня в zap.AtomicLevel
        lvl, err := zap.ParseAtomicLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Конфигурация логера в production-стиле (JSON-формат, stacktrace для ошибок)
        <span class="cov10" title="13">cfg := zap.NewProductionConfig()

        // Установка уровня логирования
        cfg.Level = lvl

        // Создание логера на основе конфигурации
        zl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Замена глобального логера
        <span class="cov10" title="13">Log = zl
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package pprof предоставляет HTTP-интерфейс для профилирования приложения
// с использованием стандартного пакета net/http/pprof.
package pprof

import (
        "net/http"
        "net/http/pprof"

        "go.uber.org/zap"

        "github.com/go-chi/chi/v5"

        "github.com/ryabkov82/shortener/internal/app/config"
)

// StartPProf запускает HTTP-сервер для профилирования приложения.
//
// Параметры:
//   - log: логер для записи ошибок
//   - config: конфигурация сервера профилирования
//   - Enabled: флаг включения сервера
//   - BindAddr: адрес для прослушивания (например, "localhost:6060")
//   - Endpoint: базовый URL для эндпоинтов (например, "/debug/pprof")
//   - AuthUser: логин для HTTP Basic Auth
//   - AuthPass: пароль для HTTP Basic Auth
//
// Пример использования:
//
//        cfg := config.PProfConfig{
//            Enabled:  true,
//            BindAddr: "localhost:6060",
//            Endpoint: "/debug/pprof",
//            AuthUser: "admin",
//            AuthPass: "secret",
//        }
//        pprof.StartPProf(logger.Log, cfg)
func StartPProf(log *zap.Logger, config config.PProfConfig) <span class="cov1" title="1">{
        if !config.Enabled </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov0" title="0">r := chi.NewRouter()

        registerPProfRoutes(r, config)

        server := &amp;http.Server{
                Addr:    config.BindAddr,
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error("failed to serve pprof server", zap.Error(err))
                }</span>
        }()
}

// basicAuthMiddleware создает middleware для HTTP Basic Authentication.
//
// Параметры:
//   - expectedUser: ожидаемое имя пользователя
//   - expectedPass: ожидаемый пароль
//
// Возвращает:
//   - middleware функцию для chi.Router
func basicAuthMiddleware(expectedUser, expectedPass string) func(http.Handler) http.Handler <span class="cov3" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov3" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="14">{
                        user, password, ok := r.BasicAuth()

                        if !ok || user != expectedUser || password != expectedPass </span><span class="cov4" title="3">{
                                w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov9" title="11">next.ServeHTTP(w, r)</span>
                })
        }
}

// Регистрируем стандартные обработчики pprof
func registerPProfRoutes(r *chi.Mux, config config.PProfConfig) <span class="cov1" title="1">{
        if !config.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">r.Route(config.Endpoint, func(r chi.Router) </span><span class="cov1" title="1">{
                // Применяем аутентификацию ко всем под-роутам
                r.Use(basicAuthMiddleware(config.AuthUser, config.AuthPass))

                // Регистрируем стандартные обработчики pprof
                r.Get("/", http.HandlerFunc(pprof.Index))
                r.Get("/cmdline", http.HandlerFunc(pprof.Cmdline))
                r.Get("/profile", http.HandlerFunc(pprof.Profile))
                r.Get("/symbol", http.HandlerFunc(pprof.Symbol))
                r.Get("/trace", http.HandlerFunc(pprof.Trace))

                // Регистрируем обработчики профилей
                r.Handle("/goroutine", pprof.Handler("goroutine"))
                r.Handle("/heap", pprof.Handler("heap"))
                r.Handle("/allocs", pprof.Handler("allocs"))
                r.Handle("/threadcreate", pprof.Handler("threadcreate"))
                r.Handle("/block", pprof.Handler("block"))
                r.Handle("/mutex", pprof.Handler("mutex"))
        }</span>)
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package interceptors

import (
        "context"
        "fmt"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"

        "github.com/golang-jwt/jwt/v5"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// JWTAutoIssueGRPC возвращает gRPC-интерцептор для JWT-аутентификации с автоматической выдачей токенов.
//
// Интерцептор выполняет:
//   - Проверку JWT-токена из метаданных gRPC-запроса (ключ "token")
//   - Автоматическую генерацию и выдачу нового токена, если:
//   - Токен отсутствует
//   - Токен невалиден
//   - Токен не содержит UserID
//   - Добавление UserID в контекст вызова при успешной аутентификации
//   - Пропуск проверки для публичных методов (см. isPublicMethod)
//
// Параметры:
//   - jwtKey: секретный ключ для подписи JWT-токенов
//
// Возвращает:
//   - grpc.UnaryServerInterceptor: настроенный интерцептор аутентификации
//
// Особенности работы:
//   - Для извлечения токена используются метаданные gRPC (metadata)
//   - Новый токен устанавливается в заголовки ответа (grpc.SetHeader)
//   - Публичные методы определяются функцией isPublicMethod
//   - Контекст обогащается UserID (ключ jwtauth.UserIDContextKey)
//
// Пример использования:
//
//        server := grpc.NewServer(
//            grpc.ChainUnaryInterceptor(
//                interceptor.JWTAutoIssueGRPC([]byte("secret")),
//            ),
//        )
//
// Схема работы:
//  1. Проверка метода в isPublicMethod
//  2. Извлечение токена из metadata["token"]
//  3. Валидация токена и проверка claims
//  4. Выдача нового токена при необходимости
//  5. Добавление UserID в контекст
//  6. Вызов основного обработчика
func JWTAutoIssueGRPC(jwtKey []byte) grpc.UnaryServerInterceptor <span class="cov7" title="10">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov10" title="23">{
                // Пропускаем аутентификацию для публичных методов
                if isPublicMethod(info.FullMethod) </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                // Аналог r.Cookie() в HTTP - получаем токен из метаданных
                <span class="cov10" title="23">md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return issueNewTokenAndHandle(ctx, req, handler, jwtKey)
                }</span>

                <span class="cov10" title="23">tokens := md.Get("token")
                if len(tokens) == 0 </span><span class="cov6" title="7">{
                        return issueNewTokenAndHandle(ctx, req, handler, jwtKey)
                }</span>

                // Парсинг и валидация токена (аналогично HTTP)
                <span class="cov8" title="16">claims := &amp;jwtauth.Claims{}

                token, err := jwt.ParseWithClaims(tokens[0], claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="16">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov8" title="16">return jwtKey, nil</span>
                })

                <span class="cov8" title="16">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        return issueNewTokenAndHandle(ctx, req, handler, jwtKey)
                }</span>

                // Если токен валиден, добавляем userID в контекст
                <span class="cov8" title="16">userID := claims.UserID
                if userID == "" </span><span class="cov0" title="0">{
                        return issueNewTokenAndHandle(ctx, req, handler, jwtKey)
                }</span>

                <span class="cov8" title="16">newCtx := context.WithValue(ctx, jwtauth.UserIDContextKey, claims.UserID)
                return handler(newCtx, req)</span>
        }
}

func StrictJWTAutoIssueGRPC(jwtKey []byte) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov0" title="0">{
                // Пропускаем аутентификацию для публичных методов
                if isPublicMethod(info.FullMethod) </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{

                        err := issueNewToken(ctx, jwtKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, "failed to generate token")
                        }</span>
                        <span class="cov0" title="0">return nil, status.Error(codes.Unauthenticated, "status unauthenticated")</span>
                }

                <span class="cov0" title="0">tokens := md.Get("token")
                if len(tokens) == 0 </span><span class="cov0" title="0">{
                        err := issueNewToken(ctx, jwtKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, "failed to generate token")
                        }</span>
                        <span class="cov0" title="0">return nil, status.Error(codes.Unauthenticated, "status unauthenticated")</span>
                }

                // Парсинг и валидация токена (аналогично HTTP)
                <span class="cov0" title="0">claims := &amp;jwtauth.Claims{}

                token, err := jwt.ParseWithClaims(tokens[0], claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return jwtKey, nil</span>
                })

                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        err := issueNewToken(ctx, jwtKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, "failed to generate token")
                        }</span>
                        <span class="cov0" title="0">return nil, status.Error(codes.Unauthenticated, "status unauthenticated")</span>
                }

                // Если токен валиден, добавляем userID в контекст
                <span class="cov0" title="0">userID := claims.UserID
                if userID == "" </span><span class="cov0" title="0">{
                        err := issueNewToken(ctx, jwtKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, "failed to generate token")
                        }</span>
                        <span class="cov0" title="0">return nil, status.Error(codes.Unauthenticated, "status unauthenticated")</span>
                }

                <span class="cov0" title="0">newCtx := context.WithValue(ctx, jwtauth.UserIDContextKey, claims.UserID)
                return handler(newCtx, req)</span>
        }
}

func issueNewToken(
        ctx context.Context,
        jwtKey []byte,
) error <span class="cov0" title="0">{
        // Генерация нового токена
        token, _, err := jwtauth.GenerateNewToken(jwtKey)
        if err != nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.Internal, "failed to create token")
        }</span>

        // Установка токена в заголовки ответа (аналог Set-Cookie)
        <span class="cov0" title="0">header := metadata.Pairs("token", token)
        grpc.SetHeader(ctx, header)

        return nil</span>
}

// Аналог issueNewToken в HTTP-версии
func issueNewTokenAndHandle(
        ctx context.Context,
        req interface{},
        handler grpc.UnaryHandler,
        jwtKey []byte,
) (interface{}, error) <span class="cov6" title="7">{
        // Генерация нового токена
        token, userID, err := jwtauth.GenerateNewToken(jwtKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to create token")
        }</span>

        // Установка токена в заголовки ответа (аналог Set-Cookie)
        <span class="cov6" title="7">header := metadata.Pairs("token", token)
        grpc.SetHeader(ctx, header)

        // Добавление userID в контекст
        newCtx := context.WithValue(ctx, jwtauth.UserIDContextKey, userID)
        return handler(newCtx, req)</span>
}

func isPublicMethod(method string) bool <span class="cov10" title="23">{
        publicMethods := map[string]bool{
                "/grpc.health.v1.Health/Check": true,
                // Другие публичные методы
        }
        return publicMethods[method]
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package interceptors

import (
        "context"
        "time"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/status"
)

// LoggingInterceptor возвращает gRPC-интерцептор для логирования вызовов методов.
//
// Интерцептор фиксирует:
//   - Полное имя вызываемого метода (info.FullMethod)
//   - Параметры запроса (req)
//   - Статус обработки (код и текстовое описание)
//   - Время выполнения вызова
//
// Параметры:
//   - log: логгер zap для записи сообщений (должен быть предварительно настроен)
//
// Возвращает:
//   - grpc.UnaryServerInterceptor: настроенный интерцептор логирования
//
// Особенности работы:
//   - Логирование происходит после выполнения основного обработчика
//   - Время выполнения измеряется с наносекундной точностью
//   - Ошибки преобразуются в gRPC-статусы для единообразного логирования
//   - Запросы логируются на уровне INFO
//
// Пример использования:
//
//        logger, _ := zap.NewProduction()
//        server := grpc.NewServer(
//            grpc.ChainUnaryInterceptor(
//                LoggingInterceptor(logger),
//            ),
//        )
//
// Формат логов:
//
//        {
//          "method": "/service.Name/MethodName",
//          "request": {...},
//          "status_code": 2,
//          "status": "UNKNOWN",
//          "duration": "12.345ms"
//        }
func LoggingInterceptor(log *zap.Logger) grpc.UnaryServerInterceptor <span class="cov7" title="10">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (resp interface{}, err error) </span><span class="cov10" title="23">{
                // Фиксируем время начала обработки
                startTime := time.Now()

                // Отложенное логирование после обработки
                defer func() </span><span class="cov10" title="23">{
                        duration := time.Since(startTime)
                        st, _ := status.FromError(err)

                        log.Info("gRPC request completed",
                                zap.String("method", info.FullMethod),     // Полное имя метода (например /shortener.Shortener/CreateShortURL)
                                zap.Any("request", req),                   // Входные параметры
                                zap.Int("status_code", int(st.Code())),    // Код статуса gRPC
                                zap.String("status", st.Code().String()),  // Текстовый статус
                                zap.String("duration", duration.String()), // Время обработки
                        )
                }</span>()

                // Вызываем следующий обработчик
                <span class="cov10" title="23">return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// internal/server/grpc/interceptors/trusted_subnet.go
package interceptors

import (
        "context"
        "net"
        "strings"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/peer"
        "google.golang.org/grpc/status"
)

// TrustedSubnetConfig содержит конфигурацию для интерцептора проверки доверенных подсетей.
//
// Используется для ограничения доступа к gRPC-методам только из определенных IP-подсетей.
// Применяется в TrustedSubnetInterceptor.
//
// Поля:
//
//   - TrustedSubnet: строка в CIDR-нотации, определяющая доверенную подсеть.
//     Формат: "IPv4/маска" или "IPv6/маска" (например "192.168.1.0/24").
//     Пустая строка означает отсутствие настроенной подсети.
//
//   - ProtectedMethods: map[string]bool, где ключи - это имена gRPC-методов,
//     которые требуют проверки доступа. Поддерживает два формата:
//
//   - Полное имя метода (например "/shortener.Shortener/Stats")
//
//   - Префикс сервиса (например "/shortener.Admin/" для всех методов сервиса)
//     Примечание: регистрозависимый поиск.
//
//   - DenyIfNotConfigured: флаг, определяющий поведение при отсутствии настроенной подсети.
//
//   - true - возвращать ошибку PermissionDenied
//
//   - false - пропускать запрос без проверки
//     Рекомендуемое значение для production: true.
type TrustedSubnetConfig struct {
        TrustedSubnet string
        // Методы, требующие проверки (например: ["/shortener.Shortener/Stats"])
        ProtectedMethods map[string]bool
        // Блокировать если подсеть не настроена (true) или пропускать (false)
        DenyIfNotConfigured bool
}

// TrustedSubnetInterceptor возвращает gRPC-интерцептор для контроля доступа по доверенным подсетям.
//
// Интерцептор выполняет:
//   - Проверку принадлежности IP-адреса клиента к указанной доверенной подсети
//   - Выборочное применение проверки только к защищенным методам (см. TrustedSubnetConfig)
//   - Гибкую настройку поведения при отсутствии конфигурации подсети
//
// Параметры:
//   - cfg: конфигурация интерцептора (TrustedSubnetConfig):
//   - TrustedSubnet: CIDR-нотация подсети (например "192.168.1.0/24")
//   - ProtectedMethods: список защищаемых gRPC-методов
//   - DenyIfNotConfigured: блокировать вызовы если подсеть не настроена
//
// Возвращает:
//   - grpc.UnaryServerInterceptor: настроенный интерцептор контроля доступа
//
// Логика работы:
//  1. Проверка метода на наличие в ProtectedMethods
//  2. Если подсеть не задана:
//     - DenyIfNotConfigured=true: возвращает PermissionDenied
//     - DenyIfNotConfigured=false: пропускает запрос
//  3. Определение IP-адреса клиента (X-Forwarded-For → X-Real-IP → peer)
//  4. Проверка принадлежности IP к доверенной подсети
//  5. При отказе: возвращает PermissionDenied с детальным описанием
//
// Пример использования:
//
//        interceptor := TrustedSubnetInterceptor(TrustedSubnetConfig{
//            TrustedSubnet: "10.0.0.0/8",
//            ProtectedMethods: map[string]bool{
//                "/shortener.Shortener/Stats": true,
//            },
//            DenyIfNotConfigured: true,
//        })
//        server := grpc.NewServer(grpc.ChainUnaryInterceptor(interceptor))
//
// Особенности:
//   - Поддерживает CIDR-нотацию для IPv4/IPv6
//   - Совместим с прокси (X-Forwarded-For/X-Real-IP)
//   - Гибкая настройка через ProtectedMethods (поддержка wildcards)
//   - Детализированные сообщения об ошибках
//
// Рекомендации:
//   - Для публичных методов исключайте проверку через ProtectedMethods
//   - В production всегда устанавливайте DenyIfNotConfigured=true
//   - Логируйте факты отказа в доступе
func TrustedSubnetInterceptor(cfg TrustedSubnetConfig) grpc.UnaryServerInterceptor <span class="cov9" title="5">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov10" title="6">{
                // Проверяем, требуется ли проверка для этого метода
                if !cfg.isMethodProtected(info.FullMethod) </span><span class="cov4" title="2">{
                        return handler(ctx, req)
                }</span>

                // Если подсеть не задана
                <span class="cov7" title="4">if cfg.TrustedSubnet == "" </span><span class="cov0" title="0">{
                        if cfg.DenyIfNotConfigured </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.PermissionDenied, "trusted subnet not configured")
                        }</span>
                        <span class="cov0" title="0">return handler(ctx, req)</span>
                }

                // Получаем IP клиента
                <span class="cov7" title="4">clientIP, err := getClientIP(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.PermissionDenied, err.Error())
                }</span>

                // Парсим доверенную подсеть
                <span class="cov7" title="4">_, subnet, err := net.ParseCIDR(cfg.TrustedSubnet)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, "invalid trusted subnet configuration")
                }</span>

                // Проверяем принадлежность IP к подсети
                <span class="cov7" title="4">ip := net.ParseIP(clientIP)
                if ip == nil || !subnet.Contains(ip) </span><span class="cov1" title="1">{
                        return nil, status.Error(codes.PermissionDenied, "access denied: IP not in trusted subnet")
                }</span>

                <span class="cov6" title="3">return handler(ctx, req)</span>
        }
}

func (c *TrustedSubnetConfig) isMethodProtected(method string) bool <span class="cov10" title="6">{
        // Проверяем полное совпадение метода
        if c.ProtectedMethods[method] </span><span class="cov7" title="4">{
                return true
        }</span>

        // Проверяем совпадение по префиксу (для группировки методов)
        <span class="cov4" title="2">for m := range c.ProtectedMethods </span><span class="cov4" title="2">{
                if strings.HasPrefix(method, m) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov4" title="2">return false</span>
}

func getClientIP(ctx context.Context) (string, error) <span class="cov7" title="4">{
        // 1. Пробуем получить из X-Forwarded-For (если есть прокси)
        if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov7" title="4">{
                if forwardedIPs := md.Get("x-forwarded-for"); len(forwardedIPs) &gt; 0 </span><span class="cov0" title="0">{
                        return strings.Split(forwardedIPs[0], ",")[0], nil
                }</span>
                <span class="cov7" title="4">if realIPs := md.Get("x-real-ip"); len(realIPs) &gt; 0 </span><span class="cov7" title="4">{
                        return realIPs[0], nil
                }</span>
        }

        // 2. Получаем из peer информации
        <span class="cov0" title="0">if p, ok := peer.FromContext(ctx); ok </span><span class="cov0" title="0">{
                switch addr := p.Addr.(type) </span>{
                case *net.TCPAddr:<span class="cov0" title="0">
                        return addr.IP.String(), nil</span>
                case *net.UDPAddr:<span class="cov0" title="0">
                        return addr.IP.String(), nil</span>
                default:<span class="cov0" title="0">
                        return addr.String(), nil</span>
                }
        }

        <span class="cov0" title="0">return "", status.Error(codes.PermissionDenied, "could not determine client IP")</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package grpcserver

import (
        "net"

        "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/config"
        grpchandlers "github.com/ryabkov82/shortener/internal/app/handlers/grpc"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/batch"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/deluserurls"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/ping"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/redirect"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/shorturl"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/stats"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/userurls"
        "github.com/ryabkov82/shortener/internal/app/service"
        "go.uber.org/zap"
        "google.golang.org/grpc"
)

// StartGRPCServer создает и запускает gRPC сервер
func StartGRPCServer(log *zap.Logger, cfg *config.Config, srv *service.Service) *grpc.Server <span class="cov0" title="0">{

        // Создаем базовый обработчик с общими зависимостями
        baseHandler := base.NewBaseHandler(log)

        // Инициализация конкретных обработчиков
        shorturlHandler := shorturl.New(
                baseHandler,
                srv,
                cfg.BaseURL,
        )

        redirectHandler := redirect.New(
                baseHandler,
                srv,
        )

        batchHandler := batch.New(
                baseHandler,
                srv,
                cfg.BaseURL,
        )

        deluserurlsHandler := deluserurls.New(
                baseHandler,
                srv,
        )

        userurlsHandler := userurls.New(
                baseHandler,
                srv,
                cfg.BaseURL,
        )

        statsHandler := stats.New(
                baseHandler,
                srv,
        )

        pingHandler := ping.New(
                baseHandler,
                srv,
        )

        // Создаем агрегированный сервер
        aggregateHandler := grpchandlers.NewServer(
                baseHandler,
                grpchandlers.WithCreateShortURLEndpoint(shorturlHandler),
                grpchandlers.WithGetOriginalURLEndpoint(redirectHandler),
                grpchandlers.WithBatchCreateEndpoint(batchHandler),
                grpchandlers.WithDeleteUserURLsEndpoint(deluserurlsHandler),
                grpchandlers.WithGetUserURLsEndpoint(userurlsHandler),
                grpchandlers.WithGetStatsEndpoint(statsHandler),
                grpchandlers.WithPingEndpoint(pingHandler),
        )

        commonInterceptors := baseHandler.CommonInterceptors(cfg)

        grpcServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(commonInterceptors...),
        )

        // Регистрация gRPC сервиса
        api.RegisterShortenerServer(grpcServer, aggregateHandler)

        lis, err := net.Listen("tcp", cfg.GRPCServerAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to listen gRPC", zap.Error(err))
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info("Starting gRPC server", zap.String("address", cfg.GRPCServerAddr))
                if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Error("gRPC server failed", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">return grpcServer</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package auth предоставляет middleware для аутентификации через JWT.
package auth

import (
        "context"
        "fmt"
        "net/http"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ryabkov82/shortener/internal/app/jwtauth"
)

// JWTAutoIssue создает middleware для автоматической выдачи JWT токенов.
//
// Middleware проверяет наличие валидного JWT токена в cookies:
// - Если токен отсутствует или невалиден - выдает новый токен
// - Если токен валиден - извлекает userID и передает в контекст
//
// Параметры:
//
//        jwtKey - ключ для подписи JWT токенов
//
// Возвращает:
//
//        func(next http.Handler) http.Handler - middleware функцию
func JWTAutoIssue(jwtKey []byte) func(next http.Handler) http.Handler <span class="cov5" title="6">{
        return func(next http.Handler) http.Handler </span><span class="cov7" title="10">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="27">{
                        cookie, err := r.Cookie("token")
                        if err != nil || cookie == nil </span><span class="cov4" title="4">{
                                userID := issueNewToken(w, jwtKey)
                                ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, userID)
                                r = r.WithContext(ctx)
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov9" title="23">tokenStr := cookie.Value
                        claims := &amp;jwtauth.Claims{}

                        token, err := jwt.ParseWithClaims(tokenStr, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov9" title="23">{
                                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                                }</span>
                                <span class="cov9" title="23">return jwtKey, nil</span>
                        })

                        <span class="cov9" title="23">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                                userID := issueNewToken(w, jwtKey)
                                ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, userID)
                                r = r.WithContext(ctx)
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov9" title="23">ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, claims.UserID)
                        r = r.WithContext(ctx)
                        next.ServeHTTP(w, r)</span>
                }

                <span class="cov7" title="10">return http.HandlerFunc(fn)</span>
        }
}

// StrictJWTAutoIssue создает строгий middleware для проверки JWT токенов.
//
// В отличие от JWTAutoIssue:
// - Не выдает новый токен при отсутствии/невалидности текущего
// - Возвращает 401 Unauthorized при отсутствии валидного токена
//
// Параметры:
//
//        jwtKey - ключ для подписи JWT токенов
//
// Возвращает:
//
//        func(next http.Handler) http.Handler - middleware функцию
func StrictJWTAutoIssue(jwtKey []byte) func(next http.Handler) http.Handler <span class="cov4" title="3">{
        return func(next http.Handler) http.Handler </span><span class="cov4" title="4">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov9" title="19">{
                        cookie, err := r.Cookie("token")
                        if err != nil || cookie == nil </span><span class="cov2" title="2">{
                                _ = issueNewToken(w, jwtKey)
                                http.Error(w, "Status unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="17">tokenStr := cookie.Value
                        claims := &amp;jwtauth.Claims{}

                        token, err := jwt.ParseWithClaims(tokenStr, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="17">{
                                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                                }</span>
                                <span class="cov8" title="17">return jwtKey, nil</span>
                        })

                        <span class="cov8" title="17">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                                _ = issueNewToken(w, jwtKey)
                                http.Error(w, "Status unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="17">ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, claims.UserID)
                        r = r.WithContext(ctx)
                        next.ServeHTTP(w, r)</span>
                }

                <span class="cov4" title="4">return http.HandlerFunc(fn)</span>
        }
}

// issueNewToken генерирует и устанавливает новый JWT токен.
//
// Параметры:
//
//        w - http.ResponseWriter для установки cookie
//        jwtKey - ключ для подписи JWT
//
// Возвращает:
//
//        string - идентификатор пользователя (userID)
func issueNewToken(w http.ResponseWriter, jwtKey []byte) string <span class="cov5" title="6">{
        token, userID, err := jwtauth.GenerateNewToken(jwtKey)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate token", http.StatusInternalServerError)
                return ""
        }</span>
        <span class="cov5" title="6">setTokenCookie(w, token)
        return userID</span>
}

// setTokenCookie устанавливает JWT токен в cookie.
//
// Параметры:
//
//        w - http.ResponseWriter для установки cookie
//        token - JWT токен для сохранения
func setTokenCookie(w http.ResponseWriter, token string) <span class="cov5" title="6">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "token",
                Value:    token,
                HttpOnly: true,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
        })
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package logger предоставляет middleware для логирования HTTP-запросов.
package logger

import (
        "net/http"
        "time"

        "github.com/go-chi/chi/v5/middleware"
        "go.uber.org/zap"
)

// RequestLogging создает middleware для логирования HTTP-запросов.
//
// Middleware логирует:
// - HTTP-метод
// - Путь запроса
// - Статус ответа
// - Размер ответа в байтах
// - Время обработки запроса
//
// Параметры:
//
//        log - логгер zap для записи логов
//
// Возвращает:
//
//        func(next http.Handler) http.Handler - middleware функцию
func RequestLogging(log *zap.Logger) func(next http.Handler) http.Handler <span class="cov6" title="11">{
        return func(next http.Handler) http.Handler </span><span class="cov6" title="11">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="53">{
                        // Создаем обертку для ResponseWriter для получения метрик ответа
                        ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        // Фиксируем время начала обработки запроса
                        t1 := time.Now()

                        // Отложенное выполнение логирования после обработки запроса
                        defer func() </span><span class="cov10" title="53">{
                                log.Info("request completed",
                                        zap.String("method", r.Method),                  // HTTP-метод (GET, POST и т.д.)
                                        zap.String("path", r.URL.Path),                  // Путь запроса
                                        zap.Int("status", ww.Status()),                  // HTTP-статус ответа
                                        zap.Int("bytes", ww.BytesWritten()),             // Размер ответа в байтах
                                        zap.String("duration", time.Since(t1).String()), // Время обработки
                                )
                        }</span>()

                        // Передаем управление следующему обработчику
                        <span class="cov10" title="53">next.ServeHTTP(ww, r)</span>
                }

                <span class="cov6" title="11">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package mwgzip предоставляет middleware для сжатия и распаковки HTTP-трафика в формате gzip.
package mwgzip

import (
        "net/http"
        "strings"

        "github.com/ryabkov82/shortener/internal/app/httpgzip"
)

// Gzip создает middleware для обработки gzip сжатия HTTP-запросов и ответов.
//
// Middleware выполняет:
// - Сжатие ответов в gzip, если клиент поддерживает прием сжатых данных
// - Распаковку входящих запросов, если они сжаты gzip
// - Прозрачную передачу данных, если gzip не используется
//
// Возвращает:
//
//        func(next http.Handler) http.Handler - middleware функцию
func Gzip(next http.Handler) http.Handler <span class="cov6" title="9">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="48">{
                // Используем оригинальный ResponseWriter по умолчанию
                ow := w

                // Проверяем поддержку gzip на стороне клиента
                acceptEncoding := r.Header.Get("Accept-Encoding")
                supportsGzip := strings.Contains(acceptEncoding, "gzip")
                if supportsGzip </span><span class="cov10" title="48">{
                        // Создаем обертку с поддержкой сжатия
                        cw := httpgzip.NewCompressWriter(w)
                        ow = cw
                        // Гарантируем закрытие компрессора
                        defer cw.Close()
                }</span>

                // Проверяем сжатие входящего запроса
                <span class="cov10" title="48">contentEncoding := r.Header.Get("Content-Encoding")
                sendsGzip := strings.Contains(contentEncoding, "gzip")
                if sendsGzip </span><span class="cov7" title="20">{
                        // Создаем reader с поддержкой распаковки
                        cr, err := httpgzip.NewCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov7" title="20">r.Body = cr
                        defer cr.Close()</span>
                }

                // Передаем управление следующему обработчику
                <span class="cov10" title="48">next.ServeHTTP(ow, r)</span>
        }

        <span class="cov6" title="9">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Package trustednet предоставляет security-мидлвары для HTTP-сервера.

Обеспечивает контроль доступа по IP-адресу через проверку вхождения
в доверенную подсеть. Основные сценарии использования:

1. Защита внутренних API эндпоинтов
2. Ограничение доступа к административным интерфейсам

Пример конфигурации nginx для корректной работы:

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_pass http://backend;
        }
*/
package trustednet

import (
        "net"
        "net/http"
)

// CheckTrustedSubnet создает middleware для проверки доступа по доверенной подсети.
//
// Параметры:
//   - trustedSubnet: строка в формате CIDR (например, "192.168.1.0/24"),
//     определяющая доверенную подсеть. Если пустая строка - доступ запрещен для всех.
//
// Возвращает:
//   - Middleware функцию для chi.Router или стандартного http.Handler
//
// Логика работы:
//  1. Если trustedSubnet пустой - все запросы отклоняются с 403 Forbidden
//  2. Проверяет наличие заголовка X-Real-IP
//  3. Валидирует переданный IP-адрес
//  4. Проверяет вхождение IP в доверенную подсеть
//
// Коды ответа:
//   - 403 Forbidden:
//   - trustedSubnet пустой
//   - Отсутствует X-Real-IP
//   - IP не входит в доверенную подсеть
//   - 500 Internal Server Error: невалидный формат trustedSubnet
//
// Пример использования:
//
//        r := chi.NewRouter()
//        r.Use(CheckTrustedSubnet("192.168.1.0/24"))
//        r.Get("/admin", adminHandler)
//
// Требования:
//   - Перед middleware должен быть установлен proxy (например, nginx), который
//     добавляет заголовок X-Real-IP с реальным IP клиента
//   - Формат trustedSubnet должен быть валидным CIDR
func CheckTrustedSubnet(trustedSubnet string) func(http.Handler) http.Handler <span class="cov4" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov4" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="5">{
                        if trustedSubnet == "" </span><span class="cov1" title="1">{
                                http.Error(w, "Access denied", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov8" title="4">realIP := r.Header.Get("X-Real-IP")
                        if realIP == "" </span><span class="cov0" title="0">{
                                http.Error(w, "X-Real-IP header required", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov8" title="4">_, subnet, err := net.ParseCIDR(trustedSubnet)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Invalid trusted subnet configuration", http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="4">ip := net.ParseIP(realIP)
                        if ip == nil || !subnet.Contains(ip) </span><span class="cov1" title="1">{
                                http.Error(w, "Access denied", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov7" title="3">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package httpserver

import (
        "net/http"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/batch"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/deluserurls"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/ping"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/redirect"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/shortenapi"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/shorturl"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/stats"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/userurls"
        "github.com/ryabkov82/shortener/internal/app/server/http/middleware/auth"
        mwlogger "github.com/ryabkov82/shortener/internal/app/server/http/middleware/logger"
        "github.com/ryabkov82/shortener/internal/app/server/http/middleware/mwgzip"
        "github.com/ryabkov82/shortener/internal/app/server/http/middleware/trustednet"
        "github.com/ryabkov82/shortener/internal/app/service"

        "github.com/go-chi/chi/v5"
)

// StartHTTPServer запускает HTTP-сервер.
func StartHTTPServer(log *zap.Logger, cfg *config.Config, srv *service.Service) *http.Server <span class="cov0" title="0">{

        log.Info("Starting http server", zap.String("address", cfg.HTTPServerAddr), zap.String("BaseURL", cfg.BaseURL))

        router := setupRouter(log, cfg, srv)

        server := &amp;http.Server{
                Addr:    cfg.HTTPServerAddr,
                Handler: router,
        }

        go runServer(log, server, cfg)
        return server

}</span>

// Приватные вспомогательные функции
func setupRouter(log *zap.Logger, cfg *config.Config, srv *service.Service) http.Handler <span class="cov0" title="0">{

        router := chi.NewRouter()
        // Настройка middleware и роутов
        router.Use(mwlogger.RequestLogging(log))
        router.Use(mwgzip.Gzip)

        router.Use(auth.JWTAutoIssue([]byte(cfg.JwtKey)))

        router.Post("/", shorturl.GetHandler(srv, cfg.BaseURL, log))
        router.Get("/{id}", redirect.GetHandler(srv, log))

        router.Post("/api/shorten", shortenapi.GetHandler(srv, cfg.BaseURL, log))

        router.Get("/ping", ping.GetHandler(srv, log))
        router.Post("/api/shorten/batch", batch.GetHandler(srv, cfg.BaseURL, log))
        router.Get("/api/user/urls", userurls.GetHandler(srv, cfg.BaseURL, log))
        router.Delete("/api/user/urls", deluserurls.GetHandler(srv, cfg.BaseURL, log))

        router.Group(func(router chi.Router) </span><span class="cov0" title="0">{
                router.Use(trustednet.CheckTrustedSubnet(cfg.TrustedSubnet))
                router.Get("/api/internal/stats", stats.GetHandler(srv, log))
        }</span>)

        <span class="cov0" title="0">return router</span>
}

func runServer(log *zap.Logger, server *http.Server, cfg *config.Config) <span class="cov0" title="0">{

        if cfg.EnableHTTPS </span><span class="cov0" title="0">{
                // Запуск сервера с HTTPS
                go func() </span><span class="cov0" title="0">{
                        if err := server.ListenAndServeTLS(cfg.SSLCertFile, cfg.SSLKeyFile); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                log.Error("failed to serve server", zap.Error(err))
                        }</span>
                }()
        } else<span class="cov0" title="0"> {
                go func() </span><span class="cov0" title="0">{
                        if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                log.Error("failed to serve server", zap.Error(err))
                        }</span>
                }()
        }

        <span class="cov0" title="0">log.Info("Server started", zap.String("address", cfg.HTTPServerAddr))</span>

}
</pre>
		
		<pre class="file" id="file38" style="display: none">// internal/server/run.go
package server

import (
        "context"
        "net/http"
        _ "net/http/pprof"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/pprof"
        grpcserver "github.com/ryabkov82/shortener/internal/app/server/grpc"
        httpserver "github.com/ryabkov82/shortener/internal/app/server/http"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/internal/app/storage/inmemory"
        "github.com/ryabkov82/shortener/internal/app/storage/postgres"
        "google.golang.org/grpc"

        "go.uber.org/zap"
)

func StartServers(log *zap.Logger, cfg *config.Config) <span class="cov0" title="0">{

        pprof.StartPProf(log, cfg.ConfigPProf)

        // 1. Инициализация хранилища и сервиса
        storage, err := initStorage(cfg, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to initialize storage", zap.Error(err))
        }</span>

        <span class="cov0" title="0">appService := service.NewService(storage)

        // 2. Запуск серверов
        httpServer := httpserver.StartHTTPServer(log, cfg, appService)
        grpcServer := grpcserver.StartGRPCServer(log, cfg, appService)

        // 3. Graceful shutdown
        waitForShutdown(log, httpServer, grpcServer, appService)</span>
}

// Вспомогательные функции
func initStorage(cfg *config.Config, log *zap.Logger) (service.Repository, error) <span class="cov0" title="0">{
        if cfg.DBConnect != "" </span><span class="cov0" title="0">{
                pg, err := postgres.NewPostgresStorage(cfg.DBConnect)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Info("Using PostgreSQL storage")
                return pg, nil</span>
        }

        <span class="cov0" title="0">mem, err := inmemory.NewInMemoryStorage(cfg.FileStorage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := mem.Load(cfg.FileStorage); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Info("Using in-memory storage", zap.String("file", cfg.FileStorage))
        return mem, nil</span>
}

func waitForShutdown(
        log *zap.Logger,
        httpServer *http.Server,
        grpcServer *grpc.Server,
        service *service.Service,
) <span class="cov0" title="0">{
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("Shutting down servers...")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Остановка HTTP сервера
        if err := httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error("HTTP server shutdown error", zap.Error(err))
        }</span>

        // Остановка gRPC сервера
        <span class="cov0" title="0">grpcServer.GracefulStop()

        // Завершение работы сервиса
        service.GracefulStop(5 * time.Second)
        if err := service.Close(); err != nil </span><span class="cov0" title="0">{
                log.Error("Storage close error", zap.Error(err))
        }</span>

        <span class="cov0" title="0">log.Info("Servers stopped gracefully")</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ryabkov82/shortener/internal/app/service (interfaces: Repository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        models "github.com/ryabkov82/shortener/internal/app/models"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov6" title="6">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov10" title="16">{
        return m.recorder
}</span>

// BatchMarkAsDeleted mocks base method.
func (m *MockRepository) BatchMarkAsDeleted(arg0 string, arg1 []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BatchMarkAsDeleted", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BatchMarkAsDeleted indicates an expected call of BatchMarkAsDeleted.
func (mr *MockRepositoryMockRecorder) BatchMarkAsDeleted(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchMarkAsDeleted", reflect.TypeOf((*MockRepository)(nil).BatchMarkAsDeleted), arg0, arg1)
}</span>

// Close mocks base method.
func (m *MockRepository) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockRepositoryMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRepository)(nil).Close))
}</span>

// CountURLs mocks base method.
func (m *MockRepository) CountURLs(arg0 context.Context) (int, error) <span class="cov6" title="6">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CountURLs", arg0)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CountURLs indicates an expected call of CountURLs.
func (mr *MockRepositoryMockRecorder) CountURLs(arg0 interface{}) *gomock.Call <span class="cov6" title="6">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountURLs", reflect.TypeOf((*MockRepository)(nil).CountURLs), arg0)
}</span>

// CountUsers mocks base method.
func (m *MockRepository) CountUsers(arg0 context.Context) (int, error) <span class="cov5" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CountUsers", arg0)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CountUsers indicates an expected call of CountUsers.
func (mr *MockRepositoryMockRecorder) CountUsers(arg0 interface{}) *gomock.Call <span class="cov5" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountUsers", reflect.TypeOf((*MockRepository)(nil).CountUsers), arg0)
}</span>

// GetExistingURLs mocks base method.
func (m *MockRepository) GetExistingURLs(arg0 context.Context, arg1 []string) (map[string]string, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetExistingURLs", arg0, arg1)
        ret0, _ := ret[0].(map[string]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetExistingURLs indicates an expected call of GetExistingURLs.
func (mr *MockRepositoryMockRecorder) GetExistingURLs(arg0, arg1 interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExistingURLs", reflect.TypeOf((*MockRepository)(nil).GetExistingURLs), arg0, arg1)
}</span>

// GetRedirectURL mocks base method.
func (m *MockRepository) GetRedirectURL(arg0 context.Context, arg1 string) (models.URLMapping, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRedirectURL", arg0, arg1)
        ret0, _ := ret[0].(models.URLMapping)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetRedirectURL indicates an expected call of GetRedirectURL.
func (mr *MockRepositoryMockRecorder) GetRedirectURL(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRedirectURL", reflect.TypeOf((*MockRepository)(nil).GetRedirectURL), arg0, arg1)
}</span>

// GetShortKey mocks base method.
func (m *MockRepository) GetShortKey(arg0 context.Context, arg1 string) (models.URLMapping, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetShortKey", arg0, arg1)
        ret0, _ := ret[0].(models.URLMapping)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetShortKey indicates an expected call of GetShortKey.
func (mr *MockRepositoryMockRecorder) GetShortKey(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetShortKey", reflect.TypeOf((*MockRepository)(nil).GetShortKey), arg0, arg1)
}</span>

// GetUserUrls mocks base method.
func (m *MockRepository) GetUserUrls(arg0 context.Context, arg1 string) ([]models.URLMapping, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserUrls", arg0, arg1)
        ret0, _ := ret[0].([]models.URLMapping)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserUrls indicates an expected call of GetUserUrls.
func (mr *MockRepositoryMockRecorder) GetUserUrls(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserUrls", reflect.TypeOf((*MockRepository)(nil).GetUserUrls), arg0, arg1)
}</span>

// Ping mocks base method.
func (m *MockRepository) Ping(arg0 context.Context) error <span class="cov5" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockRepositoryMockRecorder) Ping(arg0 interface{}) *gomock.Call <span class="cov5" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockRepository)(nil).Ping), arg0)
}</span>

// SaveNewURLs mocks base method.
func (m *MockRepository) SaveNewURLs(arg0 context.Context, arg1 []models.URLMapping) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveNewURLs", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveNewURLs indicates an expected call of SaveNewURLs.
func (mr *MockRepositoryMockRecorder) SaveNewURLs(arg0, arg1 interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveNewURLs", reflect.TypeOf((*MockRepository)(nil).SaveNewURLs), arg0, arg1)
}</span>

// SaveURL mocks base method.
func (m *MockRepository) SaveURL(arg0 context.Context, arg1 *models.URLMapping) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveURL", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveURL indicates an expected call of SaveURL.
func (mr *MockRepositoryMockRecorder) SaveURL(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveURL", reflect.TypeOf((*MockRepository)(nil).SaveURL), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package service реализует бизнес-логику сервиса сокращения URL.
//
// Основные функции:
// - Генерация коротких ключей
// - Управление хранилищем URL
// - Пакетная обработка запросов
// - Асинхронное удаление URL
package service

import (
        "context"
        "math/rand"
        "time"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/workers/deleteurls"
)

// Repository определяет интерфейс для работы с хранилищем URL.
type Repository interface {
        GetShortKey(context.Context, string) (models.URLMapping, error)
        GetRedirectURL(context.Context, string) (models.URLMapping, error)
        SaveURL(context.Context, *models.URLMapping) error
        Ping(context.Context) error
        SaveNewURLs(context.Context, []models.URLMapping) error
        GetExistingURLs(context.Context, []string) (map[string]string, error)
        GetUserUrls(context.Context, string) ([]models.URLMapping, error)
        BatchMarkAsDeleted(userID string, urls []string) error
        Close() error
        CountURLs(ctx context.Context) (int, error)
        CountUsers(ctx context.Context) (int, error)
}

// Service реализует основной сервис приложения.
type Service struct {
        repo         Repository               // Хранилище данных
        deleteworker *deleteurls.DeleteWorker // Воркер для асинхронного удаления
}

// NewService создает новый экземпляр сервиса.
//
// Параметры:
//
//        storage - реализация интерфейса Repository
//
// Возвращает:
//
//        *Service - инициализированный сервис
func NewService(storage Repository) *Service <span class="cov5" title="18">{
        // Инициализация воркера для удаления:
        // - 1 воркер
        // - Буфер на 10 задач
        // - Задержка 500мс перед обработкой
        delworker := deleteurls.NewDeleteWorker(1, 10, 500*time.Millisecond, storage)
        delworker.Start()

        return &amp;Service{
                repo:         storage,
                deleteworker: delworker,
        }
}</span>

// GetShortKey генерирует и сохраняет короткий ключ для URL.
//
// Параметры:
//
//        ctx - контекст с идентификатором пользователя
//        originalURL - URL для сокращения
//
// Возвращает:
//
//        string - сгенерированный короткий ключ
//        error - ошибка при сохранении:
//          - storage.ErrURLExists если URL уже существует
func (s *Service) GetShortKey(ctx context.Context, originalURL string) (string, error) <span class="cov6" title="34">{
        shortKey := generateShortKey()
        mapping := models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }

        err := s.repo.SaveURL(ctx, &amp;mapping)
        return mapping.ShortURL, err
}</span>

// GetRedirectURL возвращает оригинальный URL для редиректа.
//
// Параметры:
//
//        ctx - контекст запроса
//        shortKey - короткий идентификатор URL
//
// Возвращает:
//
//        string - оригинальный URL
//        error:
//          - storage.ErrURLNotFound если URL не существует
//          - storage.ErrURLDeleted если URL помечен как удаленный
func (s *Service) GetRedirectURL(ctx context.Context, shortKey string) (string, error) <span class="cov5" title="21">{
        mapping, err := s.repo.GetRedirectURL(ctx, shortKey)
        return mapping.OriginalURL, err
}</span>

// Ping проверяет доступность хранилища.
func (s *Service) Ping(ctx context.Context) error <span class="cov3" title="4">{
        return s.repo.Ping(ctx)
}</span>

// Batch обрабатывает пакетный запрос на сокращение URL.
//
// Параметры:
//
//        ctx - контекст с идентификатором пользователя
//        batchRequest - список URL для обработки
//        baseURL - базовый адрес для построения полных коротких URL
//
// Возвращает:
//
//        []models.BatchResponse - результаты обработки
//        error - ошибка при сохранении
func (s *Service) Batch(ctx context.Context, batchRequest []models.BatchRequest, baseURL string) ([]models.BatchResponse, error) <span class="cov3" title="4">{
        originalURLs := make([]string, len(batchRequest))
        for i, item := range batchRequest </span><span class="cov4" title="8">{
                originalURLs[i] = item.OriginalURL
        }</span>

        <span class="cov3" title="4">existingURLs, err := s.repo.GetExistingURLs(ctx, originalURLs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="4">var newURLs []models.URLMapping
        batchResponse := make([]models.BatchResponse, 0, len(batchRequest))

        for _, item := range batchRequest </span><span class="cov4" title="8">{
                if shortURL, ok := existingURLs[item.OriginalURL]; ok </span><span class="cov0" title="0">{
                        batchResponse = append(batchResponse, models.BatchResponse{
                                CorrelationID: item.CorrelationID,
                                ShortURL:      baseURL + "/" + shortURL,
                        })
                        continue</span>
                }

                <span class="cov4" title="8">shortURL := generateShortKey()
                newURLs = append(newURLs, models.URLMapping{
                        OriginalURL: item.OriginalURL,
                        ShortURL:    shortURL,
                })

                batchResponse = append(batchResponse, models.BatchResponse{
                        CorrelationID: item.CorrelationID,
                        ShortURL:      baseURL + "/" + shortURL,
                })</span>
        }

        <span class="cov3" title="4">if err := s.repo.SaveNewURLs(ctx, newURLs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="4">return batchResponse, nil</span>
}

// GetUserUrls возвращает все сокращенные URL пользователя.
//
// Параметры:
//
//        ctx - контекст с идентификатором пользователя
//        baseURL - базовый адрес для построения полных коротких URL
//
// Возвращает:
//
//        []models.URLMapping - список URL пользователя
//        error - ошибка при получении
func (s *Service) GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error) <span class="cov3" title="6">{
        return s.repo.GetUserUrls(ctx, baseURL)
}</span>

// GetStats возвращает статистику сервиса по количеству URL и пользователей.
//
// Параметры:
//   - ctx: контекст выполнения, может использоваться для передачи таймаутов
//
// Возвращает:
//   - models.StatsResponse: структура с полями:
//   - URLs: общее количество сокращенных URL в сервисе
//   - Users: количество уникальных пользователей в сервисе
//   - error: ошибка, если не удалось получить статистику:
//   - Ошибка базы данных при запросе CountURLs
//   - Ошибка базы данных при запросе CountUsers
//
// Логика работы:
//  1. Запрашивает общее количество URL через s.repo.CountURLs
//  2. При ошибке на этом шаге сразу возвращает ошибку
//  3. Запрашивает количество пользователей через s.repo.CountUsers
//  4. При ошибке на этом шаге возвращает ошибку
//  5. Формирует и возвращает структуру StatsResponse с полученными данными
//
// Пример использования:
//
//        stats, err := service.GetStats(context.Background())
//        if err != nil {
//            // обработка ошибки
//        }
//        fmt.Printf("Stats: %d URLs, %d Users\n", stats.URLs, stats.Users)
//
// Особенности:
//   - Метод атомарен - при ошибке любого из запросов статистика не возвращается
//   - Для работы требует корректной инициализации s.repo
//   - Контекст передается в нижележащие репозитории
//
// Взаимодействие с другими компонентами:
//   - Используется в stats.GetHandler для обработки HTTP-запросов
//   - Получает данные через интерфейс Repository
func (s *Service) GetStats(ctx context.Context) (models.StatsResponse, error) <span class="cov3" title="6">{

        urlCount, err := s.repo.CountURLs(ctx)
        if err != nil </span><span class="cov2" title="2">{
                return models.StatsResponse{}, err
        }</span>

        <span class="cov3" title="4">userCount, err := s.repo.CountUsers(ctx)
        if err != nil </span><span class="cov2" title="2">{
                return models.StatsResponse{}, err
        }</span>

        <span class="cov2" title="2">return models.StatsResponse{URLs: urlCount, Users: userCount}, nil</span>

}

// DeleteUserUrls помечает URL пользователя как удаленные (асинхронно).
//
// Параметры:
//
//        ctx - контекст с идентификатором пользователя
//        shortURLs - список коротких URL для удаления
//
// Возвращает:
//
//        error - ошибка при постановке задачи в очередь
func (s *Service) DeleteUserUrls(ctx context.Context, shortURLs []string) error <span class="cov4" title="12">{
        userID := ctx.Value(jwtauth.UserIDContextKey).(string)
        return s.deleteworker.Submit(deleteurls.DeleteTask{
                UserID:    userID,
                ShortURLs: shortURLs,
        })
}</span>

// GracefulStop корректно останавливает сервис.
//
// Параметры:
//
//        timeout - максимальное время ожидания завершения операций
func (s *Service) GracefulStop(timeout time.Duration) <span class="cov0" title="0">{
        s.deleteworker.GracefulStop(timeout)
}</span>

// Close освобождает ресурсы
func (s *Service) Close() error <span class="cov0" title="0">{
        return s.repo.Close()
}</span>

// generateShortKey генерирует случайный короткий ключ.
//
// Возвращает:
//
//        string - 8-символьный ключ из [a-zA-Z0-9]
func generateShortKey() string <span class="cov6" title="42">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        const keyLength = 8

        rand.New(rand.NewSource(time.Now().UnixNano()))
        shortKey := make([]byte, keyLength)
        for i := range shortKey </span><span class="cov10" title="336">{
                shortKey[i] = charset[rand.Intn(len(charset))]
        }</span>
        <span class="cov6" title="42">return string(shortKey)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package inmemory реализует in-memory хранилище для сервиса сокращения URL с персистентностью в файл.
//
// Основные особенности:
// - Хранение данных в памяти с синхронизацией через RWMutex
// - Сохранение данных в файл в формате JSON (append-only лог)
// - Поддержка транзакционности операций
// - Оптимизированное чтение для операций редиректа
package inmemory

import (
        "bufio"
        "context"
        "encoding/json"
        "errors"
        "os"
        "sync"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/storage"
)

// InMemoryStorage реализует интерфейс хранилища с in-memory кешем и файловой персистентностью.
//
// Структура использует:
// - userURLIndex: индекс для быстрого поиска по пользователю и оригинальному URL
// - shortCodeMap: основное хранилище сопоставлений
// - countRecords: счетчик записей для генерации UUID
// - file/encoder: для персистентного хранения
// - mu: RWMutex для синхронизации доступа
type InMemoryStorage struct {
        userURLIndex map[string]map[string]string
        shortCodeMap map[string]models.UserURLMapping
        file         *os.File
        encoder      *json.Encoder
        countRecords uint64
        mu           sync.RWMutex
}

// NewInMemoryStorage создает новое in-memory хранилище с файловой персистентностью.
//
// Параметры:
//
//        fileStoragePath - путь к файлу для хранения данных
//
// Возвращает:
//
//        *InMemoryStorage - инициализированное хранилище
//        error - ошибка при создании файла
//
// Пример:
//
//        storage, err := NewInMemoryStorage("data/storage.json")
func NewInMemoryStorage(fileStoragePath string) (*InMemoryStorage, error) <span class="cov7" title="11">{
        file, err := os.OpenFile(fileStoragePath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="11">return &amp;InMemoryStorage{
                userURLIndex: make(map[string]map[string]string),
                shortCodeMap: make(map[string]models.UserURLMapping),
                countRecords: 0,
                file:         file,
                encoder:      json.NewEncoder(file),
        }, nil</span>
}

// Load загружает данные из файла в память.
//
// Формат файла: JSON-строки (по одной на запись)
// В случае ошибки в строке она пропускается, но загрузка продолжается
//
// Параметры:
//
//        fileStoragePath - путь к файлу с данными
//
// Возвращает:
//
//        error - ошибка чтения файла
func (s *InMemoryStorage) Load(fileStoragePath string) error <span class="cov0" title="0">{
        file, err := os.OpenFile(fileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        var countRecords uint64

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Bytes()
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var url models.UserURLMapping
                if err := json.Unmarshal(line, &amp;url); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if url.UserID == "" || url.OriginalURL == "" || url.ShortURL == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if _, ok := s.userURLIndex[url.UserID]; !ok </span><span class="cov0" title="0">{
                        s.userURLIndex[url.UserID] = make(map[string]string)
                }</span>

                <span class="cov0" title="0">s.userURLIndex[url.UserID][url.OriginalURL] = url.ShortURL
                s.shortCodeMap[url.ShortURL] = url
                countRecords++</span>
        }

        <span class="cov0" title="0">s.countRecords = countRecords
        return scanner.Err()</span>
}

// GetShortKey возвращает короткий ключ для оригинального URL пользователя.
//
// Параметры:
//
//        ctx - контекст с userID
//        originalURL - URL для поиска
//
// Возвращает:
//
//        models.URLMapping - найденное соответствие
//        error - ошибка поиска (storage.ErrURLNotFound если не найден)
func (s *InMemoryStorage) GetShortKey(ctx context.Context, originalURL string) (models.URLMapping, error) <span class="cov4" title="4">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        userID := ctx.Value(jwtauth.UserIDContextKey)
        if userID == nil </span><span class="cov0" title="0">{
                return models.URLMapping{}, errors.New("userID is not set")
        }</span>

        <span class="cov4" title="4">shortKey, found := s.userURLIndex[userID.(string)][originalURL]
        if !found </span><span class="cov4" title="4">{
                return models.URLMapping{}, storage.ErrURLNotFound
        }</span>

        <span class="cov0" title="0">return models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }, nil</span>
}

// GetRedirectURL возвращает оригинальный URL для редиректа.
//
// Параметры:
//
//        ctx - контекст запроса
//        shortKey - короткий идентификатор URL
//
// Возвращает:
//
//        models.URLMapping - найденное соответствие
//        error:
//          - storage.ErrURLNotFound если URL не существует
//          - storage.ErrURLDeleted если URL помечен как удаленный
func (s *InMemoryStorage) GetRedirectURL(ctx context.Context, shortKey string) (models.URLMapping, error) <span class="cov8" title="14">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        url, found := s.shortCodeMap[shortKey]
        if !found </span><span class="cov4" title="4">{
                return models.URLMapping{}, storage.ErrURLNotFound
        }</span>

        <span class="cov7" title="10">if url.DeletedFlag </span><span class="cov5" title="6">{
                return models.URLMapping{}, storage.ErrURLDeleted
        }</span>

        <span class="cov4" title="4">return models.URLMapping{
                ShortURL:    url.ShortURL,
                OriginalURL: url.OriginalURL,
        }, nil</span>
}

// SaveURL сохраняет новое соответствие URL.
//
// Параметры:
//
//        ctx - контекст с userID
//        mapping - сохраняемое соответствие URL
//
// Возвращает:
//
//        error:
//          - storage.ErrShortURLExists если shortURL уже существует
//          - storage.ErrURLExists если originalURL уже существует
func (s *InMemoryStorage) SaveURL(ctx context.Context, mapping *models.URLMapping) error <span class="cov10" title="28">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, found := s.shortCodeMap[mapping.ShortURL]; found </span><span class="cov0" title="0">{
                return storage.ErrShortURLExists
        }</span>

        <span class="cov10" title="28">userID := ctx.Value(jwtauth.UserIDContextKey)
        if userID == nil </span><span class="cov0" title="0">{
                return errors.New("userID is not set")
        }</span>

        <span class="cov10" title="28">if _, ok := s.userURLIndex[userID.(string)]; !ok </span><span class="cov8" title="15">{
                s.userURLIndex[userID.(string)] = make(map[string]string)
        }</span>

        <span class="cov10" title="28">if shortURL, exists := s.userURLIndex[userID.(string)][mapping.OriginalURL]; exists </span><span class="cov3" title="3">{
                mapping.ShortURL = shortURL
                return storage.ErrURLExists
        }</span>

        <span class="cov9" title="25">s.userURLIndex[userID.(string)][mapping.OriginalURL] = mapping.ShortURL
        s.countRecords++

        userURLMapping := models.UserURLMapping{
                UUID:        s.countRecords,
                ShortURL:    mapping.ShortURL,
                OriginalURL: mapping.OriginalURL,
                UserID:      userID.(string),
                DeletedFlag: false,
        }
        s.shortCodeMap[mapping.ShortURL] = userURLMapping

        return s.encoder.Encode(userURLMapping)</span>
}

// Ping проверяет доступность хранилища (всегда возвращает nil).
func (s *InMemoryStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// GetExistingURLs возвращает существующие URL из списка.
//
// Параметры:
//
//        ctx - контекст с userID
//        originalURLs - список URL для проверки
//
// Возвращает:
//
//        map[string]string - карта существующих URL (originalURL -&gt; shortURL)
//        error - ошибка операции
func (s *InMemoryStorage) GetExistingURLs(ctx context.Context, originalURLs []string) (map[string]string, error) <span class="cov2" title="2">{
        existing := make(map[string]string)

        if len(originalURLs) == 0 </span><span class="cov0" title="0">{
                return existing, nil
        }</span>

        <span class="cov2" title="2">for _, originalURL := range originalURLs </span><span class="cov4" title="4">{
                mapping, err := s.GetShortKey(ctx, originalURL)
                if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLNotFound) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="4">if err == nil </span><span class="cov0" title="0">{
                        existing[mapping.OriginalURL] = mapping.ShortURL
                }</span>
        }

        <span class="cov2" title="2">return existing, nil</span>
}

// SaveNewURLs сохраняет список новых URL.
//
// Параметры:
//
//        ctx - контекст с userID
//        urls - список URL для сохранения
//
// Возвращает:
//
//        error - первая ошибка при сохранении
func (s *InMemoryStorage) SaveNewURLs(ctx context.Context, urls []models.URLMapping) error <span class="cov2" title="2">{
        for _, url := range urls </span><span class="cov4" title="4">{
                if err := s.SaveURL(ctx, &amp;url); err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// GetUserUrls возвращает все URL пользователя.
//
// Параметры:
//
//        ctx - контекст с userID
//        baseURL - базовый URL для построения полных коротких URL
//
// Возвращает:
//
//        []models.URLMapping - список URL пользователя
//        error - ошибка операции
func (s *InMemoryStorage) GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error) <span class="cov4" title="4">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        userID := ctx.Value(jwtauth.UserIDContextKey)
        if userID == nil </span><span class="cov0" title="0">{
                return nil, errors.New("userID is not set")
        }</span>

        <span class="cov4" title="4">userURLs, exists := s.userURLIndex[userID.(string)]
        if !exists </span><span class="cov2" title="2">{
                return nil, nil
        }</span>

        <span class="cov2" title="2">var result []models.URLMapping
        for originalURL, shortCode := range userURLs </span><span class="cov4" title="4">{
                result = append(result, models.URLMapping{
                        OriginalURL: originalURL,
                        ShortURL:    baseURL + "/" + shortCode,
                })
        }</span>
        <span class="cov2" title="2">return result, nil</span>
}

// CountURLs возвращает количество сокращённых URL в сервисе.
//
// Параметры:
//
//        ctx - контекст
//
// Возвращает:
//
//         int - количество сокращённых URL в сервисе
//                error - ошибка операции
func (s *InMemoryStorage) CountURLs(ctx context.Context) (int, error) <span class="cov0" title="0">{
        count := len(s.shortCodeMap)
        return count, nil
}</span>

// CountUsers возвращает количество пользователей в сервисе.
//
// Параметры:
//
//        ctx - контекст
//
// Возвращает:
//
//         int - количество пользователей в сервисе
//                error - ошибка операции
func (s *InMemoryStorage) CountUsers(ctx context.Context) (int, error) <span class="cov0" title="0">{
        count := len(s.userURLIndex)
        return count, nil
}</span>

// BatchMarkAsDeleted помечает URL пользователя как удаленные.
//
// Параметры:
//
//        userID - идентификатор пользователя
//        urls - список коротких URL для удаления
//
// Возвращает:
//
//        error - ошибка операции
func (s *InMemoryStorage) BatchMarkAsDeleted(userID string, urls []string) error <span class="cov6" title="8">{
        s.mu.Lock()
        defer s.mu.Unlock()

        for _, code := range urls </span><span class="cov7" title="10">{
                if mapping, exists := s.shortCodeMap[code]; exists &amp;&amp; mapping.UserID == userID </span><span class="cov5" title="6">{
                        mapping.DeletedFlag = true
                        s.shortCodeMap[code] = mapping
                        if err := s.encoder.Encode(mapping); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov6" title="8">return nil</span>
}

// FilePath возвращает путь к файлу, используемому хранилищем.
// Если файл не открыт, возвращает пустую строку.
func (s *InMemoryStorage) FilePath() string <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        if s.file == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return s.file.Name()</span>
}

// Close освобождает ресурсы
func (s *InMemoryStorage) Close() error <span class="cov7" title="11">{
        if s.file != nil </span><span class="cov7" title="11">{
                return s.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package postgres

import (
        "database/sql"
        "embed"
        "time"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        "github.com/golang-migrate/migrate/v4/source/iofs"
)

//go:embed migrations/*.sql
var fs embed.FS

func applyMigrations(db *sql.DB) error <span class="cov8" title="1">{
        // 1. Создаем драйвер для источника миграций (из embed.FS)
        sourceDriver, err := iofs.New(fs, "migrations")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 2. Создаем драйвер для базы данных
        <span class="cov8" title="1">dbDriver, err := postgres.WithInstance(db, &amp;postgres.Config{
                StatementTimeout: 5 * time.Minute, // Для операций миграции
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 3. Инициализируем мигратор
        <span class="cov8" title="1">m, err := migrate.NewWithInstance(
                "iofs",       // Имя драйвера источника
                sourceDriver, // Экземпляр драйвера источника
                "postgres",   // Имя драйвера БД
                dbDriver)     // Экземпляр драйвера БД
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 4. Применяем миграции
        <span class="cov8" title="1">if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package postgres предоставляет реализацию хранилища URL на PostgreSQL.
//
// Пакет включает:
// - Подключение к PostgreSQL с настройкой пула соединений
// - Подготовленные SQL-запросы для повышения производительности
// - Поддержку транзакций для пакетных операций
// - Обработку миграций базы данных
package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        _ "github.com/jackc/pgx/v5/stdlib"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/storage"
)

// PostgresStorage реализует интерфейс хранилища для работы с PostgreSQL.
type PostgresStorage struct {
        db              *sql.DB
        getShortURLStmt *sql.Stmt
        getURLStmt      *sql.Stmt
        insertURLStmt   *sql.Stmt
}

// NewPostgresStorage создает новое подключение к PostgreSQL и инициализирует хранилище.
//
// Параметры:
//   - StoragePath: строка подключения к PostgreSQL
//
// Возвращает:
//   - *PostgresStorage: инициализированное хранилище
//   - error: ошибка при подключении или инициализации
func NewPostgresStorage(storagePath string) (*PostgresStorage, error) <span class="cov1" title="1">{
        db, err := sql.Open("pgx", storagePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if err = applyMigrations(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("migrations failed: %w", err)
        }</span>

        // Настройка пула соединений
        <span class="cov1" title="1">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(25)
        db.SetConnMaxLifetime(5 * time.Minute)

        // Подготовка часто используемых запросов
        getShortURLStmt, err := db.Prepare(`SELECT short_code FROM short_urls WHERE original_url = $1 and user_id = $2`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">getURLStmt, err := db.Prepare(`SELECT original_url, is_deleted FROM short_urls WHERE short_code = $1`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">insertURLStmt, err := db.Prepare(`
        INSERT INTO short_urls (original_url, short_code, user_id)
        VALUES ($1, $2, $3)
        ON CONFLICT (user_id, original_url) DO UPDATE SET
                original_url = EXCLUDED.original_url
        RETURNING short_code, xmax;
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;PostgresStorage{db, getShortURLStmt, getURLStmt, insertURLStmt}, nil</span>
}

// Ping проверяет соединение с базой данных.
//
// Параметры:
//
//        ctx - контекст выполнения
//
// Возвращает:
//
//        error - ошибка соединения
func (s *PostgresStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        ctxTm, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()
        return s.db.PingContext(ctxTm)
}</span>

// GetShortKey возвращает сокращенный URL для оригинального.
//
// Параметры:
//
//        ctx - контекст выполнения
//        originalURL - оригинальный URL
//
// Возвращает:
//
//        models.URLMapping - соответствие URL
//        error - ошибка операции
func (s *PostgresStorage) GetShortKey(ctx context.Context, originalURL string) (models.URLMapping, error) <span class="cov0" title="0">{
        mapping := models.URLMapping{
                OriginalURL: originalURL,
        }

        userID := ctx.Value(jwtauth.UserIDContextKey)
        err := s.getShortURLStmt.QueryRowContext(ctx, originalURL, userID).Scan(&amp;mapping.ShortURL)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return mapping, storage.ErrURLNotFound
                }</span>
                <span class="cov0" title="0">return mapping, err</span>
        }

        <span class="cov0" title="0">return mapping, nil</span>
}

// GetRedirectURL возвращает оригинальный URL для сокращенного.
//
// Параметры:
//
//        ctx - контекст выполнения
//        shortKey - сокращенный ключ URL
//
// Возвращает:
//
//        models.URLMapping - соответствие URL
//        error - ошибка операции
func (s *PostgresStorage) GetRedirectURL(ctx context.Context, shortKey string) (models.URLMapping, error) <span class="cov7" title="7">{
        mapping := models.URLMapping{
                ShortURL: shortKey,
        }

        var deletedFlag bool
        err := s.getURLStmt.QueryRowContext(ctx, shortKey).Scan(&amp;mapping.OriginalURL, &amp;deletedFlag)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov3" title="2">{
                        return mapping, fmt.Errorf("%w", storage.ErrURLNotFound)
                }</span>
                <span class="cov0" title="0">return mapping, fmt.Errorf("ошибка при поиске URL: %w", err)</span>
        }

        <span class="cov6" title="5">if deletedFlag </span><span class="cov4" title="3">{
                return mapping, storage.ErrURLDeleted
        }</span>
        <span class="cov3" title="2">return mapping, nil</span>
}

// SaveURL сохраняет новое соответствие URL.
//
// Параметры:
//
//        ctx - контекст выполнения
//        mapping - соответствие URL для сохранения
//
// Возвращает:
//
//        error - ошибка операции
func (s *PostgresStorage) SaveURL(ctx context.Context, mapping *models.URLMapping) error <span class="cov10" title="13">{
        var xmax int64 // Системный столбец для определения конфликтов

        userID := ctx.Value(jwtauth.UserIDContextKey)
        err := s.insertURLStmt.QueryRowContext(ctx, mapping.OriginalURL, mapping.ShortURL, userID).Scan(&amp;mapping.ShortURL, &amp;xmax)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="13">if xmax &gt; 0 </span><span class="cov3" title="2">{
                err = storage.ErrURLExists
        }</span>

        <span class="cov10" title="13">return err</span>
}

// GetExistingURLs возвращает существующие сокращения для URL.
//
// Параметры:
//
//        ctx - контекст выполнения
//        originalURLs - список оригинальных URL
//
// Возвращает:
//
//        map[string]string - соответствия URL
//        error - ошибка операции
func (s *PostgresStorage) GetExistingURLs(ctx context.Context, originalURLs []string) (map[string]string, error) <span class="cov1" title="1">{
        existing := make(map[string]string)
        if len(originalURLs) == 0 </span><span class="cov0" title="0">{
                return existing, nil
        }</span>

        <span class="cov1" title="1">query := "SELECT original_url, short_code FROM short_urls WHERE original_url = ANY($1) and user_id = $2"
        userID := ctx.Value(jwtauth.UserIDContextKey)

        rows, err := s.db.QueryContext(ctx, query, originalURLs, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var originalURL, shortURL string
                if err := rows.Scan(&amp;originalURL, &amp;shortURL); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">existing[originalURL] = shortURL</span>
        }

        <span class="cov1" title="1">return existing, rows.Err()</span>
}

// SaveNewURLs сохраняет пакет новых URL.
//
// Параметры:
//
//        ctx - контекст выполнения
//        urls - список URL для сохранения
//
// Возвращает:
//
//        error - ошибка операции
func (s *PostgresStorage) SaveNewURLs(ctx context.Context, urls []models.URLMapping) error <span class="cov1" title="1">{
        if len(urls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">userID := ctx.Value(jwtauth.UserIDContextKey)

        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov1" title="1">stmt, err := tx.Prepare("INSERT INTO short_urls (original_url, short_code, user_id) VALUES($1, $2, $3)")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer stmt.Close()

        for _, url := range urls </span><span class="cov3" title="2">{
                _, err = stmt.ExecContext(ctx, url.OriginalURL, url.ShortURL, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return tx.Commit()</span>
}

// GetUserUrls возвращает все URL пользователя.
//
// Параметры:
//
//        ctx - контекст выполнения
//        baseURL - базовый URL сервиса
//
// Возвращает:
//
//        []models.URLMapping - список URL пользователя
//        error - ошибка операции
func (s *PostgresStorage) GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error) <span class="cov3" title="2">{
        userID := ctx.Value(jwtauth.UserIDContextKey)
        query := "SELECT original_url, short_code FROM short_urls WHERE user_id = $1"

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var userURLs []models.URLMapping
        for rows.Next() </span><span class="cov3" title="2">{
                var originalURL, shortURL string
                if err := rows.Scan(&amp;originalURL, &amp;shortURL); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">userURLs = append(userURLs, models.URLMapping{
                        OriginalURL: originalURL,
                        ShortURL:    baseURL + "/" + shortURL,
                })</span>
        }

        <span class="cov3" title="2">return userURLs, rows.Err()</span>
}

// BatchMarkAsDeleted помечает URL пользователя как удаленные.
//
// Параметры:
//
//        userID - идентификатор пользователя
//        urls - список коротких URL для удаления
//
// Возвращает:
//
//        error - ошибка операции
func (s *PostgresStorage) BatchMarkAsDeleted(userID string, urls []string) error <span class="cov5" title="4">{
        if len(urls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov5" title="4">var params []interface{}
        query := "UPDATE short_urls SET is_deleted = true WHERE short_code IN ("

        for i, url := range urls </span><span class="cov6" title="5">{
                query += fmt.Sprintf("$%d,", i+1)
                params = append(params, url)
        }</span>
        <span class="cov5" title="4">query = strings.TrimSuffix(query, ",") + ") AND user_id = $" + fmt.Sprintf("%d", len(urls)+1)
        params = append(params, userID)

        _, err := s.db.Exec(query, params...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error updating batch: %w", err)
        }</span>

        <span class="cov5" title="4">return nil</span>
}

// CountURLs возвращает количество сокращённых URL в сервисе.
//
// Параметры:
//
//        ctx - контекст
//
// Возвращает:
//
//         int - количество сокращённых URL в сервисе
//                error - ошибка операции
func (s *PostgresStorage) CountURLs(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        err := s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM short_urls").Scan(&amp;count)
        return count, err
}</span>

// CountUsers возвращает количество пользователей в сервисе.
//
// Параметры:
//
//        ctx - контекст
//
// Возвращает:
//
//         int - количество пользователей в сервисе
//                error - ошибка операции
func (s *PostgresStorage) CountUsers(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        err := s.db.QueryRowContext(ctx, "SELECT COUNT(DISTINCT user_id) FROM short_urls").Scan(&amp;count)
        return count, err
}</span>

// Close освобождает ресурсы
func (s *PostgresStorage) Close() error <span class="cov0" title="0">{
        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package deleteurls предоставляет асинхронный обработчик для пакетного удаления URL в сервисе сокращения ссылок.
//
// Пакет реализует паттерн "рабочий пул" с:
// - Группировкой запросов по пользователям
// - Настраиваемым размером пакета и временем ожидания
// - Параллельной обработкой с помощью пула воркеров
// - Поддержкой плавного завершения работы
package deleteurls

import (
        "errors"
        "log"
        "sync"
        "time"
)

// Repository определяет интерфейс хранилища, необходимый для работы DeleteWorker.
type Repository interface {
        // BatchMarkAsDeleted помечает несколько URL как удаленные для указанного пользователя.
        // Возвращает ошибку в случае неудачи.
        BatchMarkAsDeleted(userID string, urls []string) error
}

// DeleteTask представляет запрос на удаление нескольких сокращенных URL для пользователя.
type DeleteTask struct {
        UserID    string   // ID пользователя, инициировавшего запрос
        ShortURLs []string // Список сокращенных URL для пометки как удаленных
}

// DeleteWorker управляет жизненным циклом обработки удаления URL.
// Агрегирует запросы в пакеты и обрабатывает их асинхронно.
type DeleteWorker struct {
        repo        Repository
        taskChan    chan DeleteTask
        batchChan   chan map[string][]string
        stopChan    chan struct{}
        wg          sync.WaitGroup
        workerCount int
        batchSize   int
        batchWindow time.Duration
}

// NewDeleteWorker создает новый экземпляр DeleteWorker с заданными параметрами.
//
// Параметры:
//   - workerCount: количество воркеров для обработки пакетов
//   - batchSize: максимальный размер пакета перед обработкой
//   - batchWindow: максимальное время ожидания формирования пакета
//   - storage: реализация интерфейса Repository
func NewDeleteWorker(workerCount, batchSize int, batchWindow time.Duration, storage Repository) *DeleteWorker <span class="cov7" title="18">{
        return &amp;DeleteWorker{
                taskChan:    make(chan DeleteTask, 10000),
                batchChan:   make(chan map[string][]string, 100),
                stopChan:    make(chan struct{}),
                workerCount: workerCount,
                batchSize:   batchSize,
                batchWindow: batchWindow,
                repo:        storage,
        }
}</span>

// Start запускает воркеры и сборщик пакетов.
func (w *DeleteWorker) Start() <span class="cov7" title="18">{
        w.wg.Add(w.workerCount + 1) // +1 для сборщика пакетов

        go w.batchCollector() // Запускаем сборщик пакетов

        for i := 0; i &lt; w.workerCount; i++ </span><span class="cov7" title="18">{
                go w.batchProcessor() // Запускаем воркеры
        }</span>
}

// Submit добавляет новую задачу на удаление в очередь обработки.
// Возвращает ошибку если очередь переполнена.
func (w *DeleteWorker) Submit(task DeleteTask) error <span class="cov6" title="12">{
        select </span>{
        case w.taskChan &lt;- task:<span class="cov6" title="12">
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("очередь переполнена")</span>
        }
}

// batchCollector собирает задачи в пакеты по пользователям.
// Отправляет пакеты на обработку при достижении batchSize или по истечении batchWindow.
func (w *DeleteWorker) batchCollector() <span class="cov7" title="18">{
        defer w.wg.Done()

        batch := make(map[string][]string)
        ticker := time.NewTicker(w.batchWindow)
        defer ticker.Stop()

        for </span><span class="cov10" title="44">{
                select </span>{
                case &lt;-w.stopChan:<span class="cov0" title="0">
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                w.batchChan &lt;- batch
                        }</span>
                        <span class="cov0" title="0">close(w.batchChan)
                        return</span>

                case task, ok := &lt;-w.taskChan:<span class="cov6" title="12">
                        if !ok </span><span class="cov0" title="0">{
                                if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                        w.batchChan &lt;- batch
                                }</span>
                                <span class="cov0" title="0">close(w.batchChan)
                                return</span>
                        }

                        <span class="cov6" title="12">if urls, exists := batch[task.UserID]; exists </span><span class="cov0" title="0">{
                                batch[task.UserID] = append(urls, task.ShortURLs...)
                        }</span> else<span class="cov6" title="12"> {
                                batch[task.UserID] = task.ShortURLs
                        }</span>

                        <span class="cov6" title="12">if len(batch) &gt;= w.batchSize </span><span class="cov0" title="0">{
                                w.batchChan &lt;- batch
                                batch = make(map[string][]string)
                                ticker.Reset(w.batchWindow)
                        }</span>

                case &lt;-ticker.C:<span class="cov7" title="14">
                        if len(batch) &gt; 0 </span><span class="cov6" title="12">{
                                w.batchChan &lt;- batch
                                batch = make(map[string][]string)
                        }</span>
                }
        }
}

// batchProcessor обрабатывает пакеты задач, используя пул воркеров.
func (w *DeleteWorker) batchProcessor() <span class="cov7" title="18">{
        defer w.wg.Done()

        for batch := range w.batchChan </span><span class="cov6" title="12">{
                var batchWg sync.WaitGroup
                batchWg.Add(len(batch))

                concurrencyLimit := make(chan struct{}, w.workerCount*2)

                for userID, urls := range batch </span><span class="cov6" title="12">{
                        concurrencyLimit &lt;- struct{}{}

                        go func(userID string, urls []string) </span><span class="cov6" title="12">{
                                defer batchWg.Done()
                                defer func() </span><span class="cov6" title="12">{ &lt;-concurrencyLimit }</span>()

                                <span class="cov6" title="12">const subBatchSize = 50
                                for i := 0; i &lt; len(urls); i += subBatchSize </span><span class="cov6" title="12">{
                                        end := i + subBatchSize
                                        if end &gt; len(urls) </span><span class="cov6" title="12">{
                                                end = len(urls)
                                        }</span>
                                        <span class="cov6" title="12">subBatch := urls[i:end]

                                        if err := w.processUserBatch(userID, subBatch); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Ошибка при пометке URL как удалённых для пользователя %s: %v", userID, err)
                                        }</span>
                                }
                        }(userID, urls)
                }

                <span class="cov6" title="12">batchWg.Wait()</span>
        }
}

// processUserBatch выполняет пометку URL как удаленных в хранилище.
func (w *DeleteWorker) processUserBatch(userID string, urls []string) error <span class="cov6" title="12">{
        if err := w.repo.BatchMarkAsDeleted(userID, urls); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="12">return nil</span>
}

// GracefulStop выполняет плавное завершение работы с заданным таймаутом.
// Дожидается завершения обработки текущих задач или истечения таймаута.
func (w *DeleteWorker) GracefulStop(timeout time.Duration) <span class="cov0" title="0">{
        close(w.stopChan)

        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                w.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                log.Println("Все воркеры завершили работу")</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                log.Println("Таймаут ожидания завершения воркеров")</span>
        }

        <span class="cov0" title="0">close(w.taskChan)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Package testconfig предоставляет утилиты для настройки тестового окружения с использованием testcontainers.
//
// Основные возможности:
//   - Запуск контейнера PostgreSQL для интеграционных тестов
//   - Автоматическая конфигурация подключения к БД
//   - Параллельно-безопасная инициализация (используется sync.Once)
//   - Логирование работы контейнера в реальном времени
//
// Пример использования:
//
//        ctx := context.Background()
//        cfg := DefaultPGConfig()
//        container, dsn, err := StartPGContainer(ctx, cfg)
//        if err != nil {
//            log.Fatal(err)
//        }
//        defer container.Terminate(ctx)
//
//        db, err := sql.Open("postgres", dsn)
//        // ... работа с БД
//
// Пакет используется для интеграционных тестов, требующих изолированного экземпляра БД.
package testconfig

import (
        "context"
        "fmt"
        "log"
        "os"
        "sync"
        "time"

        "github.com/docker/go-connections/nat"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/wait"
)

var (
        pgContainer testcontainers.Container
        pgDSN       string
        pgOnce      sync.Once
)

// PGConfig содержит конфигурационные параметры для настройки контейнера PostgreSQL.
//
// Поля структуры:
//   - Image:    Docker-образ PostgreSQL (например, "postgres:13-alpine")
//   - User:     Имя пользователя для подключения к БД
//   - Password: Пароль пользователя БД
//   - DBName:   Название создаваемой базы данных
//   - Port:     Порт для подключения к PostgreSQL (формат "5432")
//
// Пример использования:
//
//        cfg := PGConfig{
//            Image:    "postgres:13-alpine",
//            User:     "testuser",
//            Password: "testpass",
//            DBName:   "testdb",
//            Port:     "5432",
//        }
//
// Примечания:
//   - Все поля обязательные
//   - Для тестов рекомендуется использовать образы с alpine
//   - Порт должен соответствовать порту, используемому в выбранном образе
type PGConfig struct {
        Image    string
        User     string
        Password string
        DBName   string
        Port     string
}

// DefaultPGConfig возвращает конфигурацию PostgreSQL со значениями по умолчанию
// Используется образ postgres:13-alpine с пользователем test, паролем test и БД test на порту 5432
func DefaultPGConfig() PGConfig <span class="cov1" title="1">{
        return PGConfig{
                Image:    "postgres:13-alpine",
                User:     "test",
                Password: "test",
                DBName:   "test",
                Port:     "5432",
        }
}</span>

// StartPGContainer запускает контейнер PostgreSQL с заданной конфигурацией.
// Использует sync.Once для гарантии однократного запуска контейнера.
// Возвращает:
//   - testcontainers.Container: интерфейс для управления контейнером
//   - string: DSN строку для подключения к БД
//   - error: ошибка, если возникла при запуске контейнера
//
// Контейнер будет автоматически остановлен при завершении работы приложения.
func StartPGContainer(ctx context.Context, cfg PGConfig) (testcontainers.Container, string, error) <span class="cov1" title="1">{
        var startErr error
        pgOnce.Do(func() </span><span class="cov1" title="1">{

                // Конвертируем строку в nat.Port
                pgPort := nat.Port(cfg.Port + "/tcp") // Например: "5432" -&gt; "5432/tcp"
                req := testcontainers.ContainerRequest{
                        Image:        cfg.Image,
                        ExposedPorts: []string{string(pgPort)},
                        Env: map[string]string{
                                "POSTGRES_USER":     cfg.User,
                                "POSTGRES_PASSWORD": cfg.Password,
                                "POSTGRES_DB":       cfg.DBName,
                        },
                        WaitingFor: wait.ForAll(
                                wait.ForLog("database system is ready"),
                                wait.ForListeningPort(pgPort),
                        ).WithDeadline(1 * time.Minute),
                }

                logger := log.New(os.Stdout, "[POSTGRES] ", log.LstdFlags)

                pgContainer, startErr = testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
                        ContainerRequest: req,
                        Started:          true,
                        Logger:           logger,
                })
                if startErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // Получаем логи в реальном времени
                <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                        reader, err := pgContainer.Logs(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Println("Failed to get logs:", err)
                                return
                        }</span>
                        <span class="cov1" title="1">defer reader.Close()

                        buf := make([]byte, 1024)
                        for </span><span class="cov10" title="117">{
                                n, err := reader.Read(buf)
                                if err != nil </span><span class="cov1" title="1">{
                                        return
                                }</span>
                                <span class="cov9" title="116">logger.Print(string(buf[:n]))</span>
                        }
                }()

                <span class="cov1" title="1">host, err := pgContainer.Host(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        startErr = err
                        return
                }</span>

                <span class="cov1" title="1">mappedPort, err := pgContainer.MappedPort(ctx, pgPort)
                if err != nil </span><span class="cov0" title="0">{
                        startErr = err
                        return
                }</span>

                <span class="cov1" title="1">pgDSN = fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
                        cfg.User, cfg.Password, host, mappedPort.Port(), cfg.DBName)</span>
        })

        <span class="cov1" title="1">return pgContainer, pgDSN, startErr</span>
}

// GetTestPGDSN возвращает DSN строку для подключения к тестовой БД PostgreSQL.
// Перед использованием необходимо вызвать StartPGContainer для инициализации контейнера.
func GetTestPGDSN() string <span class="cov0" title="0">{
        return pgDSN
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package testhandlers

import (
        "context"
        "encoding/json"
        "testing"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/test/testutils"
        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
        "google.golang.org/grpc/status"
)

func TestBatchGRPC(t *testing.T, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        tests := CommonBatchTestCases()

        for _, tt := range tests </span><span class="cov10" title="2">{
                t.Run("gRPC_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="2">{
                        var request []pb.BatchCreateItem
                        err := json.Unmarshal([]byte(tt.Request), &amp;request)
                        if err != nil </span><span class="cov1" title="1">{
                                // в случае некорректного JSON пропускаем
                                t.Skip("invalid request format for gRPC")
                        }</span>

                        <span class="cov1" title="1">var items []*pb.BatchCreateItem
                        for i := range request </span><span class="cov10" title="2">{
                                items = append(items, &amp;request[i])
                        }</span>

                        <span class="cov1" title="1">resp, err := grpcClient.BatchCreate(context.Background(), &amp;pb.BatchCreateRequest{Items: items})

                        if tt.WantStatus != testutils.StatusCreated </span><span class="cov0" title="0">{
                                require.Error(t, err)
                                st, _ := status.FromError(err)
                                assert.Equal(t, tt.WantStatus, testutils.GRPCCodeToStatusCode(st.Code()))
                                return
                        }</span>

                        <span class="cov1" title="1">require.NoError(t, err)
                        assert.Len(t, resp.Items, tt.ExpectedLength)</span>

                })
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package testhandlers

import (
        "bytes"
        "compress/gzip"
        "encoding/json"
        "testing"

        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/ryabkov82/shortener/internal/app/models"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestBatchHandler тестирует обработчик пакетного создания сокращённых URL (/api/shorten/batch).
//
// Проверяет следующие сценарии:
//   - Успешное создание сокращённых URL для пакета ссылок
//   - Обработку некорректных входных данных
//   - Работу сжатия gzip на входящих и исходящих данных
//   - Авторизацию через JWT cookie
//   - Соответствие форматов запроса и ответа API
//
// Тест создаёт полноценное HTTP-окружение с:
//   - Роутером Chi
//   - Middleware: логирование, gzip, JWT-авторизация
//   - Тестовым сервером httptest
//   - Поддержкой сжатия на клиенте и сервере
//
// Примеры тест-кейсов:
//   - Корректный запрос с валидными URL (ожидается 201 Created)
//   - Некорректный JSON (ожидается 400 Bad Request)
//
// Используемые компоненты:
//   - service.Service: бизнес-логика сервиса
//   - logger: система логирования
//   - testutils: утилиты для генерации тестовых данных
//   - resty: HTTP-клиент для тестирования
func TestBatch(t *testing.T, client *resty.Client) <span class="cov6" title="3">{

        //cookie, _ := testutils.CreateSignedCookie()

        tests := CommonBatchTestCases()

        for _, tt := range tests </span><span class="cov10" title="6">{
                t.Run("HTTP_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="6">{

                        buf := bytes.NewBuffer(nil)
                        zb := gzip.NewWriter(buf)
                        _, err := zb.Write([]byte(tt.Request))
                        assert.NoError(t, err)
                        err = zb.Close()
                        assert.NoError(t, err)

                        resp, err := client.R().
                                SetBody(buf).
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                Post("/api/shorten/batch")

                        assert.NoError(t, err)

                        // Проверяем статус ответа
                        assert.Equal(t, tt.WantStatus, testutils.HTTPStatusToStatusCode(resp.StatusCode()))
                        if tt.WantStatus == testutils.StatusCreated </span><span class="cov6" title="3">{
                                // проверим, что получили данные в нужном формате
                                var response []models.BatchResponse
                                err = json.Unmarshal(resp.Body(), &amp;response)
                                assert.NoError(t, err)
                        }</span>

                })
        }

}
</pre>
		
		<pre class="file" id="file48" style="display: none">package testhandlers

import (
        "net/http"

        "github.com/ryabkov82/shortener/test/testutils"
)

type ShortenURLTestCase struct {
        Name        string
        OriginalURL string
        Want        testutils.StatusCode
        Cookie      *http.Cookie
}

// ShortenResult — общий результат для обоих клиентов
type ShortenResult struct {
        ShortURL string
        Status   testutils.StatusCode
}

func CommonShortenURLTestCases() []ShortenURLTestCase <span class="cov8" title="3">{

        cookie, _ := testutils.CreateSignedCookie()

        return []ShortenURLTestCase{
                {
                        Name:        "valid URL",
                        OriginalURL: "https://example.com",
                        Want:        testutils.StatusCreated,
                        Cookie:      cookie,
                },
                {
                        Name:        "valid URL",
                        OriginalURL: "https://example.com",
                        Want:        testutils.StatusConflict,
                        Cookie:      cookie,
                },
                /*
                        {
                                Name:        "invalid JWT",
                                OriginalURL: "https://example.com",
                                Want:        testutils.StatusUnauthorized,
                                Setup: func() (context.Context, error) {
                                        return testutils.ContextWithJWT(context.Background(), "bad.token"), nil
                                },
                                Cookie: &amp;http.Cookie{},
                        },
                */
                {
                        Name:        "bad URL",
                        OriginalURL: "not-a-url",
                        Want:        testutils.StatusBadRequest,
                        Cookie:      cookie,
                },
        }
}</span>

type RedirectResult struct {
        Location string
        Status   testutils.StatusCode
}

type RedirectTestCase struct {
        Name           string
        ShortKey       string
        ExpectedStatus testutils.StatusCode
        ExpectedURL    string
}

func CommonRedirectTestCases(shortKey string, originalURL string) []RedirectTestCase <span class="cov8" title="3">{
        return []RedirectTestCase{
                {
                        Name:           "valid redirect",
                        ShortKey:       shortKey,
                        ExpectedStatus: testutils.StatusTemporaryRedirect,
                        ExpectedURL:    originalURL,
                },
                {
                        Name:           "not found",
                        ShortKey:       "not_existing_key",
                        ExpectedStatus: testutils.StatusNotFound,
                        ExpectedURL:    "",
                },
        }
}</span>

type BatchTestCase struct {
        Name           string
        Request        string
        WantStatus     testutils.StatusCode
        ExpectedLength int // сколько объектов в ответе
}

func CommonBatchTestCases() []BatchTestCase <span class="cov10" title="4">{
        return []BatchTestCase{
                {
                        Name: "valid batch request",
                        Request: `[
                        {"correlation_id": "123", "original_url": "https://example.com/page1"},
                        {"correlation_id": "456", "original_url": "https://example.com/page2"}
                ]`,
                        WantStatus:     testutils.StatusCreated,
                        ExpectedLength: 2,
                },
                {
                        Name:           "invalid json request",
                        Request:        `{}`,
                        WantStatus:     testutils.StatusBadRequest,
                        ExpectedLength: 0,
                },
        }
}</span>

type DelUserURLsTestCase struct {
        cookie         *http.Cookie
        name           string
        userID         string
        codesToDelete  []string
        shouldBeMarked []string
        wantStatus     testutils.StatusCode
}

func CommonDelUserURLsCases(user1URLs map[string]string) []DelUserURLsTestCase <span class="cov8" title="3">{

        user1 := "bf38c714-b8df-4f75-8578-ea6b5df32758"
        user2 := "93f3b6be-3f1c-452a-9cf9-475e160a3cb1"

        cookie1, err := testutils.CreateCookieByUserID(user1)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="3">cookie2, err := testutils.CreateCookieByUserID(user2)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="3">return []DelUserURLsTestCase{
                {
                        name:           "successful deletion",
                        userID:         user1,
                        cookie:         cookie1,
                        codesToDelete:  []string{user1URLs["url1"]},
                        wantStatus:     testutils.StatusAccepted,
                        shouldBeMarked: []string{user1URLs["url1"]},
                },
                {
                        name:           "delete multiple",
                        userID:         user1,
                        cookie:         cookie1,
                        codesToDelete:  []string{user1URLs["url2"], user1URLs["url3"]},
                        wantStatus:     testutils.StatusAccepted,
                        shouldBeMarked: []string{user1URLs["url2"], user1URLs["url3"]},
                },
                {
                        name:           "delete non-existent",
                        userID:         user1,
                        cookie:         cookie1,
                        codesToDelete:  []string{"nonexistent"},
                        wantStatus:     testutils.StatusAccepted,
                        shouldBeMarked: []string{},
                },
                {
                        name:           "delete other user's url",
                        userID:         user2,
                        cookie:         cookie2,
                        codesToDelete:  []string{user1URLs["url4"]},
                        wantStatus:     testutils.StatusAccepted,
                        shouldBeMarked: []string{}, // Не должно пометить как удаленный
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package testhandlers

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "testing"
        "time"

        "github.com/stretchr/testify/assert"
        "google.golang.org/grpc/status"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
)

// TestDelUserUrls тестирует обработчик удаления пользовательских URL (/api/user/urls).
//
// Проверяет следующие сценарии:
//   - Успешную пометку URL как удаленных (StatusAccepted)
//   - Пакетное удаление нескольких URL
//   - Попытку удаления несуществующих URL
//   - Попытку удаления URL другого пользователя
//   - Асинхронную природу удаления (проверка через последующий запрос)
//   - Работу сжатия gzip на входящих данных
//   - Авторизацию через JWT cookie
//
// Тест создает:
//   - Тестовое хранилище с URL для двух пользователей
//   - HTTP-сервер с middleware:
//   - Логирование
//   - Gzip сжатие
//   - JWT авторизация
//   - Набор тестовых случаев с разными сценариями удаления
//
// Примеры тест-кейсов:
//   - Удаление одного URL (ожидается 202 Accepted)
//   - Пакетное удаление (ожидается 202 Accepted)
//   - Попытка удаления URL другого пользователя
//   - Проверка статуса 410 Gone после удаления
//
// Особенности:
//   - Использует асинхронную модель удаления
//   - Проверяет реальное изменение статуса через последующий GET-запрос
//   - Поддерживает сжатие gzip в запросах
func TestDelUserUrls(t *testing.T, serv *service.Service, client *resty.Client) <span class="cov3" title="2">{

        user1URLs, _ := prepareTestURLs(serv)

        tests := CommonDelUserURLsCases(user1URLs)
        for _, tt := range tests </span><span class="cov8" title="8">{
                t.Run("HTTP"+tt.name, func(t *testing.T) </span><span class="cov8" title="8">{

                        // Подготовка запроса
                        body, _ := json.Marshal(tt.codesToDelete)
                        buf := bytes.NewBuffer(nil)
                        zb := gzip.NewWriter(buf)
                        _, err := zb.Write([]byte(body))
                        assert.NoError(t, err)
                        err = zb.Close()
                        assert.NoError(t, err)

                        // Запрос
                        resp, err := client.R().
                                SetBody(buf).
                                SetCookie(tt.cookie).
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                Delete("/api/user/urls")

                        // Проверки
                        assert.NoError(t, err)
                        assert.Equal(t, tt.wantStatus, testutils.HTTPStatusToStatusCode(resp.StatusCode()))

                        time.Sleep(500 * time.Millisecond)
                        // Проверка что URL помечены как удаленные
                        for _, code := range tt.codesToDelete </span><span class="cov9" title="10">{

                                resp, err := client.R().
                                        SetCookie(tt.cookie).
                                        Get("/" + code)

                                // Проверки
                                assert.NoError(t, err)
                                if resp.StatusCode() == http.StatusGone </span><span class="cov7" title="6">{
                                        assert.Contains(t, tt.shouldBeMarked, code)
                                }</span> else<span class="cov6" title="4"> {
                                        assert.NotContains(t, tt.shouldBeMarked, code)
                                }</span>

                        }
                })
        }
}

func TestDelUserUrlsGRPC(t *testing.T, serv *service.Service, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        user1URLs, _ := prepareTestURLs(serv)

        tests := CommonDelUserURLsCases(user1URLs)
        for _, tt := range tests </span><span class="cov6" title="4">{
                t.Run("gRPC"+tt.name, func(t *testing.T) </span><span class="cov6" title="4">{

                        token := tt.cookie.Value
                        ctx := testutils.ContextWithJWT(context.Background(), token)

                        _, err := grpcClient.DeleteUserURLs(ctx, &amp;pb.DeleteRequest{ShortUrls: tt.codesToDelete})
                        assert.NoError(t, err)

                        time.Sleep(500 * time.Millisecond)
                        // Проверка что URL помечены как удаленные
                        for _, code := range tt.codesToDelete </span><span class="cov6" title="5">{

                                _, err := grpcClient.GetOriginalURL(ctx, &amp;pb.GetRequest{ShortUrl: code})

                                var redirectStatus testutils.StatusCode
                                if err != nil </span><span class="cov6" title="4">{
                                        if s, ok := status.FromError(err); ok </span><span class="cov6" title="4">{
                                                redirectStatus = testutils.GRPCCodeToStatusCode(s.Code())
                                        }</span> else<span class="cov0" title="0"> {
                                                redirectStatus = testutils.StatusInternalError
                                        }</span>
                                } else<span class="cov1" title="1"> {
                                        redirectStatus = testutils.StatusTemporaryRedirect
                                }</span>

                                // Проверки
                                <span class="cov6" title="5">if redirectStatus == testutils.StatusNotFound </span><span class="cov6" title="4">{
                                        if len(tt.shouldBeMarked) &gt; 0 </span><span class="cov4" title="3">{
                                                assert.Contains(t, tt.shouldBeMarked, code)
                                        }</span>
                                } else<span class="cov1" title="1"> {
                                        assert.NotContains(t, tt.shouldBeMarked, code)
                                }</span>
                        }

                })
        }
}

func prepareTestURLs(serv *service.Service) (map[string]string, map[string]string) <span class="cov4" title="3">{

        user1 := "bf38c714-b8df-4f75-8578-ea6b5df32758"
        user2 := "93f3b6be-3f1c-452a-9cf9-475e160a3cb1"

        // Исходные данные
        user1Data := map[string]string{
                "url1": "https://example.com/1",
                "url2": "https://example.com/2",
                "url3": "https://example.com/3",
                "url4": "https://example.com/4",
        }
        user2Data := map[string]string{
                "url5": "https://example.com/5",
        }

        user1Shorts := map[string]string{}
        user2Shorts := map[string]string{}

        // Заполняем хранилище
        for key, original := range user1Data </span><span class="cov10" title="12">{
                ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, user1)
                shortKey, err := serv.GetShortKey(ctx, original)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to shorten URL %s: %v", original, err))</span>
                }
                <span class="cov10" title="12">user1Shorts[key] = shortKey</span>
        }

        <span class="cov4" title="3">for key, original := range user2Data </span><span class="cov4" title="3">{
                ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, user2)
                shortKey, err := serv.GetShortKey(ctx, original)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to shorten URL %s: %v", original, err))</span>
                }
                <span class="cov4" title="3">user2Shorts[key] = shortKey</span>
        }

        <span class="cov4" title="3">return user1Shorts, user2Shorts</span>

}
</pre>
		
		<pre class="file" id="file50" style="display: none">package testhandlers

import (
        "context"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/stretchr/testify/assert"
        "google.golang.org/grpc/status"
)

func TestRedirectGRPC(t *testing.T, repo service.Repository, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        const (
                shortKey    = "EYm7J2zF"
                originalURL = "https://practicum.yandex.ru/"
        )

        mapping := models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }

        cookie, userID := testutils.CreateSignedCookie()
        ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, userID)
        repo.SaveURL(ctx, &amp;mapping)

        tests := CommonRedirectTestCases(shortKey, originalURL)

        for _, tt := range tests </span><span class="cov10" title="2">{
                t.Run("gRPC_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="2">{

                        token := cookie.Value
                        ctx := testutils.ContextWithJWT(context.Background(), token)

                        resp, err := grpcClient.GetOriginalURL(ctx, &amp;pb.GetRequest{ShortUrl: tt.ShortKey})

                        var redirectStatus testutils.StatusCode
                        if err != nil </span><span class="cov1" title="1">{
                                if s, ok := status.FromError(err); ok </span><span class="cov1" title="1">{
                                        redirectStatus = testutils.GRPCCodeToStatusCode(s.Code())
                                }</span> else<span class="cov0" title="0"> {
                                        redirectStatus = testutils.StatusInternalError
                                }</span>
                        } else<span class="cov1" title="1"> {
                                redirectStatus = testutils.StatusTemporaryRedirect
                        }</span>

                        // Проверяем статус ответа
                        <span class="cov10" title="2">assert.Equal(t, tt.ExpectedStatus, redirectStatus)
                        if tt.ExpectedStatus == testutils.StatusTemporaryRedirect </span><span class="cov1" title="1">{
                                assert.NoError(t, err)
                                assert.Equal(t, tt.ExpectedURL, resp.OriginalUrl)
                        }</span> else<span class="cov1" title="1"> {
                                assert.Error(t, err)
                        }</span>

                })
        }
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package testhandlers

import (
        "context"
        "errors"
        "net/http"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"

        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestRedirect тестирует обработчик редиректа по короткой ссылке (GET /{id}).
//
// Проверяет следующие сценарии:
//   - Успешный редирект на оригинальный URL (StatusTemporaryRedirect)
//   - Обработку несуществующего короткого URL (StatusNotFound)
//   - Корректность заголовка Location при редиректе
//   - Работу JWT авторизации через cookie
//   - Обработку gzip сжатия через middleware
//
// Тест создает:
//   - Тестовое хранилище с предзаполненным URL
//   - HTTP-сервер с middleware:
//   - Логирование запросов
//   - Поддержка gzip
//   - JWT авторизация
//   - Специальную политику обработки редиректов для resty
//
// Примеры тест-кейсов:
//   - Запрос существующего URL (ожидается 307 с правильным Location)
//   - Запрос несуществующего URL (ожидается 404)
//
// Особенности:
//   - Использует кастомную политику редиректов для проверки Location
//   - Сохраняет тестовые данные перед выполнением тестов
//   - Проверяет как положительные, так и отрицательные сценарии
func TestRedirect(t *testing.T, repo service.Repository, client *resty.Client) <span class="cov5" title="2">{

        const (
                shortKey    = "EYm7J2zF"
                originalURL = "https://practicum.yandex.ru/"
        )

        mapping := models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }

        var redirectAttemptedError = errors.New("redirect")
        redirectPolicy := resty.RedirectPolicyFunc(func(req *http.Request, via []*http.Request) error </span><span class="cov5" title="2">{
                // return nil for continue redirect otherwise return error to stop/prevent redirect
                return redirectAttemptedError
        }</span>)

        <span class="cov5" title="2">cookie, userID := testutils.CreateSignedCookie()
        ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, userID)
        repo.SaveURL(ctx, &amp;mapping)

        tests := CommonRedirectTestCases(shortKey, originalURL)

        for _, tt := range tests </span><span class="cov10" title="4">{
                t.Run("HTTP_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="4">{

                        client.SetRedirectPolicy(redirectPolicy)
                        req := client.R().SetCookie(cookie)
                        req.Method = http.MethodGet
                        req.URL = "/" + tt.ShortKey

                        resp, err := req.Send()

                        if errors.Is(err, redirectAttemptedError) </span><span class="cov5" title="2">{
                                // эту ошибку игнорируем
                                err = nil
                        }</span>

                        <span class="cov10" title="4">assert.NoError(t, err)

                        // Проверяем статус ответа
                        assert.Equal(t, tt.ExpectedStatus, testutils.HTTPStatusToStatusCode(resp.StatusCode()))
                        if tt.ExpectedStatus == testutils.StatusTemporaryRedirect </span><span class="cov5" title="2">{
                                assert.Equal(t, tt.ExpectedURL, resp.Header().Get("Location"))
                        }</span>
                })
        }

}
</pre>
		
		<pre class="file" id="file52" style="display: none">package testhandlers

import (
        "bytes"
        "compress/gzip"
        "encoding/json"
        "net/http"
        "net/url"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/handlers/http/shortenapi"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestShortenAPI тестирует JSON API обработчик сокращения URL (POST /api/shorten).
//
// Проверяет следующие сценарии:
//   - Успешное создание короткой ссылки (StatusCreated)
//   - Попытку повторного сокращения того же URL (StatusConflict)
//   - Обработку некорректного URL (StatusBadRequest)
//   - Корректность формата JSON ответа
//   - Работу JWT авторизации через cookie
//   - Поддержку gzip сжатия запросов и ответов
//
// Тест создает:
//   - Тестовый HTTP сервер с middleware:
//   - Логирование запросов
//   - Поддержка gzip
//   - JWT авторизация
//   - Набор тестовых случаев с разными входными данными
//
// Примеры тест-кейсов:
//   - Корректный URL (ожидается 201 Created с валидным коротким URL)
//   - Дублирующийся URL (ожидается 409 Conflict)
//   - Некорректный URL (ожидается 400 Bad Request)
//
// Особенности:
//   - Проверяет валидность возвращаемого короткого URL
//   - Использует gzip сжатие для запросов
//   - Поддерживает авторизацию через JWT cookie
func TestShortenAPI(t *testing.T, client *resty.Client) <span class="cov1" title="1">{

        cookie, _ := testutils.CreateSignedCookie()
        tests := []struct {
                cookie         *http.Cookie
                name           string
                request        shortenapi.Request
                wantStatusCode int
        }{
                {
                        name:           "positive test #1",
                        request:        shortenapi.Request{URL: "https://practicum.yandex.ru/"},
                        cookie:         cookie,
                        wantStatusCode: 201,
                },
                {
                        name:           "positive test #2",
                        request:        shortenapi.Request{URL: "https://practicum.yandex.ru/"},
                        cookie:         cookie,
                        wantStatusCode: 409,
                },
                {
                        name:           "negative test #2",
                        request:        shortenapi.Request{URL: "not url"},
                        cookie:         cookie,
                        wantStatusCode: 400,
                },
        }

        for _, tt := range tests </span><span class="cov10" title="3">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov10" title="3">{

                        req, err := json.Marshal(tt.request)
                        assert.NoError(t, err)

                        buf := bytes.NewBuffer(nil)
                        zb := gzip.NewWriter(buf)
                        _, err = zb.Write([]byte(req))
                        assert.NoError(t, err)
                        err = zb.Close()
                        assert.NoError(t, err)

                        resp, err := client.R().
                                SetCookie(tt.cookie).
                                SetBody(buf).
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                Post("/api/shorten")

                        assert.NoError(t, err)

                        // Проверяем статус ответа
                        assert.Equal(t, tt.wantStatusCode, resp.StatusCode())
                        if tt.wantStatusCode == 201 </span><span class="cov1" title="1">{
                                var response shortenapi.Response
                                err = json.Unmarshal(resp.Body(), &amp;response)
                                assert.NoError(t, err)
                                shortURL := response.Result
                                // Проверяем, что получен URL
                                _, err = url.Parse(shortURL)
                                assert.NoError(t, err)
                        }</span>
                })
        }

}
</pre>
		
		<pre class="file" id="file53" style="display: none">package testhandlers

import (
        "context"
        "net/url"
        "testing"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/stretchr/testify/assert"
        "google.golang.org/grpc/status"
)

func TestShortenURLGRPC(t *testing.T, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        for _, tt := range CommonShortenURLTestCases() </span><span class="cov10" title="3">{
                t.Run("gRPC_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="3">{

                        token := tt.Cookie.Value
                        ctx := testutils.ContextWithJWT(context.Background(), token)

                        resp, err := grpcClient.CreateShortURL(ctx, &amp;pb.CreateRequest{OriginalUrl: tt.OriginalURL})
                        var shortenResult ShortenResult
                        if resp != nil </span><span class="cov1" title="1">{
                                shortenResult.ShortURL = resp.ShortUrl
                                shortenResult.Status = testutils.StatusCreated
                        }</span>

                        <span class="cov10" title="3">if err != nil </span><span class="cov6" title="2">{
                                if s, ok := status.FromError(err); ok </span><span class="cov6" title="2">{
                                        shortenResult.Status = testutils.GRPCCodeToStatusCode(s.Code())
                                }</span> else<span class="cov0" title="0"> {
                                        shortenResult.Status = testutils.StatusInternalError
                                }</span>
                        }

                        <span class="cov10" title="3">assert.Equal(t, tt.Want, shortenResult.Status)

                        if tt.Want == testutils.StatusCreated </span><span class="cov1" title="1">{
                                assert.NoError(t, err)
                                assert.NotNil(t, resp)
                                _, err = url.Parse(shortenResult.ShortURL)
                                assert.NoError(t, err)
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package testhandlers

import (
        "net/url"
        "testing"

        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestShortenURL тестирует текстовый обработчик сокращения URL (POST /).
//
// Принимает:
//
//        t *testing.T - инстанс тестинга
//        client *resty.Client - предварительно настроенный HTTP клиент (с базовым URL)
//
// Проверяет следующие сценарии:
//   - Успешное создание короткой ссылки (StatusCreated)
//   - Попытку повторного сокращения того же URL (StatusConflict)
//   - Обработку некорректного URL (StatusBadRequest)
//   - Корректность возвращаемого текстового ответа
//   - Работу JWT авторизации через cookie
//   - Поддержку gzip сжатия через middleware
//
// Тест создает:
//   - Тестовый HTTP сервер с middleware:
//   - Логирование запросов
//   - Поддержка gzip
//   - JWT авторизация
//   - Набор тестовых случаев с разными входными данными
//
// Примеры тест-кейсов:
//   - Корректный URL (ожидается 201 Created с валидным коротким URL в теле ответа)
//   - Дублирующийся URL (ожидается 409 Conflict)
//   - Некорректный URL (ожидается 400 Bad Request)
//
// Особенности:
//   - Проверяет валидность возвращаемого короткого URL
//   - Работает с текстовым форматом запроса/ответа (в отличие от JSON API)
//   - Поддерживает авторизацию через JWT cookie

func TestShortenURL(t *testing.T, httpClient *resty.Client) <span class="cov4" title="2">{

        for _, tt := range CommonShortenURLTestCases() </span><span class="cov10" title="6">{
                t.Run("HTTP_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="6">{

                        resp, err := httpClient.R().
                                SetCookie(tt.Cookie).
                                SetBody(tt.OriginalURL).
                                Post("/")

                        assert.NoError(t, err)

                        var shortenResult ShortenResult

                        shortenResult.ShortURL = string(resp.Body())
                        shortenResult.Status = testutils.HTTPStatusToStatusCode(resp.StatusCode())

                        // Проверяем статус ответа
                        assert.Equal(t, tt.Want, shortenResult.Status)
                        if tt.Want == testutils.StatusCreated </span><span class="cov4" title="2">{
                                shortURL := shortenResult.ShortURL
                                // Проверяем, что получен URL
                                _, err = url.Parse(string(shortURL))
                                assert.NoError(t, err)
                        }</span>

                })
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package testhandlers

import (
        "context"
        "encoding/json"
        "net/http"
        "testing"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/models"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestUserUrls тестирует обработчик получения списка URL пользователя (GET /api/user/urls).
//
// Проверяет следующие сценарии:
//   - Успешное получение списка URL авторизованного пользователя (StatusOK)
//   - Пустой результат для нового пользователя (StatusNoContent)
//   - Ошибку авторизации при отсутствии cookie (StatusUnauthorized)
//   - Корректность формата JSON ответа
//   - Автоматическую выдачу новой cookie при неавторизованном доступе
//   - Работу JWT авторизации через StrictJWTAutoIssue middleware
//
// Тест создает:
//   - Тестовое хранилище с URL для двух пользователей
//   - HTTP-сервер с middleware:
//   - Логирование запросов
//   - Поддержка gzip
//   - Строгая JWT авторизация с автоматической выдачей
//   - Набор тестовых случаев с разными условиями авторизации
//
// Примеры тест-кейсов:
//   - Авторизованный пользователь с URL (ожидается 200 OK с корректным списком)
//   - Новый пользователь без URL (ожидается 204 NoContent)
//   - Запрос без авторизации (ожидается 401 Unauthorized с новой cookie)
//
// Особенности:
//   - Проверяет строгую авторизацию через StrictJWTAutoIssue
//   - Тестирует автоматическую выдачу cookie при неавторизованном доступе
//   - Поддерживает проверку структуры JSON ответа
func TestUserUrls(t *testing.T, serv *service.Service, client *resty.Client) <span class="cov3" title="2">{

        // Тестовые данные
        cookie1, user1 := testutils.CreateSignedCookie()
        _, user2 := testutils.CreateSignedCookie()

        testURLs := []models.UserURLMapping{
                {UserID: user1, OriginalURL: "https://example.com/1"},
                {UserID: user1, OriginalURL: "https://example.com/2"},
                {UserID: user2, OriginalURL: "https://example.com/3"},
        }

        prepareTestUserURLs(serv, testURLs)

        t.Run("Успешное получение ссылок пользователя", func(t *testing.T) </span><span class="cov3" title="2">{

                // Запрос
                resp, err := client.R().
                        SetCookie(cookie1).
                        Get("/api/user/urls")

                // Проверки
                assert.NoError(t, err)
                assert.Equal(t, http.StatusOK, resp.StatusCode())

                var urls []models.URLMapping
                err = json.Unmarshal(resp.Body(), &amp;urls)
                assert.NoError(t, err)
                assert.Len(t, urls, 2) // user1 имеет 2 ссылки

        }</span>)
        <span class="cov3" title="2">t.Run("Пустой результат для нового пользователя", func(t *testing.T) </span><span class="cov3" title="2">{
                cookie, _ := testutils.CreateSignedCookie()

                resp, err := client.R().
                        SetCookie(cookie).
                        Get("/api/user/urls")

                assert.NoError(t, err)
                assert.Equal(t, http.StatusNoContent, resp.StatusCode())

        }</span>)

        <span class="cov3" title="2">t.Run("Ошибка без куки", func(t *testing.T) </span><span class="cov3" title="2">{
                resp, err := client.R().
                        Get("/api/user/urls")

                assert.NoError(t, err)
                assert.Equal(t, http.StatusUnauthorized, resp.StatusCode())

                // Проверяем что установлена новая кука
                assert.NotEmpty(t, resp.Cookies())
        }</span>)

}

func TestUserUrlsGRPC(t *testing.T, serv *service.Service, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        // Тестовые данные
        cookie1, user1 := testutils.CreateSignedCookie()
        _, user2 := testutils.CreateSignedCookie()

        testURLs := []models.UserURLMapping{
                {UserID: user1, OriginalURL: "https://example.com/1"},
                {UserID: user1, OriginalURL: "https://example.com/2"},
                {UserID: user2, OriginalURL: "https://example.com/3"},
        }

        prepareTestUserURLs(serv, testURLs)

        t.Run("Успешное получение ссылок пользователя", func(t *testing.T) </span><span class="cov1" title="1">{

                // Запрос
                token := cookie1.Value
                ctx := testutils.ContextWithJWT(context.Background(), token)

                resp, err := grpcClient.GetUserURLs(ctx, &amp;pb.UserURLsRequest{})

                // Проверки
                assert.NoError(t, err)

                statusGetUserURLs := testutils.StatusOK
                if len(resp.Urls) == 0 </span><span class="cov0" title="0">{
                        statusGetUserURLs = testutils.StatusNoContent
                }</span>

                <span class="cov1" title="1">var urls []models.URLMapping
                if statusGetUserURLs == testutils.StatusOK </span><span class="cov1" title="1">{
                        for _, u := range resp.Urls </span><span class="cov3" title="2">{
                                urls = append(urls, models.URLMapping{
                                        ShortURL:    u.ShortUrl,
                                        OriginalURL: u.OriginalUrl,
                                })
                        }</span>
                }

                <span class="cov1" title="1">assert.Equal(t, testutils.StatusOK, statusGetUserURLs)

                assert.Len(t, urls, 2)</span> // user1 имеет 2 ссылки

        })
        <span class="cov1" title="1">t.Run("Пустой результат для нового пользователя", func(t *testing.T) </span><span class="cov1" title="1">{

                cookie, _ := testutils.CreateSignedCookie()
                ctx := testutils.ContextWithJWT(context.Background(), cookie.Value)

                resp, err := grpcClient.GetUserURLs(ctx, &amp;pb.UserURLsRequest{})

                assert.NoError(t, err)
                statusGetUserURLs := testutils.StatusOK
                if len(resp.Urls) == 0 </span><span class="cov1" title="1">{
                        statusGetUserURLs = testutils.StatusNoContent
                }</span>

                <span class="cov1" title="1">assert.Equal(t, testutils.StatusNoContent, statusGetUserURLs)</span>

        })
}

func prepareTestUserURLs(serv *service.Service, testURLs []models.UserURLMapping) <span class="cov5" title="3">{

        for _, url := range testURLs </span><span class="cov10" title="9">{
                ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, url.UserID)
                _, err := serv.GetShortKey(ctx, url.OriginalURL)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                // url.ShortURL = shortURL
        }

}
</pre>
		
		<pre class="file" id="file56" style="display: none">package testutils

import (
        "context"
        "fmt"
        "net/http"

        "github.com/golang-jwt/jwt/v5"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// TestSecretKey содержит тестовый ключ для подписи JWT.
// Используется только в тестовой среде.
var TestSecretKey = []byte("test-secret-key")

// CreateSignedCookie создает тестовую HTTP-куку с подписанным JWT-токеном.
// Используется для симуляции аутентифицированных запросов в тестах.
func CreateSignedCookie() (*http.Cookie, string) <span class="cov10" title="17">{
        tokenString, userID, err := jwtauth.GenerateNewToken(TestSecretKey)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // В тестах допустим panic
        }

        <span class="cov10" title="17">return &amp;http.Cookie{
                Name:     "token",
                Value:    tokenString,
                HttpOnly: true,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
        }, userID</span>
}

// CreateJWTToken создает тестовый JWT токен
func CreateCookieByUserID(userID string) (*http.Cookie, error) <span class="cov6" title="6">{
        tokenString, err := jwtauth.CreateToken(TestSecretKey, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="6">return &amp;http.Cookie{
                Name:     "token",
                Value:    tokenString,
                HttpOnly: true,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
        }, nil</span>
}

// ContextWithJWT добавляет JWT токен в контекст gRPC
func ContextWithJWT(ctx context.Context, token string) context.Context <span class="cov8" title="11">{
        md := metadata.New(map[string]string{
                "token": token,
        })
        return metadata.NewOutgoingContext(ctx, md)
}</span>

// ParseUserIDFromContext извлекает userID из контекста
func ParseUserIDFromContext(ctx context.Context) (string, error) <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return "", status.Error(codes.Unauthenticated, "metadata not provided")
        }</span>

        <span class="cov0" title="0">tokens := md.Get("token")
        if len(tokens) == 0 </span><span class="cov0" title="0">{
                return "", status.Error(codes.Unauthenticated, "authorization token not provided")
        }</span>

        <span class="cov0" title="0">claims := &amp;jwtauth.Claims{}

        token, err := jwt.ParseWithClaims(tokens[0], claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                }</span>
                <span class="cov0" title="0">return TestSecretKey, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", status.Error(codes.Unauthenticated, "invalid token")
        }</span>

        <span class="cov0" title="0">userID := claims.UserID

        if userID != "" &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return userID, nil
        }</span>

        <span class="cov0" title="0">return "", status.Error(codes.Unauthenticated, "invalid token claims")</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package testutils

import (
        "net/http/httptest"

        "github.com/go-chi/chi/v5"
        "github.com/go-resty/resty/v2"
)

// TestClient представляет тестовый HTTP клиент с ассоциированным сервером.
// Используется для тестирования HTTP обработчиков с полным жизненным циклом.
//
// Поля:
//
//        Client *resty.Client - предварительно настроенный HTTP клиент
//        Server *httptest.Server - тестовый HTTP сервер
type TestClient struct {
        Client *resty.Client
        Server *httptest.Server
}

// NewTestClient создает новое тестовое окружение для HTTP тестов.
//
// Параметры:
//
//        handlers ...func(r chi.Router) - обработчики для настройки роутера.
//          Каждая функция получает возможность зарегистрировать свои эндпоинты.
//          Можно передавать несколько обработчиков - они будут применены по порядку.
//
// Возвращает:
//
//        *TestClient - готовый к использованию тестовый клиент с сервером.
//
// Примеры:
//
//  1. Простое создание:
//     tc := NewTestClient(
//     func(r chi.Router) {
//     r.Get("/ping", PingHandler)
//     },
//     )
//     defer tc.Close()
//
//  2. С middleware:
//     tc := NewTestClient(
//     func(r chi.Router) {
//     r.Use(LoggerMiddleware)
//     r.Post("/data", DataHandler)
//     },
//     )
func NewTestClient(handlers ...func(r chi.Router)) *TestClient <span class="cov10" title="8">{
        r := chi.NewRouter()
        for _, h := range handlers </span><span class="cov10" title="8">{
                h(r)
        }</span>
        <span class="cov10" title="8">srv := httptest.NewServer(r)

        return &amp;TestClient{
                Client: resty.New().SetBaseURL(srv.URL),
                Server: srv,
        }</span>
}

// Close освобождает ресурсы тестового клиента.
// Должен вызываться при завершении работы (обычно через defer).
//
// Выполняет:
//   - Остановку тестового сервера
//   - Закрытие всех idle-соединений клиента
func (tc *TestClient) Close() <span class="cov9" title="7">{
        tc.Server.Close()
        tc.Client.GetClient().CloseIdleConnections()
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package testutils

import (
        "context"
        "fmt"
        "net"
        "time"

        pb "github.com/ryabkov82/shortener/api"

        "google.golang.org/grpc"
        "google.golang.org/grpc/connectivity"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/test/bufconn"
)

// TestGRPCClient представляет тестовый gRPC клиент с ассоциированным сервером.
type TestGRPCClient struct {
        Conn   *grpc.ClientConn
        Server *grpc.Server
        Lis    *bufconn.Listener
}

// NewTestGRPCClient создает новое тестовое окружение для gRPC тестов.
//
// Параметры:
//   - interceptors: список gRPC интерцепторов
//   - service: реализация gRPC сервера
//
// Возвращает:
//   - *TestGRPCClient - готовый к использованию тестовый клиент с сервером
func NewTestGRPCClient(
        interceptors []grpc.UnaryServerInterceptor,
        service pb.ShortenerServer,
) *TestGRPCClient <span class="cov7" title="10">{

        // Создаем виртуальное соединение
        lis := bufconn.Listen(1024 * 1024)

        srv := grpc.NewServer(
                grpc.ChainUnaryInterceptor(interceptors...),
        )

        // Регистрируем сервисы
        pb.RegisterShortenerServer(srv, service)

        // Канал для ожидания запуска сервера
        serverErr := make(chan error, 1) // Буферизированный канал
        ready := make(chan struct{})

        go func() </span><span class="cov7" title="10">{
                close(ready) // Сообщаем, что вот-вот будет вызван Serve
                if err := srv.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        serverErr &lt;- err
                }</span>
                <span class="cov7" title="10">close(serverErr)</span>
        }()

        <span class="cov7" title="10">&lt;-ready // Дождались запуска горутины

        // Создаем dial функцию для bufconn
        dialer := func(ctx context.Context, addr string) (net.Conn, error) </span><span class="cov7" title="10">{
                return lis.DialContext(ctx)
        }</span>

        <span class="cov7" title="10">conn, err := grpc.NewClient(
                "passthrough:///inmem",
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithContextDialer(dialer),
        )

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // 1. Явно инициируем соединение
        <span class="cov7" title="10">conn.Connect()

        // 2. Проверяем соединение с таймаутом
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // 3. Механизм проверки готовности соединения
        connectionReady := make(chan struct{})
        go func() </span><span class="cov7" title="10">{
                for </span><span class="cov10" title="20">{
                        state := conn.GetState()
                        if state == connectivity.Ready </span><span class="cov7" title="10">{
                                close(connectionReady)
                                return
                        }</span>

                        // Ждем изменения состояния
                        <span class="cov7" title="10">if !conn.WaitForStateChange(ctx, state) </span><span class="cov0" title="0">{
                                return // Таймаут или отмена контекста
                        }</span>
                }
        }()

        // Ждем либо готовности, либо таймаута
        <span class="cov7" title="10">select </span>{
        case &lt;-connectionReady:<span class="cov7" title="10">
                // Соединение готово к работе
                fmt.Println("Connection established successfully")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                panic("connection timeout exceeded: server not responding")</span>
        }

        <span class="cov7" title="10">return &amp;TestGRPCClient{
                Conn:   conn,
                Lis:    lis,
                Server: srv,
        }</span>
}

// Close освобождает ресурсы тестового клиента.
func (tc *TestGRPCClient) Close() <span class="cov7" title="10">{
        tc.Conn.Close()
        tc.Server.Stop()
        tc.Lis.Close()
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package testutils

import (
        "os"
        "path/filepath"

        storage "github.com/ryabkov82/shortener/internal/app/storage/inmemory"
)

// InitializeInMemoryStorage создает и инициализирует хранилище в памяти для тестов.
//
// Функция выполняет:
//   - Поиск глобальной директории с тестовыми данными проекта
//   - Удаление предыдущего файла хранилища (если существует)
//   - Создание нового in-memory хранилища
//   - Загрузку данных из файла (если файл существует)
//
// Возвращает:
//   - *storage.InMemoryStorage: инициализированное хранилище
//   - error: ошибка, если возникла при создании хранилища
//
// Особенности:
//   - Использует глобальную тестовую директорию проекта
//   - Автоматически очищает предыдущее состояние хранилища
//   - Поддерживает загрузку данных из файла
//
// Пример использования:
//
//        st, err := InitializeInMemoryStorage()
//        if err != nil {
//            log.Fatalf("Failed to initialize storage: %v", err)
//        }
//        defer st.Close()
func InitializeInMemoryStorage() (*storage.InMemoryStorage, error) <span class="cov10" title="11">{

        // Для общих testdata проекта
        globalData, err := GetGlobalTestDataPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="11">fileStorage := filepath.Join(globalData, "test.dat")

        _ = os.Remove(fileStorage)

        st, err := storage.NewInMemoryStorage(fileStorage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //st.Load(fileStorage)

        <span class="cov10" title="11">return st, nil</span>

}
</pre>
		
		<pre class="file" id="file60" style="display: none">package testutils

import (
        "os/exec"
        "path/filepath"
        "strings"
)

// GetModuleRoot возвращает абсолютный путь к корневой директории Go-модуля.
// Использует команду 'go list -m'. Может возвращать ошибку, если команда
// не выполнена или модуль не инициализирован.
func GetModuleRoot() (string, error) <span class="cov10" title="11">{
        out, err := exec.Command("go", "list", "-m", "-f", "{{.Dir}}").Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="11">return strings.TrimSpace(string(out)), nil</span>
}

// GetGlobalTestDataPath возвращает путь к общей папке testdata проекта
func GetGlobalTestDataPath() (string, error) <span class="cov10" title="11">{
        root, err := GetModuleRoot()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="11">return filepath.Join(root, "test", "testdata"), nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package testutils

import (
        "net/http"

        "google.golang.org/grpc/codes"
)

// StatusCode — универсальный enum статусов для тестов.
type StatusCode int

const (
        StatusOK StatusCode = iota
        StatusCreated
        StatusBadRequest
        StatusUnauthorized
        StatusForbidden
        StatusNotFound
        StatusConflict
        StatusTemporaryRedirect
        StatusAccepted
        StatusNoContent
        StatusServiceUnavailable
        StatusGatewayTimeout
        StatusInternalError
        StatusUnknown
)

// grpcCodeToStatusCode преобразует grpc коды в StatusCode
func GRPCCodeToStatusCode(code codes.Code) StatusCode <span class="cov6" title="7">{
        switch code </span>{
        case codes.OK:<span class="cov0" title="0">
                return StatusCreated</span>
        case codes.InvalidArgument:<span class="cov1" title="1">
                return StatusBadRequest</span>
        case codes.NotFound:<span class="cov5" title="5">
                return StatusNotFound</span>
        case codes.AlreadyExists:<span class="cov1" title="1">
                return StatusConflict</span>
        case codes.PermissionDenied:<span class="cov0" title="0">
                return StatusForbidden</span>
        case codes.Unauthenticated:<span class="cov0" title="0">
                return StatusUnauthorized</span>
        case codes.Unavailable:<span class="cov0" title="0">
                return StatusServiceUnavailable</span>
        case codes.DeadlineExceeded:<span class="cov0" title="0">
                return StatusGatewayTimeout</span>
        case codes.Internal:<span class="cov0" title="0">
                return StatusInternalError</span>
        default:<span class="cov0" title="0">
                return StatusUnknown</span>
        }
}

// httpStatusToStatusCode преобразует HTTP статус в StatusCode
func HTTPStatusToStatusCode(code int) StatusCode <span class="cov10" title="24">{
        switch code </span>{
        case http.StatusOK:<span class="cov0" title="0">
                return StatusOK</span>
        case http.StatusCreated:<span class="cov5" title="5">
                return StatusCreated</span>
        case http.StatusBadRequest:<span class="cov5" title="5">
                return StatusBadRequest</span>
        case http.StatusUnauthorized:<span class="cov0" title="0">
                return StatusUnauthorized</span>
        case http.StatusForbidden:<span class="cov0" title="0">
                return StatusForbidden</span>
        case http.StatusNotFound:<span class="cov2" title="2">
                return StatusNotFound</span>
        case http.StatusConflict:<span class="cov2" title="2">
                return StatusConflict</span>
        case http.StatusServiceUnavailable:<span class="cov0" title="0">
                return StatusServiceUnavailable</span>
        case http.StatusGatewayTimeout:<span class="cov0" title="0">
                return StatusGatewayTimeout</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                return StatusInternalError</span>
        case http.StatusTemporaryRedirect:<span class="cov2" title="2">
                return StatusTemporaryRedirect</span>
        case http.StatusAccepted:<span class="cov6" title="8">
                return StatusAccepted</span>
        case http.StatusNoContent:<span class="cov0" title="0">
                return StatusNoContent</span>
        default:<span class="cov0" title="0">
                return StatusUnknown</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
