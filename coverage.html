
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ryabkov82/shortener/cmd/client/main.go (0.0%)</option>
				
				<option value="file1">github.com/ryabkov82/shortener/cmd/shortener/main.go (0.0%)</option>
				
				<option value="file2">github.com/ryabkov82/shortener/cmd/staticlint/main.go (0.0%)</option>
				
				<option value="file3">github.com/ryabkov82/shortener/cmd/staticlint/noosexit/analyzer.go (0.0%)</option>
				
				<option value="file4">github.com/ryabkov82/shortener/internal/app/config/config.go (0.0%)</option>
				
				<option value="file5">github.com/ryabkov82/shortener/internal/app/handlers/batch/batch.go (71.4%)</option>
				
				<option value="file6">github.com/ryabkov82/shortener/internal/app/handlers/deluserurls/deluserurls.go (54.5%)</option>
				
				<option value="file7">github.com/ryabkov82/shortener/internal/app/handlers/ping/ping.go (100.0%)</option>
				
				<option value="file8">github.com/ryabkov82/shortener/internal/app/handlers/redirect/redirect.go (61.1%)</option>
				
				<option value="file9">github.com/ryabkov82/shortener/internal/app/handlers/shortenapi/shortenapi.go (66.7%)</option>
				
				<option value="file10">github.com/ryabkov82/shortener/internal/app/handlers/shorturl/shorturl.go (67.7%)</option>
				
				<option value="file11">github.com/ryabkov82/shortener/internal/app/handlers/userurls/userurls.go (76.5%)</option>
				
				<option value="file12">github.com/ryabkov82/shortener/internal/app/httpgzip/httpgzip.go (92.6%)</option>
				
				<option value="file13">github.com/ryabkov82/shortener/internal/app/jwtauth/jwtauth.go (100.0%)</option>
				
				<option value="file14">github.com/ryabkov82/shortener/internal/app/logger/logger.go (80.0%)</option>
				
				<option value="file15">github.com/ryabkov82/shortener/internal/app/pprof/routes.go (0.0%)</option>
				
				<option value="file16">github.com/ryabkov82/shortener/internal/app/server/middleware/auth/auth.go (77.4%)</option>
				
				<option value="file17">github.com/ryabkov82/shortener/internal/app/server/middleware/logger/logger.go (100.0%)</option>
				
				<option value="file18">github.com/ryabkov82/shortener/internal/app/server/middleware/mwgzip/mwgzip.go (89.5%)</option>
				
				<option value="file19">github.com/ryabkov82/shortener/internal/app/server/server.go (0.0%)</option>
				
				<option value="file20">github.com/ryabkov82/shortener/internal/app/service/mocks/Repository.go (41.1%)</option>
				
				<option value="file21">github.com/ryabkov82/shortener/internal/app/service/service.go (87.2%)</option>
				
				<option value="file22">github.com/ryabkov82/shortener/internal/app/storage/inmemory/inmemory.go (82.7%)</option>
				
				<option value="file23">github.com/ryabkov82/shortener/internal/app/storage/postgres/migrate.go (66.7%)</option>
				
				<option value="file24">github.com/ryabkov82/shortener/internal/app/storage/postgres/postgres.go (68.9%)</option>
				
				<option value="file25">github.com/ryabkov82/shortener/internal/app/workers/deleteurls/deleteworker.go (63.1%)</option>
				
				<option value="file26">github.com/ryabkov82/shortener/test/testconfig/postgres.go (75.0%)</option>
				
				<option value="file27">github.com/ryabkov82/shortener/test/testutils/auth.go (75.0%)</option>
				
				<option value="file28">github.com/ryabkov82/shortener/test/testutils/handlers/batch_tests.go (96.4%)</option>
				
				<option value="file29">github.com/ryabkov82/shortener/test/testutils/handlers/deluserurls_tests.go (95.2%)</option>
				
				<option value="file30">github.com/ryabkov82/shortener/test/testutils/handlers/redirect_tests.go (96.9%)</option>
				
				<option value="file31">github.com/ryabkov82/shortener/test/testutils/handlers/shortenapi_tests.go (97.0%)</option>
				
				<option value="file32">github.com/ryabkov82/shortener/test/testutils/handlers/shorturl_tests.go (95.5%)</option>
				
				<option value="file33">github.com/ryabkov82/shortener/test/testutils/handlers/userurls_tests.go (94.7%)</option>
				
				<option value="file34">github.com/ryabkov82/shortener/test/testutils/inmemory.go (80.0%)</option>
				
				<option value="file35">github.com/ryabkov82/shortener/test/testutils/paths.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "strings"
)

func main() <span class="cov0" title="0">{
        endpoint := "http://localhost:8080/"
        // контейнер данных для запроса
        data := url.Values{}
        // приглашение в консоли
        fmt.Println("Введите длинный URL")
        // открываем потоковое чтение из консоли
        reader := bufio.NewReader(os.Stdin)
        // читаем строку из консоли
        long, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">long = strings.TrimSuffix(long, "\n")
        long = strings.TrimSuffix(long, "\r")
        // заполняем контейнер данными
        data.Set("url", long)
        // добавляем HTTP-клиент
        client := &amp;http.Client{}
        // пишем запрос
        // запрос методом POST должен, помимо заголовков, содержать тело
        // тело должно быть источником потокового чтения io.Reader
        request, err := http.NewRequest(http.MethodPost, endpoint, strings.NewReader(long))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // в заголовках запроса указываем кодировку
        // request.Header.Add("Content-Type", "application/x-www-form-urlencoded")
        // отправляем запрос и получаем ответ
        <span class="cov0" title="0">response, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // выводим код ответа
        <span class="cov0" title="0">fmt.Println("Статус-код ", response.Status)
        defer response.Body.Close()
        // читаем поток из тела ответа
        body, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // и печатаем его
        <span class="cov0" title="0">fmt.Println(string(body))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Пакет main предоставляет точку входа для сервиса сокращения URL.
//
// Основные функции:
//
//   - Инициализация конфигурации системы
//   - Настройка логгера
//   - Запуск HTTP сервера
package main

import (
        "fmt"
        "os"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/logger"
        "github.com/ryabkov82/shortener/internal/app/server"
)

var (
        buildVersion string
        buildDate    string
        buildCommit  string
)

func main() <span class="cov0" title="0">{

        printBuildInfo()

        cfg := config.Load()

        if err := logger.Initialize(cfg.LogLevel); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Запуск сервера с использованием конфигурации
        <span class="cov0" title="0">logger.Log.Info("Starting server", zap.String("address", cfg.HTTPServerAddr), zap.String("BaseURL", cfg.BaseURL))
        // log.Printf("Starting server on %s with base URL %s", cfg.HTTPServerAddr, cfg.BaseURL)
        server.StartServer(logger.Log, cfg)</span>

}

func printBuildInfo() <span class="cov0" title="0">{
        // Set default value "N/A" if variables are empty
        if buildVersion == "" </span><span class="cov0" title="0">{
                buildVersion = "N/A"
        }</span>
        <span class="cov0" title="0">if buildDate == "" </span><span class="cov0" title="0">{
                buildDate = "N/A"
        }</span>
        <span class="cov0" title="0">if buildCommit == "" </span><span class="cov0" title="0">{
                buildCommit = "N/A"
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(os.Stdout, "Build version: %s\n", buildVersion)
        fmt.Fprintf(os.Stdout, "Build date: %s\n", buildDate)
        fmt.Fprintf(os.Stdout, "Build commit: %s\n", buildCommit)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package staticlint представляет собой комплексный статический анализатор для проекта Shortener.
// Он объединяет:
// - стандартные анализаторы go/analysis
// - анализаторы staticcheck
// - дополнительные сторонние анализаторы
//
// Для запуска:
//
//        go run cmd/staticlint/main.go ./...
//
// Для установки и использования как standalone-инструмента:
//
//        go install github.com/ryabkov82/shortener/cmd/staticlint
//        staticlint ./...
package main

import (
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/asmdecl"
        "golang.org/x/tools/go/analysis/passes/assign"
        "golang.org/x/tools/go/analysis/passes/atomic"
        "golang.org/x/tools/go/analysis/passes/bools"
        "golang.org/x/tools/go/analysis/passes/buildtag"
        "golang.org/x/tools/go/analysis/passes/cgocall"
        "golang.org/x/tools/go/analysis/passes/composite"
        "golang.org/x/tools/go/analysis/passes/copylock"
        "golang.org/x/tools/go/analysis/passes/deepequalerrors"
        "golang.org/x/tools/go/analysis/passes/errorsas"
        "golang.org/x/tools/go/analysis/passes/fieldalignment"
        "golang.org/x/tools/go/analysis/passes/httpresponse"
        "golang.org/x/tools/go/analysis/passes/ifaceassert"
        "golang.org/x/tools/go/analysis/passes/loopclosure"
        "golang.org/x/tools/go/analysis/passes/lostcancel"
        "golang.org/x/tools/go/analysis/passes/nilfunc"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/shift"
        "golang.org/x/tools/go/analysis/passes/sigchanyzer"
        "golang.org/x/tools/go/analysis/passes/stdmethods"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "golang.org/x/tools/go/analysis/passes/testinggoroutine"
        "golang.org/x/tools/go/analysis/passes/unmarshal"
        "golang.org/x/tools/go/analysis/passes/unreachable"
        "golang.org/x/tools/go/analysis/passes/unsafeptr"
        "golang.org/x/tools/go/analysis/passes/unusedresult"

        "honnef.co/go/tools/quickfix"
        "honnef.co/go/tools/simple"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck"

        "github.com/go-critic/go-critic/checkers/analyzer"
        "github.com/timakin/bodyclose/passes/bodyclose"

        "github.com/ryabkov82/shortener/cmd/staticlint/noosexit"
)

func main() <span class="cov0" title="0">{
        // Стандартные анализаторы из golang.org/x/tools/go/analysis/passes
        standardAnalyzers := []*analysis.Analyzer{
                asmdecl.Analyzer,          // проверяет корректность объявлений ассемблерного кода
                assign.Analyzer,           // обнаруживает бесполезные присваивания
                atomic.Analyzer,           // проверяет правильность использования sync/atomic
                bools.Analyzer,            // обнаруживает распространенные ошибки с булевыми операторами
                buildtag.Analyzer,         // проверяет корректность build тегов
                cgocall.Analyzer,          // проверяет корректность вызовов CGO
                composite.Analyzer,        // проверяет композитные литералы без ключей
                copylock.Analyzer,         // проверяет копирование мьютексов
                deepequalerrors.Analyzer,  // проверяет использование deep equal с ошибками
                errorsas.Analyzer,         // проверяет правильность использования errors.As
                fieldalignment.Analyzer,   // предлагает оптимальное выравнивание полей структур
                httpresponse.Analyzer,     // проверяет закрытие HTTP response bodies
                ifaceassert.Analyzer,      // обнаруживает бессмысленные type assertions
                loopclosure.Analyzer,      // проверяет захват переменных в замыканиях
                lostcancel.Analyzer,       // проверяет утечку контекста
                nilfunc.Analyzer,          // обнаруживает сравнения функций с nil
                printf.Analyzer,           // проверяет формат строки в Printf-функциях
                shadow.Analyzer,           // обнаруживает затенение переменных
                shift.Analyzer,            // проверяет сдвиги превышающие размер типа
                sigchanyzer.Analyzer,      // проверяет неправильное использование каналов в signal.Notify
                stdmethods.Analyzer,       // проверяет соответствие стандартным интерфейсам
                structtag.Analyzer,        // проверяет корректность тегов структур
                testinggoroutine.Analyzer, // обнаруживает утечку горутин в тестах
                unmarshal.Analyzer,        // проверяет правильность передачи указателей в Unmarshal
                unreachable.Analyzer,      // обнаруживает недостижимый код
                unsafeptr.Analyzer,        // проверяет корректность преобразований unsafe.Pointer
                unusedresult.Analyzer,     // проверяет неиспользованные результаты функций
        }

        // Анализаторы класса SA из staticcheck.io (Static Analysis)
        var saAnalyzers []*analysis.Analyzer
        for _, v := range staticcheck.Analyzers </span><span class="cov0" title="0">{
                if v.Analyzer.Name[:2] == "SA" </span><span class="cov0" title="0">{
                        saAnalyzers = append(saAnalyzers, v.Analyzer)
                }</span>
        }

        // Дополнительные анализаторы из других классов staticcheck
        <span class="cov0" title="0">var otherStaticcheckAnalyzers []*analysis.Analyzer

        // Добавляем анализаторы из stylecheck
        for _, a := range stylecheck.Analyzers </span><span class="cov0" title="0">{
                if a.Analyzer.Name == "ST1000" </span><span class="cov0" title="0">{ // проверка документации пакета
                        otherStaticcheckAnalyzers = append(otherStaticcheckAnalyzers, a.Analyzer)
                        break</span>
                }
        }

        // Добавляем анализаторы из simple
        <span class="cov0" title="0">for _, a := range simple.Analyzers </span><span class="cov0" title="0">{
                if a.Analyzer.Name == "S1002" </span><span class="cov0" title="0">{ // предлагает упрощение булевых выражений
                        otherStaticcheckAnalyzers = append(otherStaticcheckAnalyzers, a.Analyzer)
                        break</span>
                }
        }

        // Добавляем анализаторы из quickfix
        <span class="cov0" title="0">for _, a := range quickfix.Analyzers </span><span class="cov0" title="0">{
                if a.Analyzer.Name == "QF1001" </span><span class="cov0" title="0">{ // применяет законы Де Моргана
                        otherStaticcheckAnalyzers = append(otherStaticcheckAnalyzers, a.Analyzer)
                        break</span>
                }
        }

        // Сторонние анализаторы
        <span class="cov0" title="0">externalAnalyzers := []*analysis.Analyzer{
                bodyclose.Analyzer, // проверяет закрытие response.Body
                analyzer.Analyzer,  // go-critic, выявляет потенциальные ошибки, неэффективности и плохие практики программирования
        }

        // Собственные анализаторы
        customAnalyzers := []*analysis.Analyzer{
                noosexit.NoOsExitAnalyzer,
        }

        // Объединяем все анализаторы
        var analyzers []*analysis.Analyzer
        analyzers = append(analyzers, standardAnalyzers...)
        analyzers = append(analyzers, saAnalyzers...)
        analyzers = append(analyzers, otherStaticcheckAnalyzers...)
        analyzers = append(analyzers, externalAnalyzers...)
        analyzers = append(analyzers, customAnalyzers...)

        multichecker.Main(analyzers...)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package noosexit проверяет отсутствие прямых вызовов os.Exit в функции main пакета main
package noosexit

import (
        "go/ast"
        "path/filepath"
        "strings"

        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/ast/inspector"
)

const doc = `noosexit проверяет отсутствие прямых вызовов os.Exit в функции main пакета main

Анализатор запрещает использование os.Exit() в функции main() основного пакета,
рекомендуя вместо этого возвращать ошибки или использовать log.Fatal().`

// NoOsExitAnalyzer анализатор для проверки вызовов os.Exit
var NoOsExitAnalyzer = &amp;analysis.Analyzer{
        Name:     "noosexit",
        Doc:      doc,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
        Run:      run,
}

func run(pass *analysis.Pass) (interface{}, error) <span class="cov0" title="0">{

        // Проверяем, что пакет находится в директории cmd
        if !isCmdPackage(pass.Pkg.Path()) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Используем inspector для более эффективного обхода AST
        <span class="cov0" title="0">inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

        // Фильтруем только вызовы функций
        nodeFilter := []ast.Node{
                (*ast.CallExpr)(nil),
        }

        // Проверяем, находимся ли мы в пакете main и функции main
        inspect.Preorder(nodeFilter, func(n ast.Node) </span><span class="cov0" title="0">{
                call := n.(*ast.CallExpr)
                fun, ok := call.Fun.(*ast.SelectorExpr)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                // Проверяем что это вызов os.Exit
                <span class="cov0" title="0">if ident, ok := fun.X.(*ast.Ident); ok </span><span class="cov0" title="0">{
                        if ident.Name == "os" &amp;&amp; fun.Sel.Name == "Exit" </span><span class="cov0" title="0">{
                                // Проверяем что находимся в функции main пакета main
                                if pass.Pkg.Name() == "main" </span><span class="cov0" title="0">{
                                        // Проверяем что находимся внутри функции main
                                        for _, f := range pass.Files </span><span class="cov0" title="0">{
                                                for _, decl := range f.Decls </span><span class="cov0" title="0">{
                                                        if fd, ok := decl.(*ast.FuncDecl); ok &amp;&amp; fd.Name.Name == "main" </span><span class="cov0" title="0">{
                                                                pass.Reportf(call.Pos(), "прямой вызов os.Exit в функции main запрещен, используйте log.Fatal() или возврат ошибки")
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        })

        <span class="cov0" title="0">return nil, nil</span>
}

// isCmdPackage проверяет, находится ли пакет в директории cmd
func isCmdPackage(pkgPath string) bool <span class="cov0" title="0">{
        return strings.Contains(filepath.ToSlash(pkgPath), "/cmd/")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package config предоставляет загрузку и валидацию конфигурации приложения.
//
// Поддерживает несколько источников конфигурации:
// - Аргументы командной строки
// - Переменные окружения
// - Значения по умолчанию
//
// Приоритет настроек:
// 1. Переменные окружения
// 2. Аргументы командной строки
// 3. Значения по умолчанию
package config

import (
        "errors"
        "flag"
        "log"
        "net/url"
        "os"
        "strconv"
        "strings"
)

// Config содержит все параметры конфигурации приложения.
type Config struct {
        HTTPServerAddr string      // Адрес HTTP-сервера в формате host:port
        BaseURL        string      // Базовый URL для сокращённых ссылок
        LogLevel       string      // Уровень логирования (debug, info, warn, error)
        FileStorage    string      // Путь к файлу хранилища
        DBConnect      string      // Строка подключения к БД
        JwtKey         string      // Секретный ключ для JWT
        ConfigPProf    PProfConfig // Настройки pprof
}

// PProfConfig содержит настройки профилирования pprof.
type PProfConfig struct {
        AuthUser string
        AuthPass string
        Endpoint string
        BindAddr string
        Enabled  bool
}

// validateHTTPServerAddr проверяет корректность адреса сервера.
//
// Формат адреса: host:port
// Где port должен быть числом от 1 до 65535
//
// Возвращает:
//
//        error - ошибка валидации или nil
func validateHTTPServerAddr(addr string) error <span class="cov0" title="0">{
        hp := strings.Split(addr, ":")
        if len(hp) != 2 </span><span class="cov0" title="0">{
                return errors.New("address must be in host:port format")
        }</span>

        <span class="cov0" title="0">port, err := strconv.Atoi(hp[1])
        if err != nil || port &lt; 1 || port &gt; 65535 </span><span class="cov0" title="0">{
                return errors.New("port must be a number between 1 and 65535")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateBaseURL проверяет корректность базового URL.
//
// URL должен быть:
// - Абсолютным (содержать схему)
// - Валидным согласно net/url.Parse
//
// Возвращает:
//
//        error - ошибка валидации или nil
func validateBaseURL(baseURL string) error <span class="cov0" title="0">{
        u, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if u.Scheme == "" || u.Host == "" </span><span class="cov0" title="0">{
                return errors.New("URL must be absolute with scheme and host")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Load загружает конфигурацию из разных источников.
//
// Порядок загрузки:
// 1. Устанавливает значения по умолчанию
// 2. Читает аргументы командной строки
// 3. Перезаписывает переменными окружения
//
// Возвращает:
//
//        *Config - загруженную конфигурацию
func Load() *Config <span class="cov0" title="0">{
        cfg := &amp;Config{
                HTTPServerAddr: "localhost:8080",
                BaseURL:        "http://localhost:8080",
                LogLevel:       "info",
                FileStorage:    "storage.dat",
                JwtKey:         "your_strong_secret_here",
                ConfigPProf: PProfConfig{
                        Enabled:  true,
                        AuthUser: "admin",
                        AuthPass: "admin",
                        Endpoint: "/debug/pprof",
                        BindAddr: ":6060",
                },
        }

        // Загрузка из аргументов командной строки
        flag.Func("a", "Server address in host:port format", func(flagValue string) error </span><span class="cov0" title="0">{
                if err := validateHTTPServerAddr(flagValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cfg.HTTPServerAddr = flagValue
                return nil</span>
        })

        <span class="cov0" title="0">flag.Func("b", "Base URL for shortened links (e.g. http://example.com)", func(flagValue string) error </span><span class="cov0" title="0">{
                if err := validateBaseURL(flagValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cfg.BaseURL = strings.TrimSuffix(flagValue, "/")
                return nil</span>
        })

        <span class="cov0" title="0">flag.StringVar(&amp;cfg.LogLevel, "l", cfg.LogLevel, "Log level (debug, info, warn, error)")
        flag.StringVar(&amp;cfg.FileStorage, "f", cfg.FileStorage, "Path to file storage")
        flag.StringVar(&amp;cfg.DBConnect, "d", cfg.DBConnect, "Database connection string")
        flag.Parse()

        // Переопределение переменными окружения
        loadFromEnv(cfg)

        // Дополнительная обработка
        cfg.BaseURL = strings.TrimSuffix(cfg.BaseURL, "/")

        return cfg</span>
}

// loadFromEnv загружает значения из переменных окружения.
func loadFromEnv(cfg *Config) <span class="cov0" title="0">{
        if envAddr := os.Getenv("SERVER_ADDRESS"); envAddr != "" </span><span class="cov0" title="0">{
                if err := validateHTTPServerAddr(envAddr); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("invalid SERVER_ADDRESS: %v", err)
                }</span>
                <span class="cov0" title="0">cfg.HTTPServerAddr = envAddr</span>
        }

        <span class="cov0" title="0">if envURL := os.Getenv("BASE_URL"); envURL != "" </span><span class="cov0" title="0">{
                if err := validateBaseURL(envURL); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("invalid BASE_URL: %v", err)
                }</span>
                <span class="cov0" title="0">cfg.BaseURL = envURL</span>
        }

        <span class="cov0" title="0">if envFile := os.Getenv("FILE_STORAGE_PATH"); envFile != "" </span><span class="cov0" title="0">{
                cfg.FileStorage = envFile
        }</span>

        <span class="cov0" title="0">if envDB := os.Getenv("DATABASE_DSN"); envDB != "" </span><span class="cov0" title="0">{
                cfg.DBConnect = envDB
        }</span>

        <span class="cov0" title="0">if envJWT := os.Getenv("JWT_SECRET"); envJWT != "" </span><span class="cov0" title="0">{
                if len(envJWT) &lt; 32 </span><span class="cov0" title="0">{
                        log.Fatal("JWT_SECRET must be at least 32 characters long")
                }</span>
                <span class="cov0" title="0">cfg.JwtKey = envJWT</span>
        }

        // Обработка pprof настроек
        <span class="cov0" title="0">if user := os.Getenv("PPROF_USER"); user != "" </span><span class="cov0" title="0">{
                cfg.ConfigPProf.AuthUser = user
        }</span>
        <span class="cov0" title="0">if pass := os.Getenv("PPROF_PASS"); pass != "" </span><span class="cov0" title="0">{
                cfg.ConfigPProf.AuthPass = pass
        }</span>
        <span class="cov0" title="0">if enabled := os.Getenv("PPROF_ENABLED"); enabled != "" </span><span class="cov0" title="0">{
                if v, err := strconv.ParseBool(enabled); err == nil </span><span class="cov0" title="0">{
                        cfg.ConfigPProf.Enabled = v
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package batch предоставляет обработчик для пакетного создания сокращённых URL.
//
// Пакет реализует:
// - Приём массива URL в JSON-формате
// - Параллельную обработку запросов
// - Возврат результатов в коррелируемом формате
package batch

import (
        "context"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/models"
)

// URLHandler определяет контракт для обработки пакетных запросов.
type URLHandler interface {
        // Batch обрабатывает массив запросов на сокращение URL.
        //
        // Параметры:
        //   ctx - контекст выполнения
        //   requests - массив запросов
        //   baseURL - базовый URL для генерации коротких ссылок
        //
        // Возвращает:
        //   []models.BatchResponse - массив результатов
        //   error - ошибка выполнения
        Batch(ctx context.Context, requests []models.BatchRequest, baseURL string) ([]models.BatchResponse, error)
}

// GetHandler создаёт HTTP-обработчик для пакетного создания URL.
//
// Спецификация API:
//
//        Метод: POST
//        Content-Type: application/json
//        Путь: /api/shorten/batch
//
// Формат запроса:
//
//        [
//          {
//            "correlation_id": "уникальный_идентификатор",
//            "original_url": "https://example.com"
//          },
//          ...
//        ]
//
// Формат ответа:
//
//        [
//          {
//            "correlation_id": "уникальный_идентификатор",
//            "short_url": "http://short.ly/abc"
//          },
//          ...
//        ]
//
// Коды ответа:
//   - 201 Created - успешная обработка
//   - 400 Bad Request - невалидный JSON
//   - 500 Internal Server Error - внутренняя ошибка сервера
//
// Параметры:
//
//        urlHandler - сервис для обработки URL
//        baseURL - базовый адрес для коротких ссылок
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov5" title="2">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="4">{
                // Декодируем тело запроса
                var requestData []models.BatchRequest
                decoder := json.NewDecoder(req.Body)
                err := decoder.Decode(&amp;requestData)
                if err != nil </span><span class="cov5" title="2">{
                        http.Error(res, "Failed to read request body", http.StatusBadRequest)
                        log.Error("Failed to read request body", zap.Error(err))
                        return
                }</span>

                <span class="cov5" title="2">responseData, err := urlHandler.Batch(req.Context(), requestData, baseURL)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to proccessing request data", http.StatusBadRequest)
                        log.Error("Failed to proccessing request data", zap.Error(err))
                        return
                }</span>

                <span class="cov5" title="2">res.Header().Set("content-type", "application/json")
                // устанавливаем код 201
                res.WriteHeader(http.StatusCreated)
                // пишем тело ответа
                resp, err := json.Marshal(responseData)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        log.Error("Failed to encode response data", zap.Error(err))
                        return
                }</span>
                <span class="cov5" title="2">res.Write(resp)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package deluserurls предоставляет обработчик для массового удаления URL пользователя.
//
// Пакет реализует:
// - Приём списка URL для удаления в JSON-формате
// - Асинхронное удаление URL
// - Подтверждение принятия запроса
package deluserurls

import (
        "context"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"
)

// URLHandler определяет контракт для обработки удаления URL.
type URLHandler interface {
        // DeleteUserUrls удаляет указанные URL, принадлежащие пользователю.
        //
        // Параметры:
        //   ctx - контекст выполнения
        //   urls - список коротких URL для удаления (только идентификаторы)
        //
        // Возвращает:
        //   error - ошибка выполнения (не влияет на HTTP-статус ответа)
        DeleteUserUrls(ctx context.Context, urls []string) error
}

// GetHandler создаёт HTTP-обработчик для массового удаления URL пользователя.
//
// Спецификация API:
//
//        Метод: DELETE
//        Content-Type: application/json
//        Путь: /api/user/urls
//
// Формат запроса:
//
//        ["url1", "url2", ...]
//
// Формат ответа:
//
//        Тело ответа пустое
//
// Коды ответа:
//   - 202 Accepted - запрос принят в обработку
//   - 400 Bad Request - невалидный JSON
//   - 401 Unauthorized - пользователь не аутентифицирован
//   - 500 Internal Server Error - внутренняя ошибка сервера
//
// Особенности:
//   - Удаление происходит асинхронно
//   - Ответ 202 не гарантирует успешного удаления
//   - Для аутентификации используется JWT-токен в Cookie
//
// Параметры:
//
//        urlHandler - сервис для обработки URL
//        baseURL - базовый адрес сервиса (не используется в текущей реализации)
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="4">{
                var shortURLs []string
                if err := json.NewDecoder(req.Body).Decode(&amp;shortURLs); err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Invalid request body", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov10" title="4">err := urlHandler.DeleteUserUrls(req.Context(), shortURLs)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to delete user urls", http.StatusBadRequest)
                        log.Error("Failed to delete user urls", zap.Error(err))
                        return
                }</span>

                <span class="cov10" title="4">res.WriteHeader(http.StatusAccepted)</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package ping предоставляет обработчик для проверки доступности базы данных.
//
// Пакет реализует:
// - Проверку соединения с базой данных
// - Возврат статуса доступности сервиса
// - Логирование результатов проверки
package ping

import (
        "context"
        "net/http"

        "go.uber.org/zap"
)

// URLHandler определяет контракт для проверки соединения с БД.
type URLHandler interface {
        // Ping проверяет соединение с базой данных.
        //
        // Параметры:
        //   ctx - контекст выполнения с таймаутом
        //
        // Возвращает:
        //   error - ошибка соединения или nil при успехе
        Ping(ctx context.Context) error
}

// GetHandler создаёт HTTP-обработчик для проверки доступности БД.
//
// Спецификация API:
//
//        Метод: GET
//        Путь: /ping
//
// Формат ответа:
//   - При успехе: текст "Connect to database is successful"
//   - При ошибке: текст ошибки
//
// Коды ответа:
//   - 200 OK - соединение с БД установлено
//   - 500 Internal Server Error - ошибка соединения с БД
//   - 503 Service Unavailable - сервис недоступен (может добавляться в будущих версиях)
//
// Параметры:
//
//        urlHandler - сервис для проверки соединения
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="2">{
                err := urlHandler.Ping(req.Context())
                if err != nil </span><span class="cov1" title="1">{
                        http.Error(res, "Failed to connect to database", http.StatusInternalServerError)
                        log.Error("Failed to connect to database",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov1" title="1">log.Debug("Database connection check successful",
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                res.WriteHeader(http.StatusOK)
                res.Write([]byte("Connect to database is successful"))</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package redirect предоставляет обработчик для перенаправления по коротким URL.
//
// Пакет реализует:
// - Поиск оригинального URL по короткому идентификатору
// - Обработку различных статусов URL (активен, удален, не найден)
// - Логирование всех операций перенаправления
package redirect

import (
        "context"
        "errors"
        "net/http"

        "go.uber.org/zap"

        "github.com/go-chi/chi/v5"

        "github.com/ryabkov82/shortener/internal/app/storage"
)

// URLHandler определяет контракт для получения оригинального URL.
type URLHandler interface {
        // GetRedirectURL возвращает оригинальный URL для перенаправления.
        //
        // Параметры:
        //   ctx - контекст выполнения
        //   id - короткий идентификатор URL
        //
        // Возвращает:
        //   string - оригинальный URL
        //   error - возможные ошибки:
        //     - storage.ErrURLNotFound: URL не существует
        //     - storage.ErrURLDeleted: URL был удален
        //     - другие внутренние ошибки
        GetRedirectURL(ctx context.Context, id string) (string, error)
}

// GetHandler создаёт HTTP-обработчик для перенаправления по коротким URL.
//
// Спецификация API:
//
//        Метод: GET
//        Путь: /{id}
//
// Параметры пути:
//
//        id - короткий идентификатор URL (a-z, A-Z, 0-9)
//
// Ответы:
//   - 307 Temporary Redirect: успешное перенаправление (с Location header)
//   - 404 Not Found: короткий URL не существует
//   - 410 Gone: URL был удален
//   - 500 Internal Server Error: внутренняя ошибка сервера
//
// Особенности:
//   - Все запросы логируются с указанием shortKey
//   - Для удаленных URL возвращается специальный статус 410
//   - Поддерживается контекст для отмены операций
//
// Параметры:
//
//        urlHandler - сервис для получения URL
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="2">{
                id := chi.URLParam(req, "id")

                // Получаем адрес перенаправления
                originalURL, err := urlHandler.GetRedirectURL(req.Context(), id)
                if err != nil </span><span class="cov1" title="1">{
                        if errors.Is(err, storage.ErrURLNotFound) </span><span class="cov1" title="1">{
                                http.Error(res, "Shortened key not found", http.StatusNotFound)
                                log.Info("Shortened key not found",
                                        zap.String("shortKey", id),
                                        zap.String("method", req.Method),
                                        zap.String("path", req.URL.Path))
                                return
                        }</span>
                        <span class="cov0" title="0">if errors.Is(err, storage.ErrURLDeleted) </span><span class="cov0" title="0">{
                                http.Error(res, "URL has been deleted", http.StatusGone)
                                log.Info("URL has been deleted",
                                        zap.String("shortKey", id),
                                        zap.String("method", req.Method),
                                        zap.String("path", req.URL.Path))
                                return
                        }</span>
                        <span class="cov0" title="0">http.Error(res, "failed get redirect URL", http.StatusInternalServerError)
                        log.Error("failed get redirect URL",
                                zap.Error(err),
                                zap.String("shortKey", id),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return</span>
                }

                <span class="cov1" title="1">log.Info("Shortened key found",
                        zap.String("shortKey", id),
                        zap.String("redirect", originalURL),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                // Устанавливаем заголовок ответа Location
                res.Header().Set("Location", originalURL)
                // устанавливаем код 307
                res.WriteHeader(http.StatusTemporaryRedirect)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package shortenapi предоставляет JSON API для создания сокращённых URL.
//
// Пакет реализует:
// - Приём оригинального URL в JSON-формате
// - Валидацию входящего URL
// - Генерацию короткого ключа
// - Возврат результата в стандартизированном JSON-формате
package shortenapi

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"
        "net/url"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/storage"
)

// URLHandler определяет контракт для генерации коротких URL.
type URLHandler interface {
        // GetShortKey возвращает короткий ключ для оригинального URL.
        //
        // Параметры:
        //   ctx - контекст выполнения
        //   originalURL - URL для сокращения (должен быть валидным)
        //
        // Возвращает:
        //   string - короткий ключ
        //   error - возможные ошибки:
        //     - storage.ErrURLExists: URL уже существует
        //     - другие внутренние ошибки
        GetShortKey(ctx context.Context, originalURL string) (string, error)
}

// Request представляет структуру входящего JSON-запроса.
type Request struct {
        URL string `json:"url"` // Оригинальный URL для сокращения
}

// Response представляет структуру исходящего JSON-ответа.
type Response struct {
        Result string `json:"result"` // Полный сокращённый URL
}

// GetHandler создаёт HTTP-обработчик для API сокращения URL.
//
// Спецификация API:
//
//        Метод: POST
//        Content-Type: application/json
//        Путь: /api/shorten
//
// Формат запроса:
//
//        {
//          "url": "https://example.com/very/long/url"
//        }
//
// Формат ответа:
//
//        {
//          "result": "http://short.ly/abc123"
//        }
//
// Коды ответа:
//   - 201 Created: URL успешно сокращён
//   - 400 Bad Request: невалидный запрос
//   - 409 Conflict: URL уже существует
//   - 500 Internal Server Error: внутренняя ошибка сервера
//
// Параметры:
//
//        urlHandler - сервис для генерации коротких ключей
//        baseURL - базовый адрес для построения полного короткого URL
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="3">{
                var request Request

                // Декодируем JSON-тело запроса
                if err := json.NewDecoder(req.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to read request body", http.StatusBadRequest)
                        log.Error("Failed to decode request body",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov10" title="3">originalURL := request.URL

                // Валидация обязательного поля URL
                if originalURL == "" </span><span class="cov0" title="0">{
                        http.Error(res, "URL parameter is missing", http.StatusBadRequest)
                        log.Error("Empty URL in request",
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Проверка валидности URL
                <span class="cov10" title="3">if _, err := url.ParseRequestURI(originalURL); err != nil </span><span class="cov1" title="1">{
                        http.Error(res, "Invalid URL format", http.StatusBadRequest)
                        log.Error("Invalid URL in request",
                                zap.String("url", originalURL),
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov6" title="2">log.Debug("Processing URL shortening",
                        zap.String("originalURL", originalURL),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                // Генерация короткого ключа
                shortKey, err := urlHandler.GetShortKey(req.Context(), originalURL)

                // Обработка ошибок
                if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to generate short URL", http.StatusInternalServerError)
                        log.Error("Short URL generation failed",
                                zap.Error(err),
                                zap.String("originalURL", originalURL),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Формирование ответа
                <span class="cov6" title="2">response := Response{
                        Result: baseURL + "/" + shortKey,
                }

                res.Header().Set("Content-Type", "application/json")

                // Установка соответствующего HTTP-статуса
                if errors.Is(err, storage.ErrURLExists) </span><span class="cov1" title="1">{
                        res.WriteHeader(http.StatusConflict)
                        log.Debug("URL already exists",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span> else<span class="cov1" title="1"> {
                        res.WriteHeader(http.StatusCreated)
                        log.Debug("URL successfully shortened",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span>

                // Кодирование и отправка ответа
                <span class="cov6" title="2">if err := json.NewEncoder(res).Encode(response); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to encode response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package shorturl предоставляет обработчик для создания сокращённых URL через текстовый интерфейс.
//
// Пакет реализует:
// - Приём оригинального URL в текстовом формате
// - Валидацию входящего URL
// - Генерацию короткого ключа
// - Возврат результата в текстовом формате
package shorturl

import (
        "context"
        "errors"
        "io"
        "net/http"
        "net/url"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/storage"
)

// URLHandler определяет контракт для генерации коротких URL.
type URLHandler interface {
        // GetShortKey возвращает короткий ключ для оригинального URL.
        //
        // Параметры:
        //   ctx - контекст выполнения (должен включать таймаут)
        //   originalURL - валидный URL для сокращения
        //
        // Возвращает:
        //   string - короткий ключ
        //   error - возможные ошибки:
        //     - storage.ErrURLExists: URL уже существует
        //     - другие внутренние ошибки
        GetShortKey(ctx context.Context, originalURL string) (string, error)
}

// GetHandler создаёт HTTP-обработчик для текстового интерфейса сокращения URL.
//
// Спецификация API:
//
//        Метод: POST
//        Content-Type: text/plain
//        Путь: /
//
// Формат запроса:
//
//        Текстовое тело с оригинальным URL (например: "https://example.com/long/url")
//
// Формат ответа:
//
//        Текстовое тело с сокращённым URL (например: "http://short.ly/abc123")
//
// Коды ответа:
//   - 201 Created: URL успешно сокращён
//   - 400 Bad Request: невалидный запрос
//   - 409 Conflict: URL уже существует
//   - 500 Internal Server Error: внутренняя ошибка сервера
//
// Параметры:
//
//        urlHandler - сервис для генерации коротких ключей
//        baseURL - базовый адрес для построения полного короткого URL
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="3">{
                // Чтение и валидация тела запроса
                // Использование io.LimitReader, минимизация аллокаций
                body, err := io.ReadAll(io.LimitReader(req.Body, 1&lt;&lt;20)) // Ограничение 1MB
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to read request body", http.StatusBadRequest)
                        log.Error("Failed to read request body",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>
                <span class="cov10" title="3">defer req.Body.Close()

                originalURL := string(body)
                if originalURL == "" </span><span class="cov0" title="0">{
                        http.Error(res, "URL parameter is missing", http.StatusBadRequest)
                        log.Error("Empty URL in request",
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Валидация URL
                <span class="cov10" title="3">if _, err = url.ParseRequestURI(originalURL); err != nil </span><span class="cov1" title="1">{
                        http.Error(res, "Invalid URL format", http.StatusBadRequest)
                        log.Error("Invalid URL in request",
                                zap.String("url", originalURL),
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov6" title="2">log.Debug("Processing URL shortening",
                        zap.String("originalURL", originalURL),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                // Генерация короткого ключа
                shortKey, err := urlHandler.GetShortKey(req.Context(), originalURL)
                if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to generate short URL", http.StatusInternalServerError)
                        log.Error("Short URL generation failed",
                                zap.Error(err),
                                zap.String("originalURL", originalURL),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Формирование ответа
                <span class="cov6" title="2">res.Header().Set("Content-Type", "text/plain; charset=utf-8")
                shortURL := baseURL + "/" + shortKey

                if errors.Is(err, storage.ErrURLExists) </span><span class="cov1" title="1">{
                        res.WriteHeader(http.StatusConflict)
                        log.Debug("URL already exists",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span> else<span class="cov1" title="1"> {
                        res.WriteHeader(http.StatusCreated)
                        log.Debug("URL successfully shortened",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span>

                <span class="cov6" title="2">if _, err := res.Write([]byte(shortURL)); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to write response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package userurls предоставляет обработчик для получения списка URL пользователя.
//
// Пакет реализует:
// - Получение всех сокращённых URL авторизованного пользователя
// - Возврат данных в JSON-формате
// - Обработку случая отсутствия URL
package userurls

import (
        "context"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/models"
)

// URLHandler определяет контракт для получения URL пользователя.
type URLHandler interface {
        // GetUserUrls возвращает все сокращённые URL пользователя.
        //
        // Параметры:
        //   ctx - контекст выполнения (должен содержать идентификатор пользователя)
        //   baseURL - базовый адрес для построения полных коротких URL
        //
        // Возвращает:
        //   []models.URLMapping - список сопоставлений оригинальных и коротких URL
        //   error - ошибка выполнения (например, проблемы с хранилищем)
        GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error)
}

// GetHandler создаёт HTTP-обработчик для получения URL пользователя.
//
// Спецификация API:
//
//        Метод: GET
//        Путь: /api/user/urls
//        Требуется: JWT-аутентификация
//
// Формат ответа:
//
//        [
//          {
//            "short_url": "http://short.ly/abc123",
//            "original_url": "https://example.com/long/url"
//          },
//          ...
//        ]
//
// Коды ответа:
//   - 200 OK: успешный запрос (возвращает список URL)
//   - 204 No Content: у пользователя нет сохранённых URL
//   - 400 Bad Request: ошибка аутентификации
//   - 500 Internal Server Error: внутренняя ошибка сервера
//
// Параметры:
//
//        urlHandler - сервис для получения URL
//        baseURL - базовый адрес сервиса
//        log - логгер для записи событий
//
// Возвращает:
//
//        http.HandlerFunc - HTTP-обработчик
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="2">{
                // Получение данных из хранилища
                responseData, err := urlHandler.GetUserUrls(req.Context(), baseURL)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to get user URLs", http.StatusInternalServerError)
                        log.Error("Failed to retrieve user URLs",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Обработка случая отсутствия URL
                <span class="cov10" title="2">if len(responseData) == 0 </span><span class="cov1" title="1">{
                        res.WriteHeader(http.StatusNoContent)
                        log.Debug("No URLs found for user",
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                // Формирование JSON-ответа
                <span class="cov1" title="1">res.Header().Set("Content-Type", "application/json")
                res.WriteHeader(http.StatusOK)

                encoder := json.NewEncoder(res)
                encoder.SetIndent("", "  ") // Форматирование JSON для читаемости
                if err := encoder.Encode(responseData); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to encode response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>

                <span class="cov1" title="1">log.Debug("Successfully returned user URLs",
                        zap.Int("count", len(responseData)),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package httpgzip предоставляет инструменты для сжатия и распаковки HTTP-трафика в формате gzip.
// Реализует пул объектов gzip.Writer и gzip.Reader для оптимизации производительности.
package httpgzip

import (
        "compress/gzip"
        "io"
        "net/http"
        "sync"
)

// Пул gzip.Writer для повторного использования объектов
var writerPool = sync.Pool{
        New: func() interface{} <span class="cov10" title="102">{
                return gzip.NewWriter(io.Discard)
        }</span>,
}

// Пул gzip.Reader для повторного использования объектов
var readerPool = sync.Pool{
        New: func() interface{} <span class="cov9" title="101">{
                return new(gzip.Reader)
        }</span>,
}

// init инициализирует пулы объектов предварительным заполнением.
//
// Опционально вызывается при старте приложения для уменьшения
// накладных расходов на создание объектов при первой нагрузке.
func init() <span class="cov5" title="9">{
        for i := 0; i &lt; 10; i++ </span><span class="cov9" title="90">{
                writerPool.Put(writerPool.New())
                readerPool.Put(readerPool.New())
        }</span>
}

// PutWriter возвращает gzip.Writer в пул для повторного использования.
//
// Параметры:
//   - zw: gzip.Writer для возврата в пул
func PutWriter(zw *gzip.Writer) <span class="cov8" title="48">{
        writerPool.Put(zw)
}</span>

// PutReader возвращает gzip.Reader в пул для повторного использования.
//
// Параметры:
//   - zr: gzip.Reader для возврата в пул
func PutReader(zr *gzip.Reader) <span class="cov6" title="20">{
        readerPool.Put(zr)
}</span>

// compressWriter реализует http.ResponseWriter с поддержкой gzip-сжатия.
type compressWriter struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

// NewCompressWriter создает новый compressWriter.
//
// Параметры:
//   - w: оригинальный http.ResponseWriter
//
// Возвращает:
//   - *compressWriter: обертку с поддержкой сжатия
func NewCompressWriter(w http.ResponseWriter) *compressWriter <span class="cov8" title="48">{
        zw := writerPool.Get().(*gzip.Writer)
        zw.Reset(w)
        return &amp;compressWriter{
                w:  w,
                zw: zw,
        }
}</span>

// Header возвращает HTTP-заголовки ответа.
func (c *compressWriter) Header() http.Header <span class="cov8" title="45">{
        return c.w.Header()
}</span>

// Write записывает сжатые данные в ответ.
func (c *compressWriter) Write(p []byte) (int, error) <span class="cov7" title="34">{
        c.w.Header().Del("Content-Length")
        return c.zw.Write(p)
}</span>

// WriteHeader устанавливает код статуса и заголовки ответа.
func (c *compressWriter) WriteHeader(statusCode int) <span class="cov8" title="48">{
        c.w.Header().Set("Content-Encoding", "gzip")
        c.w.WriteHeader(statusCode)
}</span>

// Close закрывает writer и возвращает его в пул.
func (c *compressWriter) Close() error <span class="cov8" title="48">{
        err := c.zw.Close()
        PutWriter(c.zw)
        return err
}</span>

// compressReader реализует io.ReadCloser с поддержкой gzip-распаковки.
type compressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

// NewCompressReader создает новый compressReader.
//
// Параметры:
//   - r: оригинальный io.ReadCloser
//
// Возвращает:
//   - *compressReader: обертку с поддержкой распаковки
//   - error: ошибка инициализации
func NewCompressReader(r io.ReadCloser) (*compressReader, error) <span class="cov6" title="20">{
        zr := readerPool.Get().(*gzip.Reader)
        if err := zr.Reset(r); err != nil </span><span class="cov0" title="0">{
                readerPool.Put(zr)
                return nil, err
        }</span>
        <span class="cov6" title="20">return &amp;compressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

// Read читает и распаковывает данные.
func (c compressReader) Read(p []byte) (n int, err error) <span class="cov6" title="20">{
        return c.zr.Read(p)
}</span>

// Close закрывает reader и возвращает его в пул.
func (c *compressReader) Close() error <span class="cov6" title="20">{
        err := c.r.Close()
        PutReader(c.zr)
        return err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package jwtauth предоставляет функционал для работы с JWT токенами аутентификации.
package jwtauth

import (
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// Claims представляет кастомные claims JWT токена.
// Содержит идентификатор пользователя и стандартные claims.
type Claims struct {
        UserID               string `json:"user_id"` // Уникальный идентификатор пользователя
        jwt.RegisteredClaims        // Стандартные claims JWT
}

// ContextKey тип для ключей контекста.
// Используется для безопасного доступа к значениям в context.Context.
type ContextKey string

// UserIDContextKey ключ для хранения ID пользователя в контексте.
const UserIDContextKey ContextKey = "userID"

// GenerateNewToken генерирует новый JWT токен для пользователя.
//
// Параметры:
//   - jwtKey: секретный ключ для подписи токена
//
// Возвращает:
//   - string: подписанный JWT токен
//   - string: сгенерированный ID пользователя
//   - error: ошибка генерации токена
//
// Пример использования:
//
//        token, userID, err := GenerateNewToken([]byte("secret"))
func GenerateNewToken(jwtKey []byte) (string, string, error) <span class="cov10" title="27">{
        userID := uuid.New().String() // Генерация уникального ID пользователя

        claims := &amp;Claims{
                UserID: userID,
                // При необходимости можно добавить время экспирации:
                // RegisteredClaims: jwt.RegisteredClaims{
                //     ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
                // },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString(jwtKey)
        return tokenString, userID, err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package logger предоставляет централизованную систему логирования для приложения
// на основе zap.Logger. Реализует паттерн синглтона для глобального доступа к логеру.
package logger

import (
        "go.uber.org/zap"
)

// Log - глобальный экземпляр логера, инициализированный no-op логером по умолчанию.
// No-op логер не производит никакого вывода и не аллоцирует ресурсы.
var Log *zap.Logger = zap.NewNop()

// Initialize настраивает глобальный логер с указанным уровнем логирования.
//
// Параметры:
//   - level: строка, определяющая уровень логирования (debug, info, warn, error, dpanic, panic, fatal)
//
// Возвращает:
//   - error: ошибка, если передан некорректный уровень логирования или возникла проблема при создании логера
//
// Пример использования:
//
//        err := logger.Initialize("debug")
//        if err != nil {
//            // обработка ошибки инициализации
//        }
//        logger.Log.Info("Логер успешно инициализирован")
func Initialize(level string) error <span class="cov10" title="14">{
        // Преобразование строкового уровня в zap.AtomicLevel
        lvl, err := zap.ParseAtomicLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Конфигурация логера в production-стиле (JSON-формат, stacktrace для ошибок)
        <span class="cov10" title="14">cfg := zap.NewProductionConfig()

        // Установка уровня логирования
        cfg.Level = lvl

        // Создание логера на основе конфигурации
        zl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Замена глобального логера
        <span class="cov10" title="14">Log = zl
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package pprof предоставляет HTTP-интерфейс для профилирования приложения
// с использованием стандартного пакета net/http/pprof.
package pprof

import (
        "net/http"
        "net/http/pprof"

        "go.uber.org/zap"

        "github.com/go-chi/chi/v5"

        "github.com/ryabkov82/shortener/internal/app/config"
)

// StartPProf запускает HTTP-сервер для профилирования приложения.
//
// Параметры:
//   - log: логер для записи ошибок
//   - config: конфигурация сервера профилирования
//   - Enabled: флаг включения сервера
//   - BindAddr: адрес для прослушивания (например, "localhost:6060")
//   - Endpoint: базовый URL для эндпоинтов (например, "/debug/pprof")
//   - AuthUser: логин для HTTP Basic Auth
//   - AuthPass: пароль для HTTP Basic Auth
//
// Пример использования:
//
//        cfg := config.PProfConfig{
//            Enabled:  true,
//            BindAddr: "localhost:6060",
//            Endpoint: "/debug/pprof",
//            AuthUser: "admin",
//            AuthPass: "secret",
//        }
//        pprof.StartPProf(logger.Log, cfg)
func StartPProf(log *zap.Logger, config config.PProfConfig) <span class="cov0" title="0">{
        if !config.Enabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">r := chi.NewRouter()

        // Регистрируем стандартные обработчики pprof
        r.Route(config.Endpoint, func(r chi.Router) </span><span class="cov0" title="0">{
                // Применяем аутентификацию ко всем под-роутам
                r.Use(basicAuthMiddleware(config.AuthUser, config.AuthPass))

                // Регистрируем стандартные обработчики pprof
                r.Get("/", http.HandlerFunc(pprof.Index))
                r.Get("/cmdline", http.HandlerFunc(pprof.Cmdline))
                r.Get("/profile", http.HandlerFunc(pprof.Profile))
                r.Get("/symbol", http.HandlerFunc(pprof.Symbol))
                r.Get("/trace", http.HandlerFunc(pprof.Trace))

                // Регистрируем обработчики профилей
                r.Handle("/goroutine", pprof.Handler("goroutine"))
                r.Handle("/heap", pprof.Handler("heap"))
                r.Handle("/allocs", pprof.Handler("allocs"))
                r.Handle("/threadcreate", pprof.Handler("threadcreate"))
                r.Handle("/block", pprof.Handler("block"))
                r.Handle("/mutex", pprof.Handler("mutex"))
        }</span>)

        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:    config.BindAddr,
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error("failed to serve pprof server", zap.Error(err))
                }</span>
        }()
}

// basicAuthMiddleware создает middleware для HTTP Basic Authentication.
//
// Параметры:
//   - expectedUser: ожидаемое имя пользователя
//   - expectedPass: ожидаемый пароль
//
// Возвращает:
//   - middleware функцию для chi.Router
func basicAuthMiddleware(expectedUser, expectedPass string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        user, password, ok := r.BasicAuth()

                        if !ok || user != expectedUser || password != expectedPass </span><span class="cov0" title="0">{
                                w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package auth предоставляет middleware для аутентификации через JWT.
package auth

import (
        "context"
        "fmt"
        "net/http"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ryabkov82/shortener/internal/app/jwtauth"
)

// JWTAutoIssue создает middleware для автоматической выдачи JWT токенов.
//
// Middleware проверяет наличие валидного JWT токена в cookies:
// - Если токен отсутствует или невалиден - выдает новый токен
// - Если токен валиден - извлекает userID и передает в контекст
//
// Параметры:
//
//        jwtKey - ключ для подписи JWT токенов
//
// Возвращает:
//
//        func(next http.Handler) http.Handler - middleware функцию
func JWTAutoIssue(jwtKey []byte) func(next http.Handler) http.Handler <span class="cov7" title="9">{
        return func(next http.Handler) http.Handler </span><span class="cov7" title="9">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov9" title="22">{
                        cookie, err := r.Cookie("token")
                        if err != nil || cookie == nil </span><span class="cov6" title="6">{
                                userID := issueNewToken(w, jwtKey)
                                ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, userID)
                                r = r.WithContext(ctx)
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov8" title="16">tokenStr := cookie.Value
                        claims := &amp;jwtauth.Claims{}

                        token, err := jwt.ParseWithClaims(tokenStr, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="16">{
                                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                                }</span>
                                <span class="cov8" title="16">return jwtKey, nil</span>
                        })

                        <span class="cov8" title="16">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                                userID := issueNewToken(w, jwtKey)
                                ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, userID)
                                r = r.WithContext(ctx)
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov8" title="16">ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, claims.UserID)
                        r = r.WithContext(ctx)
                        next.ServeHTTP(w, r)</span>
                }

                <span class="cov7" title="9">return http.HandlerFunc(fn)</span>
        }
}

// StrictJWTAutoIssue создает строгий middleware для проверки JWT токенов.
//
// В отличие от JWTAutoIssue:
// - Не выдает новый токен при отсутствии/невалидности текущего
// - Возвращает 401 Unauthorized при отсутствии валидного токена
//
// Параметры:
//
//        jwtKey - ключ для подписи JWT токенов
//
// Возвращает:
//
//        func(next http.Handler) http.Handler - middleware функцию
func StrictJWTAutoIssue(jwtKey []byte) func(next http.Handler) http.Handler <span class="cov4" title="4">{
        return func(next http.Handler) http.Handler </span><span class="cov4" title="4">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="24">{
                        cookie, err := r.Cookie("token")
                        if err != nil || cookie == nil </span><span class="cov2" title="2">{
                                _ = issueNewToken(w, jwtKey)
                                http.Error(w, "Status unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov9" title="22">tokenStr := cookie.Value
                        claims := &amp;jwtauth.Claims{}

                        token, err := jwt.ParseWithClaims(tokenStr, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov9" title="22">{
                                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                                }</span>
                                <span class="cov9" title="22">return jwtKey, nil</span>
                        })

                        <span class="cov9" title="22">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                                _ = issueNewToken(w, jwtKey)
                                http.Error(w, "Status unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov9" title="22">ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, claims.UserID)
                        r = r.WithContext(ctx)
                        next.ServeHTTP(w, r)</span>
                }

                <span class="cov4" title="4">return http.HandlerFunc(fn)</span>
        }
}

// issueNewToken генерирует и устанавливает новый JWT токен.
//
// Параметры:
//
//        w - http.ResponseWriter для установки cookie
//        jwtKey - ключ для подписи JWT
//
// Возвращает:
//
//        string - идентификатор пользователя (userID)
func issueNewToken(w http.ResponseWriter, jwtKey []byte) string <span class="cov6" title="8">{
        token, userID, err := jwtauth.GenerateNewToken(jwtKey)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate token", http.StatusInternalServerError)
                return ""
        }</span>
        <span class="cov6" title="8">setTokenCookie(w, token)
        return userID</span>
}

// setTokenCookie устанавливает JWT токен в cookie.
//
// Параметры:
//
//        w - http.ResponseWriter для установки cookie
//        token - JWT токен для сохранения
func setTokenCookie(w http.ResponseWriter, token string) <span class="cov6" title="8">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "token",
                Value:    token,
                HttpOnly: true,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
        })
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package logger предоставляет middleware для логирования HTTP-запросов.
package logger

import (
        "net/http"
        "time"

        "github.com/go-chi/chi/v5/middleware"
        "go.uber.org/zap"
)

// RequestLogging создает middleware для логирования HTTP-запросов.
//
// Middleware логирует:
// - HTTP-метод
// - Путь запроса
// - Статус ответа
// - Размер ответа в байтах
// - Время обработки запроса
//
// Параметры:
//
//        log - логгер zap для записи логов
//
// Возвращает:
//
//        func(next http.Handler) http.Handler - middleware функцию
func RequestLogging(log *zap.Logger) func(next http.Handler) http.Handler <span class="cov7" title="14">{
        return func(next http.Handler) http.Handler </span><span class="cov7" title="14">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="48">{
                        // Создаем обертку для ResponseWriter для получения метрик ответа
                        ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        // Фиксируем время начала обработки запроса
                        t1 := time.Now()

                        // Отложенное выполнение логирования после обработки запроса
                        defer func() </span><span class="cov10" title="48">{
                                log.Info("request completed",
                                        zap.String("method", r.Method),                  // HTTP-метод (GET, POST и т.д.)
                                        zap.String("path", r.URL.Path),                  // Путь запроса
                                        zap.Int("status", ww.Status()),                  // HTTP-статус ответа
                                        zap.Int("bytes", ww.BytesWritten()),             // Размер ответа в байтах
                                        zap.String("duration", time.Since(t1).String()), // Время обработки
                                )
                        }</span>()

                        // Передаем управление следующему обработчику
                        <span class="cov10" title="48">next.ServeHTTP(ww, r)</span>
                }

                <span class="cov7" title="14">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package mwgzip предоставляет middleware для сжатия и распаковки HTTP-трафика в формате gzip.
package mwgzip

import (
        "net/http"
        "strings"

        "github.com/ryabkov82/shortener/internal/app/httpgzip"
)

// Gzip создает middleware для обработки gzip сжатия HTTP-запросов и ответов.
//
// Middleware выполняет:
// - Сжатие ответов в gzip, если клиент поддерживает прием сжатых данных
// - Распаковку входящих запросов, если они сжаты gzip
// - Прозрачную передачу данных, если gzip не используется
//
// Возвращает:
//
//        func(next http.Handler) http.Handler - middleware функцию
func Gzip(next http.Handler) http.Handler <span class="cov7" title="14">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="48">{
                // Используем оригинальный ResponseWriter по умолчанию
                ow := w

                // Проверяем поддержку gzip на стороне клиента
                acceptEncoding := r.Header.Get("Accept-Encoding")
                supportsGzip := strings.Contains(acceptEncoding, "gzip")
                if supportsGzip </span><span class="cov10" title="48">{
                        // Создаем обертку с поддержкой сжатия
                        cw := httpgzip.NewCompressWriter(w)
                        ow = cw
                        // Гарантируем закрытие компрессора
                        defer cw.Close()
                }</span>

                // Проверяем сжатие входящего запроса
                <span class="cov10" title="48">contentEncoding := r.Header.Get("Content-Encoding")
                sendsGzip := strings.Contains(contentEncoding, "gzip")
                if sendsGzip </span><span class="cov7" title="20">{
                        // Создаем reader с поддержкой распаковки
                        cr, err := httpgzip.NewCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov7" title="20">r.Body = cr
                        defer cr.Close()</span>
                }

                // Передаем управление следующему обработчику
                <span class="cov10" title="48">next.ServeHTTP(ow, r)</span>
        }

        <span class="cov7" title="14">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package server

import (
        "context"
        "net/http"
        _ "net/http/pprof"
        "os"
        "os/signal"
        "syscall"
        "time"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/handlers/batch"
        "github.com/ryabkov82/shortener/internal/app/handlers/deluserurls"
        "github.com/ryabkov82/shortener/internal/app/handlers/ping"
        "github.com/ryabkov82/shortener/internal/app/handlers/redirect"
        "github.com/ryabkov82/shortener/internal/app/handlers/shortenapi"
        "github.com/ryabkov82/shortener/internal/app/handlers/shorturl"
        "github.com/ryabkov82/shortener/internal/app/handlers/userurls"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/auth"
        mwlogger "github.com/ryabkov82/shortener/internal/app/server/middleware/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/mwgzip"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/internal/app/storage/inmemory"
        "github.com/ryabkov82/shortener/internal/app/storage/postgres"

        "github.com/go-chi/chi/v5"

        "github.com/ryabkov82/shortener/internal/app/pprof"
)

// StartServer запускает HTTP-сервер.
func StartServer(log *zap.Logger, cfg *config.Config) <span class="cov0" title="0">{

        pprof.StartPProf(log, cfg.ConfigPProf)

        srv := &amp;service.Service{}

        if cfg.DBConnect != "" </span><span class="cov0" title="0">{
                pg, err := postgres.NewPostgresStorage(cfg.DBConnect)

                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">srv = service.NewService(pg)
                log.Info("Storage postgres")</span>
        } else<span class="cov0" title="0"> {
                st, err := inmemory.NewInMemoryStorage(cfg.FileStorage)

                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                // загружаем сохраненные данные из файла..
                <span class="cov0" title="0">if err := st.Load(cfg.FileStorage); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">srv = service.NewService(st)
                log.Info("Storage inmemory", zap.String("FileStorage", cfg.FileStorage))</span>
        }

        <span class="cov0" title="0">router := chi.NewRouter()
        router.Use(mwlogger.RequestLogging(log))
        router.Use(mwgzip.Gzip)

        /*
                // Группа с автоматической аутентификацией
                router.Group(func(router chi.Router) {
                        router.Use(auth.JWTAutoIssue([]byte(cfg.JwtKey)))

                        router.Post("/", shorturl.GetHandler(srv, cfg.BaseURL, log))
                        router.Get("/{id}", redirect.GetHandler(srv, log))

                        router.Post("/api/shorten", shortenapi.GetHandler(srv, cfg.BaseURL, log))

                        router.Get("/ping", ping.GetHandler(srv, log))
                        router.Post("/api/shorten/batch", batch.GetHandler(srv, cfg.BaseURL, log))
                })

                // Группа со строгой аутентификацией
                router.Group(func(router chi.Router) {
                        router.Use(auth.StrictJWTAutoIssue([]byte(cfg.JwtKey)))
                        router.Get("/api/user/urls", userurls.GetHandler(srv, cfg.BaseURL, log))
                })
        */

        router.Use(auth.JWTAutoIssue([]byte(cfg.JwtKey)))

        router.Post("/", shorturl.GetHandler(srv, cfg.BaseURL, log))
        router.Get("/{id}", redirect.GetHandler(srv, log))

        router.Post("/api/shorten", shortenapi.GetHandler(srv, cfg.BaseURL, log))

        router.Get("/ping", ping.GetHandler(srv, log))
        router.Post("/api/shorten/batch", batch.GetHandler(srv, cfg.BaseURL, log))
        router.Get("/api/user/urls", userurls.GetHandler(srv, cfg.BaseURL, log))
        router.Delete("/api/user/urls", deluserurls.GetHandler(srv, cfg.BaseURL, log))

        log.Info("Server started", zap.String("address", cfg.HTTPServerAddr))

        // Запуск HTTP-сервера в отдельной горутине

        server := &amp;http.Server{
                Addr:    cfg.HTTPServerAddr,
                Handler: router, // Ваш роутер
        }

        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error("failed to serve server", zap.Error(err))
                }</span>
        }()

        // Обработка сигналов завершения
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("Shutting down server...")

        // Создаем контекст с таймаутом для graceful shutdown
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Остановка HTTP-сервера
        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Info("HTTP server shutdown error", zap.Error(err))
        }</span>

        // корректное завершение работы воркеров сервиса
        <span class="cov0" title="0">srv.GracefulStop(5 * time.Second)

        log.Info("Server shutdown complete")</span>

}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ryabkov82/shortener/internal/app/service (interfaces: Repository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"

        models "github.com/ryabkov82/shortener/internal/app/models"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov5" title="2">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov10" title="4">{
        return m.recorder
}</span>

// BatchMarkAsDeleted mocks base method.
func (m *MockRepository) BatchMarkAsDeleted(arg0 string, arg1 []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BatchMarkAsDeleted", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BatchMarkAsDeleted indicates an expected call of BatchMarkAsDeleted.
func (mr *MockRepositoryMockRecorder) BatchMarkAsDeleted(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchMarkAsDeleted", reflect.TypeOf((*MockRepository)(nil).BatchMarkAsDeleted), arg0, arg1)
}</span>

// GetExistingURLs mocks base method.
func (m *MockRepository) GetExistingURLs(arg0 context.Context, arg1 []string) (map[string]string, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetExistingURLs", arg0, arg1)
        ret0, _ := ret[0].(map[string]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetExistingURLs indicates an expected call of GetExistingURLs.
func (mr *MockRepositoryMockRecorder) GetExistingURLs(arg0, arg1 interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExistingURLs", reflect.TypeOf((*MockRepository)(nil).GetExistingURLs), arg0, arg1)
}</span>

// GetRedirectURL mocks base method.
func (m *MockRepository) GetRedirectURL(arg0 context.Context, arg1 string) (models.URLMapping, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRedirectURL", arg0, arg1)
        ret0, _ := ret[0].(models.URLMapping)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetRedirectURL indicates an expected call of GetRedirectURL.
func (mr *MockRepositoryMockRecorder) GetRedirectURL(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRedirectURL", reflect.TypeOf((*MockRepository)(nil).GetRedirectURL), arg0, arg1)
}</span>

// GetShortKey mocks base method.
func (m *MockRepository) GetShortKey(arg0 context.Context, arg1 string) (models.URLMapping, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetShortKey", arg0, arg1)
        ret0, _ := ret[0].(models.URLMapping)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetShortKey indicates an expected call of GetShortKey.
func (mr *MockRepositoryMockRecorder) GetShortKey(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetShortKey", reflect.TypeOf((*MockRepository)(nil).GetShortKey), arg0, arg1)
}</span>

// GetUserUrls mocks base method.
func (m *MockRepository) GetUserUrls(arg0 context.Context, arg1 string) ([]models.URLMapping, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserUrls", arg0, arg1)
        ret0, _ := ret[0].([]models.URLMapping)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserUrls indicates an expected call of GetUserUrls.
func (mr *MockRepositoryMockRecorder) GetUserUrls(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserUrls", reflect.TypeOf((*MockRepository)(nil).GetUserUrls), arg0, arg1)
}</span>

// Ping mocks base method.
func (m *MockRepository) Ping(arg0 context.Context) error <span class="cov5" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockRepositoryMockRecorder) Ping(arg0 interface{}) *gomock.Call <span class="cov5" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockRepository)(nil).Ping), arg0)
}</span>

// SaveNewURLs mocks base method.
func (m *MockRepository) SaveNewURLs(arg0 context.Context, arg1 []models.URLMapping) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveNewURLs", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveNewURLs indicates an expected call of SaveNewURLs.
func (mr *MockRepositoryMockRecorder) SaveNewURLs(arg0, arg1 interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveNewURLs", reflect.TypeOf((*MockRepository)(nil).SaveNewURLs), arg0, arg1)
}</span>

// SaveURL mocks base method.
func (m *MockRepository) SaveURL(arg0 context.Context, arg1 *models.URLMapping) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveURL", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveURL indicates an expected call of SaveURL.
func (mr *MockRepositoryMockRecorder) SaveURL(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveURL", reflect.TypeOf((*MockRepository)(nil).SaveURL), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package service реализует бизнес-логику сервиса сокращения URL.
//
// Основные функции:
// - Генерация коротких ключей
// - Управление хранилищем URL
// - Пакетная обработка запросов
// - Асинхронное удаление URL
package service

import (
        "context"
        "math/rand"
        "time"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/workers/deleteurls"
)

// Repository определяет интерфейс для работы с хранилищем URL.
type Repository interface {
        GetShortKey(context.Context, string) (models.URLMapping, error)
        GetRedirectURL(context.Context, string) (models.URLMapping, error)
        SaveURL(context.Context, *models.URLMapping) error
        Ping(context.Context) error
        SaveNewURLs(context.Context, []models.URLMapping) error
        GetExistingURLs(context.Context, []string) (map[string]string, error)
        GetUserUrls(context.Context, string) ([]models.URLMapping, error)
        BatchMarkAsDeleted(userID string, urls []string) error
}

// Service реализует основной сервис приложения.
type Service struct {
        repo         Repository               // Хранилище данных
        deleteworker *deleteurls.DeleteWorker // Воркер для асинхронного удаления
}

// NewService создает новый экземпляр сервиса.
//
// Параметры:
//
//        storage - реализация интерфейса Repository
//
// Возвращает:
//
//        *Service - инициализированный сервис
func NewService(storage Repository) *Service <span class="cov5" title="14">{
        // Инициализация воркера для удаления:
        // - 1 воркер
        // - Буфер на 10 задач
        // - Задержка 500мс перед обработкой
        delworker := deleteurls.NewDeleteWorker(1, 10, 500*time.Millisecond, storage)
        delworker.Start()

        return &amp;Service{
                repo:         storage,
                deleteworker: delworker,
        }
}</span>

// GetShortKey генерирует и сохраняет короткий ключ для URL.
//
// Параметры:
//
//        ctx - контекст с идентификатором пользователя
//        originalURL - URL для сокращения
//
// Возвращает:
//
//        string - сгенерированный короткий ключ
//        error - ошибка при сохранении:
//          - storage.ErrURLExists если URL уже существует
func (s *Service) GetShortKey(ctx context.Context, originalURL string) (string, error) <span class="cov6" title="24">{
        shortKey := generateShortKey()
        mapping := models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }

        err := s.repo.SaveURL(ctx, &amp;mapping)
        return mapping.ShortURL, err
}</span>

// GetRedirectURL возвращает оригинальный URL для редиректа.
//
// Параметры:
//
//        ctx - контекст запроса
//        shortKey - короткий идентификатор URL
//
// Возвращает:
//
//        string - оригинальный URL
//        error:
//          - storage.ErrURLNotFound если URL не существует
//          - storage.ErrURLDeleted если URL помечен как удаленный
func (s *Service) GetRedirectURL(ctx context.Context, shortKey string) (string, error) <span class="cov5" title="14">{
        mapping, err := s.repo.GetRedirectURL(ctx, shortKey)
        return mapping.OriginalURL, err
}</span>

// Ping проверяет доступность хранилища.
func (s *Service) Ping(ctx context.Context) error <span class="cov2" title="2">{
        return s.repo.Ping(ctx)
}</span>

// Batch обрабатывает пакетный запрос на сокращение URL.
//
// Параметры:
//
//        ctx - контекст с идентификатором пользователя
//        batchRequest - список URL для обработки
//        baseURL - базовый адрес для построения полных коротких URL
//
// Возвращает:
//
//        []models.BatchResponse - результаты обработки
//        error - ошибка при сохранении
func (s *Service) Batch(ctx context.Context, batchRequest []models.BatchRequest, baseURL string) ([]models.BatchResponse, error) <span class="cov2" title="3">{
        originalURLs := make([]string, len(batchRequest))
        for i, item := range batchRequest </span><span class="cov3" title="6">{
                originalURLs[i] = item.OriginalURL
        }</span>

        <span class="cov2" title="3">existingURLs, err := s.repo.GetExistingURLs(ctx, originalURLs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="3">var newURLs []models.URLMapping
        batchResponse := make([]models.BatchResponse, 0, len(batchRequest))

        for _, item := range batchRequest </span><span class="cov3" title="6">{
                if shortURL, ok := existingURLs[item.OriginalURL]; ok </span><span class="cov0" title="0">{
                        batchResponse = append(batchResponse, models.BatchResponse{
                                CorrelationID: item.CorrelationID,
                                ShortURL:      baseURL + "/" + shortURL,
                        })
                        continue</span>
                }

                <span class="cov3" title="6">shortURL := generateShortKey()
                newURLs = append(newURLs, models.URLMapping{
                        OriginalURL: item.OriginalURL,
                        ShortURL:    shortURL,
                })

                batchResponse = append(batchResponse, models.BatchResponse{
                        CorrelationID: item.CorrelationID,
                        ShortURL:      baseURL + "/" + shortURL,
                })</span>
        }

        <span class="cov2" title="3">if err := s.repo.SaveNewURLs(ctx, newURLs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="3">return batchResponse, nil</span>
}

// GetUserUrls возвращает все сокращенные URL пользователя.
//
// Параметры:
//
//        ctx - контекст с идентификатором пользователя
//        baseURL - базовый адрес для построения полных коротких URL
//
// Возвращает:
//
//        []models.URLMapping - список URL пользователя
//        error - ошибка при получении
func (s *Service) GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error) <span class="cov3" title="4">{
        return s.repo.GetUserUrls(ctx, baseURL)
}</span>

// DeleteUserUrls помечает URL пользователя как удаленные (асинхронно).
//
// Параметры:
//
//        ctx - контекст с идентификатором пользователя
//        shortURLs - список коротких URL для удаления
//
// Возвращает:
//
//        error - ошибка при постановке задачи в очередь
func (s *Service) DeleteUserUrls(ctx context.Context, shortURLs []string) error <span class="cov4" title="8">{
        userID := ctx.Value(jwtauth.UserIDContextKey).(string)
        return s.deleteworker.Submit(deleteurls.DeleteTask{
                UserID:    userID,
                ShortURLs: shortURLs,
        })
}</span>

// GracefulStop корректно останавливает сервис.
//
// Параметры:
//
//        timeout - максимальное время ожидания завершения операций
func (s *Service) GracefulStop(timeout time.Duration) <span class="cov0" title="0">{
        s.deleteworker.GracefulStop(timeout)
}</span>

// generateShortKey генерирует случайный короткий ключ.
//
// Возвращает:
//
//        string - 8-символьный ключ из [a-zA-Z0-9]
func generateShortKey() string <span class="cov6" title="30">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        const keyLength = 8

        rand.New(rand.NewSource(time.Now().UnixNano()))
        shortKey := make([]byte, keyLength)
        for i := range shortKey </span><span class="cov10" title="240">{
                shortKey[i] = charset[rand.Intn(len(charset))]
        }</span>
        <span class="cov6" title="30">return string(shortKey)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package inmemory реализует in-memory хранилище для сервиса сокращения URL с персистентностью в файл.
//
// Основные особенности:
// - Хранение данных в памяти с синхронизацией через RWMutex
// - Сохранение данных в файл в формате JSON (append-only лог)
// - Поддержка транзакционности операций
// - Оптимизированное чтение для операций редиректа
package inmemory

import (
        "bufio"
        "context"
        "encoding/json"
        "errors"
        "os"
        "sync"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/storage"
)

// InMemoryStorage реализует интерфейс хранилища с in-memory кешем и файловой персистентностью.
//
// Структура использует:
// - userURLIndex: индекс для быстрого поиска по пользователю и оригинальному URL
// - shortCodeMap: основное хранилище сопоставлений
// - countRecords: счетчик записей для генерации UUID
// - file/encoder: для персистентного хранения
// - mu: RWMutex для синхронизации доступа
type InMemoryStorage struct {
        userURLIndex map[string]map[string]string
        shortCodeMap map[string]models.UserURLMapping
        file         *os.File
        encoder      *json.Encoder
        countRecords uint64
        mu           sync.RWMutex
}

// NewInMemoryStorage создает новое in-memory хранилище с файловой персистентностью.
//
// Параметры:
//
//        fileStoragePath - путь к файлу для хранения данных
//
// Возвращает:
//
//        *InMemoryStorage - инициализированное хранилище
//        error - ошибка при создании файла
//
// Пример:
//
//        storage, err := NewInMemoryStorage("data/storage.json")
func NewInMemoryStorage(fileStoragePath string) (*InMemoryStorage, error) <span class="cov6" title="6">{
        file, err := os.OpenFile(fileStoragePath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="6">return &amp;InMemoryStorage{
                userURLIndex: make(map[string]map[string]string),
                shortCodeMap: make(map[string]models.UserURLMapping),
                countRecords: 0,
                file:         file,
                encoder:      json.NewEncoder(file),
        }, nil</span>
}

// Load загружает данные из файла в память.
//
// Формат файла: JSON-строки (по одной на запись)
// В случае ошибки в строке она пропускается, но загрузка продолжается
//
// Параметры:
//
//        fileStoragePath - путь к файлу с данными
//
// Возвращает:
//
//        error - ошибка чтения файла
func (s *InMemoryStorage) Load(fileStoragePath string) error <span class="cov6" title="6">{
        file, err := os.OpenFile(fileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="6">defer file.Close()

        scanner := bufio.NewScanner(file)
        var countRecords uint64

        for scanner.Scan() </span><span class="cov10" title="18">{
                line := scanner.Bytes()
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="18">var url models.UserURLMapping
                if err := json.Unmarshal(line, &amp;url); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="18">if url.UserID == "" || url.OriginalURL == "" || url.ShortURL == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="18">if _, ok := s.userURLIndex[url.UserID]; !ok </span><span class="cov7" title="9">{
                        s.userURLIndex[url.UserID] = make(map[string]string)
                }</span>

                <span class="cov10" title="18">s.userURLIndex[url.UserID][url.OriginalURL] = url.ShortURL
                s.shortCodeMap[url.ShortURL] = url
                countRecords++</span>
        }

        <span class="cov6" title="6">s.countRecords = countRecords
        return scanner.Err()</span>
}

// GetShortKey возвращает короткий ключ для оригинального URL пользователя.
//
// Параметры:
//
//        ctx - контекст с userID
//        originalURL - URL для поиска
//
// Возвращает:
//
//        models.URLMapping - найденное соответствие
//        error - ошибка поиска (storage.ErrURLNotFound если не найден)
func (s *InMemoryStorage) GetShortKey(ctx context.Context, originalURL string) (models.URLMapping, error) <span class="cov3" title="2">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        userID := ctx.Value(jwtauth.UserIDContextKey)
        if userID == nil </span><span class="cov0" title="0">{
                return models.URLMapping{}, errors.New("userID is not set")
        }</span>

        <span class="cov3" title="2">shortKey, found := s.userURLIndex[userID.(string)][originalURL]
        if !found </span><span class="cov3" title="2">{
                return models.URLMapping{}, storage.ErrURLNotFound
        }</span>

        <span class="cov0" title="0">return models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }, nil</span>
}

// GetRedirectURL возвращает оригинальный URL для редиректа.
//
// Параметры:
//
//        ctx - контекст запроса
//        shortKey - короткий идентификатор URL
//
// Возвращает:
//
//        models.URLMapping - найденное соответствие
//        error:
//          - storage.ErrURLNotFound если URL не существует
//          - storage.ErrURLDeleted если URL помечен как удаленный
func (s *InMemoryStorage) GetRedirectURL(ctx context.Context, shortKey string) (models.URLMapping, error) <span class="cov7" title="7">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        url, found := s.shortCodeMap[shortKey]
        if !found </span><span class="cov3" title="2">{
                return models.URLMapping{}, storage.ErrURLNotFound
        }</span>

        <span class="cov6" title="5">if url.DeletedFlag </span><span class="cov4" title="3">{
                return models.URLMapping{}, storage.ErrURLDeleted
        }</span>

        <span class="cov3" title="2">return models.URLMapping{
                ShortURL:    url.ShortURL,
                OriginalURL: url.OriginalURL,
        }, nil</span>
}

// SaveURL сохраняет новое соответствие URL.
//
// Параметры:
//
//        ctx - контекст с userID
//        mapping - сохраняемое соответствие URL
//
// Возвращает:
//
//        error:
//          - storage.ErrShortURLExists если shortURL уже существует
//          - storage.ErrURLExists если originalURL уже существует
func (s *InMemoryStorage) SaveURL(ctx context.Context, mapping *models.URLMapping) error <span class="cov9" title="15">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, found := s.shortCodeMap[mapping.ShortURL]; found </span><span class="cov0" title="0">{
                return storage.ErrShortURLExists
        }</span>

        <span class="cov9" title="15">userID := ctx.Value(jwtauth.UserIDContextKey)
        if userID == nil </span><span class="cov0" title="0">{
                return errors.New("userID is not set")
        }</span>

        <span class="cov9" title="15">if _, ok := s.userURLIndex[userID.(string)]; !ok </span><span class="cov7" title="8">{
                s.userURLIndex[userID.(string)] = make(map[string]string)
        }</span>

        <span class="cov9" title="15">if shortURL, exists := s.userURLIndex[userID.(string)][mapping.OriginalURL]; exists </span><span class="cov3" title="2">{
                mapping.ShortURL = shortURL
                return storage.ErrURLExists
        }</span>

        <span class="cov8" title="13">s.userURLIndex[userID.(string)][mapping.OriginalURL] = mapping.ShortURL
        s.countRecords++

        userURLMapping := models.UserURLMapping{
                UUID:        s.countRecords,
                ShortURL:    mapping.ShortURL,
                OriginalURL: mapping.OriginalURL,
                UserID:      userID.(string),
                DeletedFlag: false,
        }
        s.shortCodeMap[mapping.ShortURL] = userURLMapping

        return s.encoder.Encode(userURLMapping)</span>
}

// Ping проверяет доступность хранилища (всегда возвращает nil).
func (s *InMemoryStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// GetExistingURLs возвращает существующие URL из списка.
//
// Параметры:
//
//        ctx - контекст с userID
//        originalURLs - список URL для проверки
//
// Возвращает:
//
//        map[string]string - карта существующих URL (originalURL -&gt; shortURL)
//        error - ошибка операции
func (s *InMemoryStorage) GetExistingURLs(ctx context.Context, originalURLs []string) (map[string]string, error) <span class="cov1" title="1">{
        existing := make(map[string]string)

        if len(originalURLs) == 0 </span><span class="cov0" title="0">{
                return existing, nil
        }</span>

        <span class="cov1" title="1">for _, originalURL := range originalURLs </span><span class="cov3" title="2">{
                mapping, err := s.GetShortKey(ctx, originalURL)
                if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLNotFound) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">if err == nil </span><span class="cov0" title="0">{
                        existing[mapping.OriginalURL] = mapping.ShortURL
                }</span>
        }

        <span class="cov1" title="1">return existing, nil</span>
}

// SaveNewURLs сохраняет список новых URL.
//
// Параметры:
//
//        ctx - контекст с userID
//        urls - список URL для сохранения
//
// Возвращает:
//
//        error - первая ошибка при сохранении
func (s *InMemoryStorage) SaveNewURLs(ctx context.Context, urls []models.URLMapping) error <span class="cov1" title="1">{
        for _, url := range urls </span><span class="cov3" title="2">{
                if err := s.SaveURL(ctx, &amp;url); err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// GetUserUrls возвращает все URL пользователя.
//
// Параметры:
//
//        ctx - контекст с userID
//        baseURL - базовый URL для построения полных коротких URL
//
// Возвращает:
//
//        []models.URLMapping - список URL пользователя
//        error - ошибка операции
func (s *InMemoryStorage) GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error) <span class="cov3" title="2">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        userID := ctx.Value(jwtauth.UserIDContextKey)
        if userID == nil </span><span class="cov0" title="0">{
                return nil, errors.New("userID is not set")
        }</span>

        <span class="cov3" title="2">userURLs, exists := s.userURLIndex[userID.(string)]
        if !exists </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">var result []models.URLMapping
        for originalURL, shortCode := range userURLs </span><span class="cov3" title="2">{
                result = append(result, models.URLMapping{
                        OriginalURL: originalURL,
                        ShortURL:    baseURL + "/" + shortCode,
                })
        }</span>
        <span class="cov1" title="1">return result, nil</span>
}

// BatchMarkAsDeleted помечает URL пользователя как удаленные.
//
// Параметры:
//
//        userID - идентификатор пользователя
//        urls - список коротких URL для удаления
//
// Возвращает:
//
//        error - ошибка операции
func (s *InMemoryStorage) BatchMarkAsDeleted(userID string, urls []string) error <span class="cov5" title="4">{
        s.mu.Lock()
        defer s.mu.Unlock()

        for _, code := range urls </span><span class="cov6" title="5">{
                if mapping, exists := s.shortCodeMap[code]; exists &amp;&amp; mapping.UserID == userID </span><span class="cov4" title="3">{
                        mapping.DeletedFlag = true
                        s.shortCodeMap[code] = mapping
                        if err := s.encoder.Encode(mapping); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov5" title="4">return nil</span>
}

// FilePath возвращает путь к файлу, используемому хранилищем.
// Если файл не открыт, возвращает пустую строку.
func (s *InMemoryStorage) FilePath() string <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        if s.file == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return s.file.Name()</span>
}

// Close освобождает ресурсы
func (s *InMemoryStorage) Close() error <span class="cov6" title="6">{
        if s.file != nil </span><span class="cov6" title="6">{
                return s.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package postgres

import (
        "database/sql"
        "embed"
        "time"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        "github.com/golang-migrate/migrate/v4/source/iofs"
)

//go:embed migrations/*.sql
var fs embed.FS

func applyMigrations(db *sql.DB) error <span class="cov10" title="6">{
        // 1. Создаем драйвер для источника миграций (из embed.FS)
        sourceDriver, err := iofs.New(fs, "migrations")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 2. Создаем драйвер для базы данных
        <span class="cov10" title="6">dbDriver, err := postgres.WithInstance(db, &amp;postgres.Config{
                StatementTimeout: 5 * time.Minute, // Для операций миграции
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 3. Инициализируем мигратор
        <span class="cov10" title="6">m, err := migrate.NewWithInstance(
                "iofs",       // Имя драйвера источника
                sourceDriver, // Экземпляр драйвера источника
                "postgres",   // Имя драйвера БД
                dbDriver)     // Экземпляр драйвера БД
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 4. Применяем миграции
        <span class="cov10" title="6">if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="6">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package postgres предоставляет реализацию хранилища URL на PostgreSQL.
//
// Пакет включает:
// - Подключение к PostgreSQL с настройкой пула соединений
// - Подготовленные SQL-запросы для повышения производительности
// - Поддержку транзакций для пакетных операций
// - Обработку миграций базы данных
package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        _ "github.com/jackc/pgx/v5/stdlib"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/storage"
)

// PostgresStorage реализует интерфейс хранилища для работы с PostgreSQL.
type PostgresStorage struct {
        db              *sql.DB
        getShortURLStmt *sql.Stmt
        getURLStmt      *sql.Stmt
        insertURLStmt   *sql.Stmt
}

// NewPostgresStorage создает новое подключение к PostgreSQL и инициализирует хранилище.
//
// Параметры:
//   - StoragePath: строка подключения к PostgreSQL
//
// Возвращает:
//   - *PostgresStorage: инициализированное хранилище
//   - error: ошибка при подключении или инициализации
func NewPostgresStorage(storagePath string) (*PostgresStorage, error) <span class="cov7" title="6">{
        db, err := sql.Open("pgx", storagePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="6">if err = applyMigrations(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("migrations failed: %w", err)
        }</span>

        // Настройка пула соединений
        <span class="cov7" title="6">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(25)
        db.SetConnMaxLifetime(5 * time.Minute)

        // Подготовка часто используемых запросов
        getShortURLStmt, err := db.Prepare(`SELECT short_code FROM short_urls WHERE original_url = $1 and user_id = $2`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="6">getURLStmt, err := db.Prepare(`SELECT original_url, is_deleted FROM short_urls WHERE short_code = $1`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="6">insertURLStmt, err := db.Prepare(`
        INSERT INTO short_urls (original_url, short_code, user_id)
        VALUES ($1, $2, $3)
        ON CONFLICT (user_id, original_url) DO UPDATE SET
                original_url = EXCLUDED.original_url
        RETURNING short_code, xmax;
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="6">return &amp;PostgresStorage{db, getShortURLStmt, getURLStmt, insertURLStmt}, nil</span>
}

// Ping проверяет соединение с базой данных.
//
// Параметры:
//
//        ctx - контекст выполнения
//
// Возвращает:
//
//        error - ошибка соединения
func (s *PostgresStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        ctxTm, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()
        return s.db.PingContext(ctxTm)
}</span>

// GetShortKey возвращает сокращенный URL для оригинального.
//
// Параметры:
//
//        ctx - контекст выполнения
//        originalURL - оригинальный URL
//
// Возвращает:
//
//        models.URLMapping - соответствие URL
//        error - ошибка операции
func (s *PostgresStorage) GetShortKey(ctx context.Context, originalURL string) (models.URLMapping, error) <span class="cov0" title="0">{
        mapping := models.URLMapping{
                OriginalURL: originalURL,
        }

        userID := ctx.Value(jwtauth.UserIDContextKey)
        err := s.getShortURLStmt.QueryRowContext(ctx, originalURL, userID).Scan(&amp;mapping.ShortURL)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return mapping, storage.ErrURLNotFound
                }</span>
                <span class="cov0" title="0">return mapping, err</span>
        }

        <span class="cov0" title="0">return mapping, nil</span>
}

// GetRedirectURL возвращает оригинальный URL для сокращенного.
//
// Параметры:
//
//        ctx - контекст выполнения
//        shortKey - сокращенный ключ URL
//
// Возвращает:
//
//        models.URLMapping - соответствие URL
//        error - ошибка операции
func (s *PostgresStorage) GetRedirectURL(ctx context.Context, shortKey string) (models.URLMapping, error) <span class="cov7" title="7">{
        mapping := models.URLMapping{
                ShortURL: shortKey,
        }

        var deletedFlag bool
        err := s.getURLStmt.QueryRowContext(ctx, shortKey).Scan(&amp;mapping.OriginalURL, &amp;deletedFlag)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov3" title="2">{
                        return mapping, fmt.Errorf("%w", storage.ErrURLNotFound)
                }</span>
                <span class="cov0" title="0">return mapping, fmt.Errorf("ошибка при поиске URL: %w", err)</span>
        }

        <span class="cov6" title="5">if deletedFlag </span><span class="cov4" title="3">{
                return mapping, storage.ErrURLDeleted
        }</span>
        <span class="cov3" title="2">return mapping, nil</span>
}

// SaveURL сохраняет новое соответствие URL.
//
// Параметры:
//
//        ctx - контекст выполнения
//        mapping - соответствие URL для сохранения
//
// Возвращает:
//
//        error - ошибка операции
func (s *PostgresStorage) SaveURL(ctx context.Context, mapping *models.URLMapping) error <span class="cov10" title="13">{
        var xmax int64 // Системный столбец для определения конфликтов

        userID := ctx.Value(jwtauth.UserIDContextKey)
        err := s.insertURLStmt.QueryRowContext(ctx, mapping.OriginalURL, mapping.ShortURL, userID).Scan(&amp;mapping.ShortURL, &amp;xmax)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="13">if xmax &gt; 0 </span><span class="cov3" title="2">{
                err = storage.ErrURLExists
        }</span>

        <span class="cov10" title="13">return err</span>
}

// GetExistingURLs возвращает существующие сокращения для URL.
//
// Параметры:
//
//        ctx - контекст выполнения
//        originalURLs - список оригинальных URL
//
// Возвращает:
//
//        map[string]string - соответствия URL
//        error - ошибка операции
func (s *PostgresStorage) GetExistingURLs(ctx context.Context, originalURLs []string) (map[string]string, error) <span class="cov1" title="1">{
        existing := make(map[string]string)
        if len(originalURLs) == 0 </span><span class="cov0" title="0">{
                return existing, nil
        }</span>

        <span class="cov1" title="1">query := "SELECT original_url, short_code FROM short_urls WHERE original_url = ANY($1) and user_id = $2"
        userID := ctx.Value(jwtauth.UserIDContextKey)

        rows, err := s.db.QueryContext(ctx, query, originalURLs, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var originalURL, shortURL string
                if err := rows.Scan(&amp;originalURL, &amp;shortURL); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">existing[originalURL] = shortURL</span>
        }

        <span class="cov1" title="1">return existing, rows.Err()</span>
}

// SaveNewURLs сохраняет пакет новых URL.
//
// Параметры:
//
//        ctx - контекст выполнения
//        urls - список URL для сохранения
//
// Возвращает:
//
//        error - ошибка операции
func (s *PostgresStorage) SaveNewURLs(ctx context.Context, urls []models.URLMapping) error <span class="cov1" title="1">{
        if len(urls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">userID := ctx.Value(jwtauth.UserIDContextKey)

        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov1" title="1">stmt, err := tx.Prepare("INSERT INTO short_urls (original_url, short_code, user_id) VALUES($1, $2, $3)")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer stmt.Close()

        for _, url := range urls </span><span class="cov3" title="2">{
                _, err = stmt.ExecContext(ctx, url.OriginalURL, url.ShortURL, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return tx.Commit()</span>
}

// GetUserUrls возвращает все URL пользователя.
//
// Параметры:
//
//        ctx - контекст выполнения
//        baseURL - базовый URL сервиса
//
// Возвращает:
//
//        []models.URLMapping - список URL пользователя
//        error - ошибка операции
func (s *PostgresStorage) GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error) <span class="cov3" title="2">{
        userID := ctx.Value(jwtauth.UserIDContextKey)
        query := "SELECT original_url, short_code FROM short_urls WHERE user_id = $1"

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var userURLs []models.URLMapping
        for rows.Next() </span><span class="cov3" title="2">{
                var originalURL, shortURL string
                if err := rows.Scan(&amp;originalURL, &amp;shortURL); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">userURLs = append(userURLs, models.URLMapping{
                        OriginalURL: originalURL,
                        ShortURL:    baseURL + "/" + shortURL,
                })</span>
        }

        <span class="cov3" title="2">return userURLs, rows.Err()</span>
}

// BatchMarkAsDeleted помечает URL пользователя как удаленные.
//
// Параметры:
//
//        userID - идентификатор пользователя
//        urls - список коротких URL для удаления
//
// Возвращает:
//
//        error - ошибка операции
func (s *PostgresStorage) BatchMarkAsDeleted(userID string, urls []string) error <span class="cov5" title="4">{
        if len(urls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov5" title="4">var params []interface{}
        query := "UPDATE short_urls SET is_deleted = true WHERE short_code IN ("

        for i, url := range urls </span><span class="cov6" title="5">{
                query += fmt.Sprintf("$%d,", i+1)
                params = append(params, url)
        }</span>
        <span class="cov5" title="4">query = strings.TrimSuffix(query, ",") + ") AND user_id = $" + fmt.Sprintf("%d", len(urls)+1)
        params = append(params, userID)

        _, err := s.db.Exec(query, params...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error updating batch: %w", err)
        }</span>

        <span class="cov5" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package deleteurls предоставляет асинхронный обработчик для пакетного удаления URL в сервисе сокращения ссылок.
//
// Пакет реализует паттерн "рабочий пул" с:
// - Группировкой запросов по пользователям
// - Настраиваемым размером пакета и временем ожидания
// - Параллельной обработкой с помощью пула воркеров
// - Поддержкой плавного завершения работы
package deleteurls

import (
        "errors"
        "log"
        "sync"
        "time"
)

// Repository определяет интерфейс хранилища, необходимый для работы DeleteWorker.
type Repository interface {
        // BatchMarkAsDeleted помечает несколько URL как удаленные для указанного пользователя.
        // Возвращает ошибку в случае неудачи.
        BatchMarkAsDeleted(userID string, urls []string) error
}

// DeleteTask представляет запрос на удаление нескольких сокращенных URL для пользователя.
type DeleteTask struct {
        UserID    string   // ID пользователя, инициировавшего запрос
        ShortURLs []string // Список сокращенных URL для пометки как удаленных
}

// DeleteWorker управляет жизненным циклом обработки удаления URL.
// Агрегирует запросы в пакеты и обрабатывает их асинхронно.
type DeleteWorker struct {
        repo        Repository
        taskChan    chan DeleteTask
        batchChan   chan map[string][]string
        stopChan    chan struct{}
        wg          sync.WaitGroup
        workerCount int
        batchSize   int
        batchWindow time.Duration
}

// NewDeleteWorker создает новый экземпляр DeleteWorker с заданными параметрами.
//
// Параметры:
//   - workerCount: количество воркеров для обработки пакетов
//   - batchSize: максимальный размер пакета перед обработкой
//   - batchWindow: максимальное время ожидания формирования пакета
//   - storage: реализация интерфейса Repository
func NewDeleteWorker(workerCount, batchSize int, batchWindow time.Duration, storage Repository) *DeleteWorker <span class="cov7" title="14">{
        return &amp;DeleteWorker{
                taskChan:    make(chan DeleteTask, 10000),
                batchChan:   make(chan map[string][]string, 100),
                stopChan:    make(chan struct{}),
                workerCount: workerCount,
                batchSize:   batchSize,
                batchWindow: batchWindow,
                repo:        storage,
        }
}</span>

// Start запускает воркеры и сборщик пакетов.
func (w *DeleteWorker) Start() <span class="cov7" title="14">{
        w.wg.Add(w.workerCount + 1) // +1 для сборщика пакетов

        go w.batchCollector() // Запускаем сборщик пакетов

        for i := 0; i &lt; w.workerCount; i++ </span><span class="cov7" title="14">{
                go w.batchProcessor() // Запускаем воркеры
        }</span>
}

// Submit добавляет новую задачу на удаление в очередь обработки.
// Возвращает ошибку если очередь переполнена.
func (w *DeleteWorker) Submit(task DeleteTask) error <span class="cov6" title="8">{
        select </span>{
        case w.taskChan &lt;- task:<span class="cov6" title="8">
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("очередь переполнена")</span>
        }
}

// batchCollector собирает задачи в пакеты по пользователям.
// Отправляет пакеты на обработку при достижении batchSize или по истечении batchWindow.
func (w *DeleteWorker) batchCollector() <span class="cov7" title="14">{
        defer w.wg.Done()

        batch := make(map[string][]string)
        ticker := time.NewTicker(w.batchWindow)
        defer ticker.Stop()

        for </span><span class="cov10" title="38">{
                select </span>{
                case &lt;-w.stopChan:<span class="cov0" title="0">
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                w.batchChan &lt;- batch
                        }</span>
                        <span class="cov0" title="0">close(w.batchChan)
                        return</span>

                case task, ok := &lt;-w.taskChan:<span class="cov6" title="8">
                        if !ok </span><span class="cov0" title="0">{
                                if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                        w.batchChan &lt;- batch
                                }</span>
                                <span class="cov0" title="0">close(w.batchChan)
                                return</span>
                        }

                        <span class="cov6" title="8">if urls, exists := batch[task.UserID]; exists </span><span class="cov0" title="0">{
                                batch[task.UserID] = append(urls, task.ShortURLs...)
                        }</span> else<span class="cov6" title="8"> {
                                batch[task.UserID] = task.ShortURLs
                        }</span>

                        <span class="cov6" title="8">if len(batch) &gt;= w.batchSize </span><span class="cov0" title="0">{
                                w.batchChan &lt;- batch
                                batch = make(map[string][]string)
                                ticker.Reset(w.batchWindow)
                        }</span>

                case &lt;-ticker.C:<span class="cov7" title="16">
                        if len(batch) &gt; 0 </span><span class="cov6" title="8">{
                                w.batchChan &lt;- batch
                                batch = make(map[string][]string)
                        }</span>
                }
        }
}

// batchProcessor обрабатывает пакеты задач, используя пул воркеров.
func (w *DeleteWorker) batchProcessor() <span class="cov7" title="14">{
        defer w.wg.Done()

        for batch := range w.batchChan </span><span class="cov6" title="8">{
                var batchWg sync.WaitGroup
                batchWg.Add(len(batch))

                concurrencyLimit := make(chan struct{}, w.workerCount*2)

                for userID, urls := range batch </span><span class="cov6" title="8">{
                        concurrencyLimit &lt;- struct{}{}

                        go func(userID string, urls []string) </span><span class="cov6" title="8">{
                                defer batchWg.Done()
                                defer func() </span><span class="cov6" title="8">{ &lt;-concurrencyLimit }</span>()

                                <span class="cov6" title="8">const subBatchSize = 50
                                for i := 0; i &lt; len(urls); i += subBatchSize </span><span class="cov6" title="8">{
                                        end := i + subBatchSize
                                        if end &gt; len(urls) </span><span class="cov6" title="8">{
                                                end = len(urls)
                                        }</span>
                                        <span class="cov6" title="8">subBatch := urls[i:end]

                                        if err := w.processUserBatch(userID, subBatch); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Ошибка при пометке URL как удалённых для пользователя %s: %v", userID, err)
                                        }</span>
                                }
                        }(userID, urls)
                }

                <span class="cov6" title="8">batchWg.Wait()</span>
        }
}

// processUserBatch выполняет пометку URL как удаленных в хранилище.
func (w *DeleteWorker) processUserBatch(userID string, urls []string) error <span class="cov6" title="8">{
        if err := w.repo.BatchMarkAsDeleted(userID, urls); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="8">return nil</span>
}

// GracefulStop выполняет плавное завершение работы с заданным таймаутом.
// Дожидается завершения обработки текущих задач или истечения таймаута.
func (w *DeleteWorker) GracefulStop(timeout time.Duration) <span class="cov0" title="0">{
        close(w.stopChan)

        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                w.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                log.Println("Все воркеры завершили работу")</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                log.Println("Таймаут ожидания завершения воркеров")</span>
        }

        <span class="cov0" title="0">close(w.taskChan)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package testconfig

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/docker/go-connections/nat"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/wait"
)

var (
        pgContainer testcontainers.Container
        pgDSN       string
        pgOnce      sync.Once
)

type PGConfig struct {
        Image    string
        User     string
        Password string
        DBName   string
        Port     string
}

func DefaultPGConfig() PGConfig <span class="cov8" title="1">{
        return PGConfig{
                Image:    "postgres:13-alpine",
                User:     "test",
                Password: "test",
                DBName:   "test",
                Port:     "5432",
        }
}</span>

func StartPGContainer(ctx context.Context, cfg PGConfig) (testcontainers.Container, string, error) <span class="cov8" title="1">{
        var startErr error
        pgOnce.Do(func() </span><span class="cov8" title="1">{

                // Конвертируем строку в nat.Port
                pgPort := nat.Port(cfg.Port + "/tcp") // Например: "5432" -&gt; "5432/tcp"
                req := testcontainers.ContainerRequest{
                        Image:        cfg.Image,
                        ExposedPorts: []string{string(pgPort)},
                        Env: map[string]string{
                                "POSTGRES_USER":     cfg.User,
                                "POSTGRES_PASSWORD": cfg.Password,
                                "POSTGRES_DB":       cfg.DBName,
                        },
                        WaitingFor: wait.ForAll(
                                wait.ForLog("database system is ready"),
                                wait.ForListeningPort(pgPort),
                                wait.ForSQL(
                                        pgPort,
                                        "postgres",
                                        func(host string, port nat.Port) string </span><span class="cov8" title="1">{
                                                return fmt.Sprintf("host=%s port=%s user=test password=test dbname=test sslmode=disable",
                                                        host, port.Port())
                                        }</span>).WithStartupTimeout(1*time.Minute).WithPollInterval(1*time.Second),
                        ).WithDeadline(1 * time.Minute),
                }

                <span class="cov8" title="1">pgContainer, startErr = testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
                        ContainerRequest: req,
                        Started:          true,
                })
                if startErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">mappedPort, err := pgContainer.MappedPort(ctx, pgPort)
                if err != nil </span><span class="cov0" title="0">{
                        startErr = err
                        return
                }</span>

                <span class="cov8" title="1">pgDSN = fmt.Sprintf("postgres://%s:%s@localhost:%s/%s?sslmode=disable",
                        cfg.User, cfg.Password, mappedPort.Port(), cfg.DBName)</span>
        })

        <span class="cov8" title="1">return pgContainer, pgDSN, startErr</span>
}

func GetTestPGDSN() string <span class="cov0" title="0">{
        return pgDSN
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package testutils

import (
        "net/http"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
)

// TestSecretKey содержит тестовый ключ для подписи JWT.
// Используется только в тестовой среде.
var TestSecretKey = []byte("test-secret-key")

// CreateSignedCookie создает тестовую HTTP-куку с подписанным JWT-токеном.
// Используется для симуляции аутентифицированных запросов в тестах.
func CreateSignedCookie() (*http.Cookie, string) <span class="cov10" title="19">{
        tokenString, userID, err := jwtauth.GenerateNewToken(TestSecretKey)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // В тестах допустим panic
        }

        <span class="cov10" title="19">return &amp;http.Cookie{
                Name:     "token",
                Value:    tokenString,
                HttpOnly: true,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
        }, userID</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package handlers

import (
        "bytes"
        "compress/gzip"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/service"

        "github.com/ryabkov82/shortener/internal/app/logger"

        "github.com/ryabkov82/shortener/internal/app/server/middleware/auth"
        mwlogger "github.com/ryabkov82/shortener/internal/app/server/middleware/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/mwgzip"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/ryabkov82/shortener/internal/app/handlers/batch"
        "github.com/ryabkov82/shortener/internal/app/models"

        "github.com/go-chi/chi/v5"
        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

func TestBatch(t *testing.T, st service.Repository) <span class="cov1" title="1">{

        service := service.NewService(st)

        if err := logger.Initialize("debug"); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov1" title="1">r := chi.NewRouter()
        r.Use(mwlogger.RequestLogging(logger.Log))
        r.Use(mwgzip.Gzip)
        r.Use(auth.JWTAutoIssue(testutils.TestSecretKey))

        baseURL := "http://localhost:8080/"
        r.Post("/api/shorten/batch", batch.GetHandler(service, baseURL, logger.Log))

        cookie, _ := testutils.CreateSignedCookie()

        // запускаем тестовый сервер, будет выбран первый свободный порт
        srv := httptest.NewServer(r)
        // останавливаем сервер после завершения теста
        defer srv.Close()
        tests := []struct {
                cookie         *http.Cookie
                name           string
                request        string
                wantStatusCode int
        }{
                {
                        name: "positive test #1",
                        request: `[
                                                                        {
                                                                                "correlation_id": "123",
                                                                                "original_url": "https://example.com/page1"
                                                                        },
                                                                        {
                                                                                "correlation_id": "456",
                                                                                "original_url": "https://example.com/page2"
                                                                        }
                                                                ]`,
                        cookie:         cookie,
                        wantStatusCode: 201,
                },
                {
                        name:           "negative test #2",
                        request:        "{}",
                        cookie:         cookie,
                        wantStatusCode: 400,
                },
        }
        for _, tt := range tests </span><span class="cov10" title="2">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov10" title="2">{

                        buf := bytes.NewBuffer(nil)
                        zb := gzip.NewWriter(buf)
                        _, err := zb.Write([]byte(tt.request))
                        assert.NoError(t, err)
                        err = zb.Close()
                        assert.NoError(t, err)

                        resp, err := resty.New().R().
                                SetBody(buf).
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                Post(srv.URL + "/api/shorten/batch")

                        assert.NoError(t, err)

                        // Проверяем статус ответа
                        assert.Equal(t, tt.wantStatusCode, resp.StatusCode())
                        if tt.wantStatusCode == 201 </span><span class="cov1" title="1">{
                                // проверим, что получили данные в нужном формате
                                var response []models.BatchResponse
                                err = json.Unmarshal(resp.Body(), &amp;response)
                                assert.NoError(t, err)
                        }</span>

                })
        }

}
</pre>
		
		<pre class="file" id="file29" style="display: none">package handlers

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "testing"
        "time"

        "github.com/stretchr/testify/assert"

        "github.com/ryabkov82/shortener/internal/app/models"

        "github.com/ryabkov82/shortener/internal/app/handlers/deluserurls"
        "github.com/ryabkov82/shortener/internal/app/handlers/redirect"
        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/auth"
        mwlogger "github.com/ryabkov82/shortener/internal/app/server/middleware/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/mwgzip"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-chi/chi/v5"
        "github.com/go-resty/resty/v2"
)

func TestDelUserUrls(t *testing.T, st service.Repository) <span class="cov1" title="1">{

        service := service.NewService(st)

        if err := logger.Initialize("debug"); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov1" title="1">r := chi.NewRouter()
        r.Use(mwlogger.RequestLogging(logger.Log))
        r.Use(mwgzip.Gzip)
        r.Use(auth.StrictJWTAutoIssue(testutils.TestSecretKey))

        baseURL := "http://localhost:8080/"
        r.Delete("/api/user/urls", deluserurls.GetHandler(service, baseURL, logger.Log))
        r.Get("/{id}", redirect.GetHandler(service, logger.Log))

        // запускаем тестовый сервер, будет выбран первый свободный порт
        srv := httptest.NewServer(r)
        // останавливаем сервер после завершения теста
        defer srv.Close()

        // Клиент resty
        client := resty.New().SetBaseURL(srv.URL)

        // Тестовые данные
        cookie1, user1 := testutils.CreateSignedCookie()
        cookie2, user2 := testutils.CreateSignedCookie()
        testURLs := []models.UserURLMapping{
                {UserID: user1, OriginalURL: "https://example.com/1"},
                {UserID: user1, OriginalURL: "https://example.com/2"},
                {UserID: user1, OriginalURL: "https://example.com/3"},
                {UserID: user1, OriginalURL: "https://example.com/4"},
                {UserID: user2, OriginalURL: "https://example.com/5"},
        }

        // Заполняем хранилище
        for i, url := range testURLs </span><span class="cov10" title="5">{
                ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, url.UserID)
                shortURL, err := service.GetShortKey(ctx, url.OriginalURL)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov10" title="5">testURLs[i].ShortURL = shortURL</span>
        }

        <span class="cov1" title="1">tests := []struct {
                cookie         *http.Cookie
                name           string
                userID         string
                codesToDelete  []string
                shouldBeMarked []string
                wantStatus     int
        }{
                {
                        name:           "successful deletion",
                        userID:         user1,
                        cookie:         cookie1,
                        codesToDelete:  []string{testURLs[0].ShortURL},
                        wantStatus:     http.StatusAccepted,
                        shouldBeMarked: []string{testURLs[0].ShortURL},
                },
                {
                        name:           "delete multiple",
                        userID:         user1,
                        cookie:         cookie1,
                        codesToDelete:  []string{testURLs[1].ShortURL, testURLs[2].ShortURL},
                        wantStatus:     http.StatusAccepted,
                        shouldBeMarked: []string{testURLs[1].ShortURL, testURLs[2].ShortURL},
                },
                {
                        name:           "delete non-existent",
                        userID:         user1,
                        cookie:         cookie1,
                        codesToDelete:  []string{"nonexistent"},
                        wantStatus:     http.StatusAccepted,
                        shouldBeMarked: []string{},
                },
                {
                        name:           "delete other user's url",
                        userID:         user2,
                        cookie:         cookie2,
                        codesToDelete:  []string{testURLs[3].ShortURL},
                        wantStatus:     http.StatusAccepted,
                        shouldBeMarked: []string{}, // Не должно пометить как удаленный
                },
        }
        for _, tt := range tests </span><span class="cov8" title="4">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov8" title="4">{

                        // Подготовка запроса
                        body, _ := json.Marshal(tt.codesToDelete)
                        buf := bytes.NewBuffer(nil)
                        zb := gzip.NewWriter(buf)
                        _, err := zb.Write([]byte(body))
                        assert.NoError(t, err)
                        err = zb.Close()
                        assert.NoError(t, err)

                        // Запрос
                        resp, err := client.R().
                                SetBody(buf).
                                SetCookie(tt.cookie).
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                Delete("/api/user/urls")

                        // Проверки
                        assert.NoError(t, err)
                        assert.Equal(t, tt.wantStatus, resp.StatusCode())

                        time.Sleep(500 * time.Millisecond)
                        // Проверка что URL помечены как удаленные
                        for _, code := range tt.codesToDelete </span><span class="cov10" title="5">{

                                resp, err := client.R().
                                        SetCookie(tt.cookie).
                                        Get("/" + code)

                                // Проверки
                                assert.NoError(t, err)
                                if resp.StatusCode() == http.StatusGone </span><span class="cov7" title="3">{
                                        assert.Contains(t, tt.shouldBeMarked, code)
                                }</span> else<span class="cov4" title="2"> {
                                        assert.NotContains(t, tt.shouldBeMarked, code)
                                }</span>

                        }
                })
        }

}
</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "context"
        "errors"
        "net/http"
        "net/http/httptest"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/logger"

        "github.com/ryabkov82/shortener/internal/app/handlers/redirect"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/auth"
        mwlogger "github.com/ryabkov82/shortener/internal/app/server/middleware/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/mwgzip"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-chi/chi/v5"
        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

func TestRedirect(t *testing.T, st service.Repository) <span class="cov1" title="1">{
        service := service.NewService(st)

        if err := logger.Initialize("debug"); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov1" title="1">mapping := models.URLMapping{
                ShortURL:    "EYm7J2zF",
                OriginalURL: "https://practicum.yandex.ru/",
        }

        r := chi.NewRouter()
        r.Use(mwlogger.RequestLogging(logger.Log))
        r.Use(mwgzip.Gzip)
        r.Use(auth.JWTAutoIssue(testutils.TestSecretKey))

        r.Get("/{id}", redirect.GetHandler(service, logger.Log))

        // запускаем тестовый сервер, будет выбран первый свободный порт
        srv := httptest.NewServer(r)
        // останавливаем сервер после завершения теста
        defer srv.Close()

        var redirectAttemptedError = errors.New("redirect")
        redirectPolicy := resty.RedirectPolicyFunc(func(req *http.Request, via []*http.Request) error </span><span class="cov1" title="1">{
                // return nil for continue redirect otherwise return error to stop/prevent redirect
                return redirectAttemptedError
        }</span>)

        <span class="cov1" title="1">cookie, userID := testutils.CreateSignedCookie()
        ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, userID)
        st.SaveURL(ctx, &amp;mapping)

        tests := []struct {
                cookie         *http.Cookie
                name           string
                originalURL    string
                shortKey       string
                wantStatusCode int
        }{
                {
                        name:           "positive test #1",
                        originalURL:    "https://practicum.yandex.ru/",
                        shortKey:       "EYm7J2zF",
                        cookie:         cookie,
                        wantStatusCode: 307,
                },
                {
                        name:           "negative test #2",
                        shortKey:       "RrixjW0q",
                        cookie:         cookie,
                        wantStatusCode: 404,
                },
        }
        for _, tt := range tests </span><span class="cov10" title="2">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov10" title="2">{

                        client := resty.New()
                        client.SetRedirectPolicy(redirectPolicy)
                        req := client.R().SetCookie(tt.cookie)
                        req.Method = http.MethodGet
                        req.URL = srv.URL + "/" + tt.shortKey

                        resp, err := req.Send()

                        if errors.Is(err, redirectAttemptedError) </span><span class="cov1" title="1">{
                                // эту ошибку игнорируем
                                err = nil
                        }</span>

                        <span class="cov10" title="2">assert.NoError(t, err)

                        // Проверяем статус ответа
                        assert.Equal(t, tt.wantStatusCode, resp.StatusCode())
                        if tt.wantStatusCode == 307 </span><span class="cov1" title="1">{
                                assert.Equal(t, tt.originalURL, resp.Header().Get("Location"))
                        }</span>
                })
        }

}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "bytes"
        "compress/gzip"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "net/url"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/logger"

        "github.com/ryabkov82/shortener/internal/app/service"

        "github.com/ryabkov82/shortener/internal/app/handlers/shortenapi"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/auth"
        mwlogger "github.com/ryabkov82/shortener/internal/app/server/middleware/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/mwgzip"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-chi/chi/v5"
        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

func TestShortenAPI(t *testing.T, st service.Repository) <span class="cov1" title="1">{

        service := service.NewService(st)

        if err := logger.Initialize("debug"); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov1" title="1">r := chi.NewRouter()
        r.Use(mwlogger.RequestLogging(logger.Log))
        r.Use(mwgzip.Gzip)
        r.Use(auth.JWTAutoIssue(testutils.TestSecretKey))

        cookie, _ := testutils.CreateSignedCookie()

        baseURL := "http://localhost:8080/"
        r.Post("/api/shorten", shortenapi.GetHandler(service, baseURL, logger.Log))

        // запускаем тестовый сервер, будет выбран первый свободный порт
        srv := httptest.NewServer(r)
        // останавливаем сервер после завершения теста
        defer srv.Close()

        tests := []struct {
                cookie         *http.Cookie
                name           string
                request        shortenapi.Request
                wantStatusCode int
        }{
                {
                        name:           "positive test #1",
                        request:        shortenapi.Request{URL: "https://practicum.yandex.ru/"},
                        cookie:         cookie,
                        wantStatusCode: 201,
                },
                {
                        name:           "positive test #2",
                        request:        shortenapi.Request{URL: "https://practicum.yandex.ru/"},
                        cookie:         cookie,
                        wantStatusCode: 409,
                },
                {
                        name:           "negative test #2",
                        request:        shortenapi.Request{URL: "not url"},
                        cookie:         cookie,
                        wantStatusCode: 400,
                },
        }

        for _, tt := range tests </span><span class="cov10" title="3">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov10" title="3">{

                        req, err := json.Marshal(tt.request)
                        assert.NoError(t, err)

                        buf := bytes.NewBuffer(nil)
                        zb := gzip.NewWriter(buf)
                        _, err = zb.Write([]byte(req))
                        assert.NoError(t, err)
                        err = zb.Close()
                        assert.NoError(t, err)

                        resp, err := resty.New().R().
                                SetCookie(tt.cookie).
                                SetBody(buf).
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                Post(srv.URL + "/api/shorten")

                        assert.NoError(t, err)

                        // Проверяем статус ответа
                        assert.Equal(t, tt.wantStatusCode, resp.StatusCode())
                        if tt.wantStatusCode == 201 </span><span class="cov1" title="1">{
                                var response shortenapi.Response
                                err = json.Unmarshal(resp.Body(), &amp;response)
                                assert.NoError(t, err)
                                shortURL := response.Result
                                // Проверяем, что получен URL
                                _, err = url.Parse(shortURL)
                                assert.NoError(t, err)
                        }</span>
                })
        }

}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "net/http"
        "net/http/httptest"
        "net/url"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/handlers/shorturl"
        "github.com/ryabkov82/shortener/internal/app/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/auth"
        mwlogger "github.com/ryabkov82/shortener/internal/app/server/middleware/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/mwgzip"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-chi/chi/v5"
        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

func TestShortenURL(t *testing.T, st service.Repository) <span class="cov1" title="1">{

        service := service.NewService(st)

        if err := logger.Initialize("debug"); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov1" title="1">r := chi.NewRouter()
        r.Use(mwlogger.RequestLogging(logger.Log))
        r.Use(mwgzip.Gzip)
        r.Use(auth.JWTAutoIssue(testutils.TestSecretKey))

        baseURL := "http://localhost:8080/"
        r.Post("/", shorturl.GetHandler(service, baseURL, logger.Log))

        // запускаем тестовый сервер, будет выбран первый свободный порт
        srv := httptest.NewServer(r)
        // останавливаем сервер после завершения теста
        defer srv.Close()

        cookie, _ := testutils.CreateSignedCookie()

        tests := []struct {
                cookie         *http.Cookie
                name           string
                originalURL    string
                wantStatusCode int
        }{
                {
                        name:           "positive test #1",
                        originalURL:    "https://practicum.yandex.ru/",
                        cookie:         cookie,
                        wantStatusCode: 201,
                },
                {
                        name:           "positive test #1",
                        originalURL:    "https://practicum.yandex.ru/",
                        cookie:         cookie,
                        wantStatusCode: 409,
                },
                {
                        name:           "negative test #2",
                        originalURL:    "not url",
                        cookie:         cookie,
                        wantStatusCode: 400,
                },
        }

        for _, tt := range tests </span><span class="cov10" title="3">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov10" title="3">{

                        resp, err := resty.New().R().
                                SetCookie(tt.cookie).
                                SetBody(tt.originalURL).
                                Post(srv.URL)

                        assert.NoError(t, err)

                        // Проверяем статус ответа
                        assert.Equal(t, tt.wantStatusCode, resp.StatusCode())
                        if tt.wantStatusCode == 201 </span><span class="cov1" title="1">{
                                shortURL := resp.Body()
                                // Проверяем, что получен URL
                                _, err = url.Parse(string(shortURL))
                                assert.NoError(t, err)
                        }</span>
                })
        }

}
</pre>
		
		<pre class="file" id="file33" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/models"

        "github.com/ryabkov82/shortener/internal/app/handlers/userurls"
        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/auth"
        mwlogger "github.com/ryabkov82/shortener/internal/app/server/middleware/logger"
        "github.com/ryabkov82/shortener/internal/app/server/middleware/mwgzip"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-chi/chi/v5"
        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

func TestUserUrls(t *testing.T, st service.Repository) <span class="cov1" title="1">{

        service := service.NewService(st)

        if err := logger.Initialize("debug"); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov1" title="1">r := chi.NewRouter()
        r.Use(mwlogger.RequestLogging(logger.Log))
        r.Use(mwgzip.Gzip)
        r.Use(auth.StrictJWTAutoIssue(testutils.TestSecretKey))

        baseURL := "http://localhost:8080/"
        r.Get("/api/user/urls", userurls.GetHandler(service, baseURL, logger.Log))

        // запускаем тестовый сервер, будет выбран первый свободный порт
        srv := httptest.NewServer(r)
        // останавливаем сервер после завершения теста
        defer srv.Close()

        // Клиент resty
        client := resty.New().SetBaseURL(srv.URL)

        // Тестовые данные
        cookie1, user1 := testutils.CreateSignedCookie()
        _, user2 := testutils.CreateSignedCookie()
        testURLs := []models.UserURLMapping{
                {UserID: user1, OriginalURL: "https://example.com/1"},
                {UserID: user1, OriginalURL: "https://example.com/2"},
                {UserID: user2, OriginalURL: "https://example.com/3"},
        }

        // Заполняем хранилище
        for _, url := range testURLs </span><span class="cov10" title="3">{
                ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, url.UserID)
                _, err := service.GetShortKey(ctx, url.OriginalURL)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                // url.ShortURL = shortURL
        }

        <span class="cov1" title="1">t.Run("Успешное получение ссылок пользователя", func(t *testing.T) </span><span class="cov1" title="1">{

                // Запрос
                resp, err := client.R().
                        SetCookie(cookie1).
                        Get("/api/user/urls")

                // Проверки
                assert.NoError(t, err)
                assert.Equal(t, http.StatusOK, resp.StatusCode())

                var urls []models.URLMapping
                err = json.Unmarshal(resp.Body(), &amp;urls)
                assert.NoError(t, err)
                assert.Len(t, urls, 2) // user1 имеет 2 ссылки

        }</span>)
        <span class="cov1" title="1">t.Run("Пустой результат для нового пользователя", func(t *testing.T) </span><span class="cov1" title="1">{
                cookie, _ := testutils.CreateSignedCookie()

                resp, err := client.R().
                        SetCookie(cookie).
                        Get("/api/user/urls")

                assert.NoError(t, err)
                assert.Equal(t, http.StatusNoContent, resp.StatusCode())

        }</span>)

        <span class="cov1" title="1">t.Run("Ошибка без куки", func(t *testing.T) </span><span class="cov1" title="1">{
                resp, err := client.R().
                        Get("/api/user/urls")

                assert.NoError(t, err)
                assert.Equal(t, http.StatusUnauthorized, resp.StatusCode())

                // Проверяем что установлена новая кука
                assert.NotEmpty(t, resp.Cookies())
        }</span>)

}
</pre>
		
		<pre class="file" id="file34" style="display: none">package testutils

import (
        "os"
        "path/filepath"

        storage "github.com/ryabkov82/shortener/internal/app/storage/inmemory"
)

func InitializeInMemoryStorage() (*storage.InMemoryStorage, error) <span class="cov10" title="6">{

        // Для общих testdata проекта
        globalData, err := GetGlobalTestDataPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="6">fileStorage := filepath.Join(globalData, "test.dat")

        _ = os.Remove(fileStorage)

        st, err := storage.NewInMemoryStorage(fileStorage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="6">st.Load(fileStorage)

        return st, nil</span>

}
</pre>
		
		<pre class="file" id="file35" style="display: none">package testutils

import (
        "os/exec"
        "path/filepath"
        "strings"
)

// GetModuleRoot возвращает абсолютный путь к корневой директории Go-модуля.
// Использует команду 'go list -m'. Может возвращать ошибку, если команда
// не выполнена или модуль не инициализирован.
func GetModuleRoot() (string, error) <span class="cov10" title="6">{
        out, err := exec.Command("go", "list", "-m", "-f", "{{.Dir}}").Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="6">return strings.TrimSpace(string(out)), nil</span>
}

// GetGlobalTestDataPath возвращает путь к общей папке testdata проекта
func GetGlobalTestDataPath() (string, error) <span class="cov10" title="6">{
        root, err := GetModuleRoot()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="6">return filepath.Join(root, "test", "testdata"), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
