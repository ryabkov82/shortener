
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ryabkov82/shortener/api/shortener.pb.go (58.4%)</option>
				
				<option value="file1">github.com/ryabkov82/shortener/api/shortener_grpc.pb.go (79.3%)</option>
				
				<option value="file2">github.com/ryabkov82/shortener/cmd/client/main.go (0.0%)</option>
				
				<option value="file3">github.com/ryabkov82/shortener/cmd/genserver/genserver.go (0.0%)</option>
				
				<option value="file4">github.com/ryabkov82/shortener/cmd/shortener/main.go (0.0%)</option>
				
				<option value="file5">github.com/ryabkov82/shortener/cmd/staticlint/main.go (93.1%)</option>
				
				<option value="file6">github.com/ryabkov82/shortener/cmd/staticlint/noosexit/analyzer.go (83.3%)</option>
				
				<option value="file7">github.com/ryabkov82/shortener/internal/app/config/config.go (75.3%)</option>
				
				<option value="file8">github.com/ryabkov82/shortener/internal/app/handlers/grpc/base/handler.go (50.0%)</option>
				
				<option value="file9">github.com/ryabkov82/shortener/internal/app/handlers/grpc/batch/batch.go (75.0%)</option>
				
				<option value="file10">github.com/ryabkov82/shortener/internal/app/handlers/grpc/deluserurls/deluserurls.go (60.0%)</option>
				
				<option value="file11">github.com/ryabkov82/shortener/internal/app/handlers/grpc/ping/ping.go (100.0%)</option>
				
				<option value="file12">github.com/ryabkov82/shortener/internal/app/handlers/grpc/redirect/redirect.go (62.5%)</option>
				
				<option value="file13">github.com/ryabkov82/shortener/internal/app/handlers/grpc/server_gen.go (82.1%)</option>
				
				<option value="file14">github.com/ryabkov82/shortener/internal/app/handlers/grpc/shorturl/shorturl.go (77.8%)</option>
				
				<option value="file15">github.com/ryabkov82/shortener/internal/app/handlers/grpc/stats/stats.go (100.0%)</option>
				
				<option value="file16">github.com/ryabkov82/shortener/internal/app/handlers/grpc/userurls/userurls.go (85.7%)</option>
				
				<option value="file17">github.com/ryabkov82/shortener/internal/app/handlers/http/batch/batch.go (71.4%)</option>
				
				<option value="file18">github.com/ryabkov82/shortener/internal/app/handlers/http/deluserurls/deluserurls.go (54.5%)</option>
				
				<option value="file19">github.com/ryabkov82/shortener/internal/app/handlers/http/ping/ping.go (100.0%)</option>
				
				<option value="file20">github.com/ryabkov82/shortener/internal/app/handlers/http/redirect/redirect.go (61.1%)</option>
				
				<option value="file21">github.com/ryabkov82/shortener/internal/app/handlers/http/shortenapi/shortenapi.go (66.7%)</option>
				
				<option value="file22">github.com/ryabkov82/shortener/internal/app/handlers/http/shorturl/shorturl.go (67.7%)</option>
				
				<option value="file23">github.com/ryabkov82/shortener/internal/app/handlers/http/stats/stats.go (91.7%)</option>
				
				<option value="file24">github.com/ryabkov82/shortener/internal/app/handlers/http/userurls/userurls.go (76.5%)</option>
				
				<option value="file25">github.com/ryabkov82/shortener/internal/app/httpgzip/httpgzip.go (92.6%)</option>
				
				<option value="file26">github.com/ryabkov82/shortener/internal/app/jwtauth/jwtauth.go (100.0%)</option>
				
				<option value="file27">github.com/ryabkov82/shortener/internal/app/logger/logger.go (80.0%)</option>
				
				<option value="file28">github.com/ryabkov82/shortener/internal/app/pprof/routes.go (77.4%)</option>
				
				<option value="file29">github.com/ryabkov82/shortener/internal/app/server/grpc/interceptors/jwt_auth.go (34.8%)</option>
				
				<option value="file30">github.com/ryabkov82/shortener/internal/app/server/grpc/interceptors/logger.go (100.0%)</option>
				
				<option value="file31">github.com/ryabkov82/shortener/internal/app/server/grpc/interceptors/trusted_subnet.go (61.8%)</option>
				
				<option value="file32">github.com/ryabkov82/shortener/internal/app/server/grpc/server.go (0.0%)</option>
				
				<option value="file33">github.com/ryabkov82/shortener/internal/app/server/http/middleware/auth/auth.go (77.4%)</option>
				
				<option value="file34">github.com/ryabkov82/shortener/internal/app/server/http/middleware/logger/logger.go (100.0%)</option>
				
				<option value="file35">github.com/ryabkov82/shortener/internal/app/server/http/middleware/mwgzip/mwgzip.go (89.5%)</option>
				
				<option value="file36">github.com/ryabkov82/shortener/internal/app/server/http/middleware/trustednet/trustednet.go (77.8%)</option>
				
				<option value="file37">github.com/ryabkov82/shortener/internal/app/server/http/server.go (0.0%)</option>
				
				<option value="file38">github.com/ryabkov82/shortener/internal/app/server/run.go (0.0%)</option>
				
				<option value="file39">github.com/ryabkov82/shortener/internal/app/service/mocks/Repository.go (48.7%)</option>
				
				<option value="file40">github.com/ryabkov82/shortener/internal/app/service/service.go (87.2%)</option>
				
				<option value="file41">github.com/ryabkov82/shortener/internal/app/storage/inmemory/inmemory.go (63.0%)</option>
				
				<option value="file42">github.com/ryabkov82/shortener/internal/app/storage/postgres/migrate.go (66.7%)</option>
				
				<option value="file43">github.com/ryabkov82/shortener/internal/app/storage/postgres/postgres.go (64.6%)</option>
				
				<option value="file44">github.com/ryabkov82/shortener/internal/app/workers/deleteurls/deleteworker.go (63.1%)</option>
				
				<option value="file45">github.com/ryabkov82/shortener/test/testconfig/postgres.go (75.0%)</option>
				
				<option value="file46">github.com/ryabkov82/shortener/test/testhandlers/batch_grpc_tests.go (77.8%)</option>
				
				<option value="file47">github.com/ryabkov82/shortener/test/testhandlers/batch_http_tests.go (100.0%)</option>
				
				<option value="file48">github.com/ryabkov82/shortener/test/testhandlers/common_cases.go (84.6%)</option>
				
				<option value="file49">github.com/ryabkov82/shortener/test/testhandlers/deluserurls_tests.go (95.1%)</option>
				
				<option value="file50">github.com/ryabkov82/shortener/test/testhandlers/redirect_grpc_tests.go (95.5%)</option>
				
				<option value="file51">github.com/ryabkov82/shortener/test/testhandlers/redirect_http_tests.go (100.0%)</option>
				
				<option value="file52">github.com/ryabkov82/shortener/test/testhandlers/shortenapi_tests.go (100.0%)</option>
				
				<option value="file53">github.com/ryabkov82/shortener/test/testhandlers/shorturl_grpc_tests.go (94.7%)</option>
				
				<option value="file54">github.com/ryabkov82/shortener/test/testhandlers/shorturl_http_tests.go (100.0%)</option>
				
				<option value="file55">github.com/ryabkov82/shortener/test/testhandlers/userurls_tests.go (96.3%)</option>
				
				<option value="file56">github.com/ryabkov82/shortener/test/testutils/auth.go (29.6%)</option>
				
				<option value="file57">github.com/ryabkov82/shortener/test/testutils/client.go (100.0%)</option>
				
				<option value="file58">github.com/ryabkov82/shortener/test/testutils/grpc_client.go (88.6%)</option>
				
				<option value="file59">github.com/ryabkov82/shortener/test/testutils/inmemory.go (77.8%)</option>
				
				<option value="file60">github.com/ryabkov82/shortener/test/testutils/paths.go (75.0%)</option>
				
				<option value="file61">github.com/ryabkov82/shortener/test/testutils/status.go (42.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v6.31.1
// source: api/shortener.proto

package api

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OriginalUrl   string                 `protobuf:"bytes,1,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateRequest) Reset() <span class="cov3" title="3">{
        *x = CreateRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateRequest) String() string <span class="cov3" title="3">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateRequest) ProtoReflect() protoreflect.Message <span class="cov7" title="12">{
        mi := &amp;file_api_shortener_proto_msgTypes[0]
        if x != nil </span><span class="cov7" title="12">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov5" title="6">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov7" title="12">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateRequest.ProtoReflect.Descriptor instead.
func (*CreateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateRequest) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortUrl      string                 `protobuf:"bytes,1,opt,name=short_url,json=shortUrl,proto3" json:"short_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateResponse) Reset() <span class="cov1" title="1">{
        *x = CreateResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateResponse) ProtoReflect() protoreflect.Message <span class="cov2" title="2">{
        mi := &amp;file_api_shortener_proto_msgTypes[1]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateResponse.ProtoReflect.Descriptor instead.
func (*CreateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateResponse) GetShortUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortUrl      string                 `protobuf:"bytes,1,opt,name=short_url,json=shortUrl,proto3" json:"short_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() <span class="cov6" title="7">{
        *x = GetRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetRequest) String() string <span class="cov6" title="7">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetRequest) ProtoReflect() protoreflect.Message <span class="cov10" title="28">{
        mi := &amp;file_api_shortener_proto_msgTypes[2]
        if x != nil </span><span class="cov10" title="28">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="14">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov10" title="28">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetRequest) GetShortUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OriginalUrl   string                 `protobuf:"bytes,1,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        Deleted       bool                   `protobuf:"varint,2,opt,name=deleted,proto3" json:"deleted,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() <span class="cov2" title="2">{
        *x = GetResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetResponse) ProtoReflect() protoreflect.Message <span class="cov4" title="4">{
        mi := &amp;file_api_shortener_proto_msgTypes[3]
        if x != nil </span><span class="cov4" title="4">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov4" title="4">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov4" title="4">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetResponse) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetResponse) GetDeleted() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Deleted
        }</span>
        <span class="cov0" title="0">return false</span>
}

type PingRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PingRequest) Reset() <span class="cov2" title="2">{
        *x = PingRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingRequest) String() string <span class="cov2" title="2">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingRequest) ProtoReflect() protoreflect.Message <span class="cov7" title="10">{
        mi := &amp;file_api_shortener_proto_msgTypes[4]
        if x != nil </span><span class="cov7" title="10">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov4" title="4">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov7" title="10">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingRequest.ProtoReflect.Descriptor instead.
func (*PingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{4}
}</span>

type PingResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Ok            bool                   `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PingResponse) Reset() <span class="cov1" title="1">{
        *x = PingResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingResponse) ProtoReflect() protoreflect.Message <span class="cov2" title="2">{
        mi := &amp;file_api_shortener_proto_msgTypes[5]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingResponse.ProtoReflect.Descriptor instead.
func (*PingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{5}
}</span>

func (x *PingResponse) GetOk() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ok
        }</span>
        <span class="cov0" title="0">return false</span>
}

type StatsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatsRequest) Reset() <span class="cov4" title="4">{
        *x = StatsRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsRequest) String() string <span class="cov4" title="4">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsRequest) ProtoReflect() protoreflect.Message <span class="cov9" title="20">{
        mi := &amp;file_api_shortener_proto_msgTypes[6]
        if x != nil </span><span class="cov9" title="20">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov6" title="8">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov9" title="20">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsRequest.ProtoReflect.Descriptor instead.
func (*StatsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{6}
}</span>

type StatsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Urls          int64                  `protobuf:"varint,1,opt,name=urls,proto3" json:"urls,omitempty"`
        Users         int64                  `protobuf:"varint,2,opt,name=users,proto3" json:"users,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatsResponse) Reset() <span class="cov1" title="1">{
        *x = StatsResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsResponse) ProtoReflect() protoreflect.Message <span class="cov2" title="2">{
        mi := &amp;file_api_shortener_proto_msgTypes[7]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsResponse.ProtoReflect.Descriptor instead.
func (*StatsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{7}
}</span>

func (x *StatsResponse) GetUrls() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Urls
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetUsers() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Users
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UserURLsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UserURLsRequest) Reset() <span class="cov2" title="2">{
        *x = UserURLsRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserURLsRequest) String() string <span class="cov2" title="2">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserURLsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserURLsRequest) ProtoReflect() protoreflect.Message <span class="cov7" title="10">{
        mi := &amp;file_api_shortener_proto_msgTypes[8]
        if x != nil </span><span class="cov7" title="10">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov4" title="4">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov7" title="10">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserURLsRequest.ProtoReflect.Descriptor instead.
func (*UserURLsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{8}
}</span>

type UserURLsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Urls          []*UserURL             `protobuf:"bytes,1,rep,name=urls,proto3" json:"urls,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UserURLsResponse) Reset() <span class="cov2" title="2">{
        *x = UserURLsResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserURLsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserURLsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserURLsResponse) ProtoReflect() protoreflect.Message <span class="cov5" title="5">{
        mi := &amp;file_api_shortener_proto_msgTypes[9]
        if x != nil </span><span class="cov5" title="5">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov4" title="4">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov5" title="5">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserURLsResponse.ProtoReflect.Descriptor instead.
func (*UserURLsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{9}
}</span>

func (x *UserURLsResponse) GetUrls() []*UserURL <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Urls
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UserURL struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortUrl      string                 `protobuf:"bytes,1,opt,name=short_url,json=shortUrl,proto3" json:"short_url,omitempty"`
        OriginalUrl   string                 `protobuf:"bytes,2,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UserURL) Reset() <span class="cov0" title="0">{
        *x = UserURL{}
        mi := &amp;file_api_shortener_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserURL) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserURL) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserURL) ProtoReflect() protoreflect.Message <span class="cov3" title="3">{
        mi := &amp;file_api_shortener_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov3" title="3">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserURL.ProtoReflect.Descriptor instead.
func (*UserURL) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{10}
}</span>

func (x *UserURL) GetShortUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserURL) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortUrls     []string               `protobuf:"bytes,1,rep,name=short_urls,json=shortUrls,proto3" json:"short_urls,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteRequest) Reset() <span class="cov4" title="4">{
        *x = DeleteRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteRequest) String() string <span class="cov4" title="4">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteRequest) ProtoReflect() protoreflect.Message <span class="cov8" title="16">{
        mi := &amp;file_api_shortener_proto_msgTypes[11]
        if x != nil </span><span class="cov8" title="16">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov6" title="8">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="16">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteRequest.ProtoReflect.Descriptor instead.
func (*DeleteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{11}
}</span>

func (x *DeleteRequest) GetShortUrls() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrls
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteResponse) Reset() <span class="cov4" title="4">{
        *x = DeleteResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteResponse) ProtoReflect() protoreflect.Message <span class="cov7" title="12">{
        mi := &amp;file_api_shortener_proto_msgTypes[12]
        if x != nil </span><span class="cov7" title="12">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov6" title="8">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov7" title="12">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteResponse.ProtoReflect.Descriptor instead.
func (*DeleteResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{12}
}</span>

type BatchCreateRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*BatchCreateItem     `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchCreateRequest) Reset() <span class="cov1" title="1">{
        *x = BatchCreateRequest{}
        mi := &amp;file_api_shortener_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchCreateRequest) String() string <span class="cov1" title="1">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchCreateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchCreateRequest) ProtoReflect() protoreflect.Message <span class="cov4" title="4">{
        mi := &amp;file_api_shortener_proto_msgTypes[13]
        if x != nil </span><span class="cov4" title="4">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov4" title="4">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchCreateRequest.ProtoReflect.Descriptor instead.
func (*BatchCreateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{13}
}</span>

func (x *BatchCreateRequest) GetItems() []*BatchCreateItem <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchCreateItem struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        CorrelationId string                 `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
        OriginalUrl   string                 `protobuf:"bytes,2,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchCreateItem) Reset() <span class="cov0" title="0">{
        *x = BatchCreateItem{}
        mi := &amp;file_api_shortener_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchCreateItem) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchCreateItem) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchCreateItem) ProtoReflect() protoreflect.Message <span class="cov5" title="5">{
        mi := &amp;file_api_shortener_proto_msgTypes[14]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov3" title="3">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchCreateItem.ProtoReflect.Descriptor instead.
func (*BatchCreateItem) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{14}
}</span>

func (x *BatchCreateItem) GetCorrelationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CorrelationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BatchCreateItem) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BatchCreateResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*BatchCreateResult   `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchCreateResponse) Reset() <span class="cov1" title="1">{
        *x = BatchCreateResponse{}
        mi := &amp;file_api_shortener_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchCreateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchCreateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchCreateResponse) ProtoReflect() protoreflect.Message <span class="cov2" title="2">{
        mi := &amp;file_api_shortener_proto_msgTypes[15]
        if x != nil </span><span class="cov2" title="2">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov2" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov2" title="2">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchCreateResponse.ProtoReflect.Descriptor instead.
func (*BatchCreateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{15}
}</span>

func (x *BatchCreateResponse) GetItems() []*BatchCreateResult <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchCreateResult struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        CorrelationId string                 `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
        ShortUrl      string                 `protobuf:"bytes,2,opt,name=short_url,json=shortUrl,proto3" json:"short_url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchCreateResult) Reset() <span class="cov0" title="0">{
        *x = BatchCreateResult{}
        mi := &amp;file_api_shortener_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchCreateResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchCreateResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchCreateResult) ProtoReflect() protoreflect.Message <span class="cov3" title="3">{
        mi := &amp;file_api_shortener_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov3" title="3">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchCreateResult.ProtoReflect.Descriptor instead.
func (*BatchCreateResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_shortener_proto_rawDescGZIP(), []int{16}
}</span>

func (x *BatchCreateResult) GetCorrelationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CorrelationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BatchCreateResult) GetShortUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_api_shortener_proto protoreflect.FileDescriptor

const file_api_shortener_proto_rawDesc = "" +
        "\n" +
        "\x13api/shortener.proto\x12\tshortener\"2\n" +
        "\rCreateRequest\x12!\n" +
        "\foriginal_url\x18\x01 \x01(\tR\voriginalUrl\"-\n" +
        "\x0eCreateResponse\x12\x1b\n" +
        "\tshort_url\x18\x01 \x01(\tR\bshortUrl\")\n" +
        "\n" +
        "GetRequest\x12\x1b\n" +
        "\tshort_url\x18\x01 \x01(\tR\bshortUrl\"J\n" +
        "\vGetResponse\x12!\n" +
        "\foriginal_url\x18\x01 \x01(\tR\voriginalUrl\x12\x18\n" +
        "\adeleted\x18\x02 \x01(\bR\adeleted\"\r\n" +
        "\vPingRequest\"\x1e\n" +
        "\fPingResponse\x12\x0e\n" +
        "\x02ok\x18\x01 \x01(\bR\x02ok\"\x0e\n" +
        "\fStatsRequest\"9\n" +
        "\rStatsResponse\x12\x12\n" +
        "\x04urls\x18\x01 \x01(\x03R\x04urls\x12\x14\n" +
        "\x05users\x18\x02 \x01(\x03R\x05users\"\x11\n" +
        "\x0fUserURLsRequest\":\n" +
        "\x10UserURLsResponse\x12&amp;\n" +
        "\x04urls\x18\x01 \x03(\v2\x12.shortener.UserURLR\x04urls\"I\n" +
        "\aUserURL\x12\x1b\n" +
        "\tshort_url\x18\x01 \x01(\tR\bshortUrl\x12!\n" +
        "\foriginal_url\x18\x02 \x01(\tR\voriginalUrl\".\n" +
        "\rDeleteRequest\x12\x1d\n" +
        "\n" +
        "short_urls\x18\x01 \x03(\tR\tshortUrls\"\x10\n" +
        "\x0eDeleteResponse\"F\n" +
        "\x12BatchCreateRequest\x120\n" +
        "\x05items\x18\x01 \x03(\v2\x1a.shortener.BatchCreateItemR\x05items\"[\n" +
        "\x0fBatchCreateItem\x12%\n" +
        "\x0ecorrelation_id\x18\x01 \x01(\tR\rcorrelationId\x12!\n" +
        "\foriginal_url\x18\x02 \x01(\tR\voriginalUrl\"I\n" +
        "\x13BatchCreateResponse\x122\n" +
        "\x05items\x18\x01 \x03(\v2\x1c.shortener.BatchCreateResultR\x05items\"W\n" +
        "\x11BatchCreateResult\x12%\n" +
        "\x0ecorrelation_id\x18\x01 \x01(\tR\rcorrelationId\x12\x1b\n" +
        "\tshort_url\x18\x02 \x01(\tR\bshortUrl2\xe8\x03\n" +
        "\tShortener\x12E\n" +
        "\x0eCreateShortURL\x12\x18.shortener.CreateRequest\x1a\x19.shortener.CreateResponse\x12?\n" +
        "\x0eGetOriginalURL\x12\x15.shortener.GetRequest\x1a\x16.shortener.GetResponse\x127\n" +
        "\x04Ping\x12\x16.shortener.PingRequest\x1a\x17.shortener.PingResponse\x12=\n" +
        "\bGetStats\x12\x17.shortener.StatsRequest\x1a\x18.shortener.StatsResponse\x12F\n" +
        "\vGetUserURLs\x12\x1a.shortener.UserURLsRequest\x1a\x1b.shortener.UserURLsResponse\x12E\n" +
        "\x0eDeleteUserURLs\x12\x18.shortener.DeleteRequest\x1a\x19.shortener.DeleteResponse\x12L\n" +
        "\vBatchCreate\x12\x1d.shortener.BatchCreateRequest\x1a\x1e.shortener.BatchCreateResponseB(Z&amp;github.com/ryabkov82/shortener/api;apib\x06proto3"

var (
        file_api_shortener_proto_rawDescOnce sync.Once
        file_api_shortener_proto_rawDescData []byte
)

func file_api_shortener_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_shortener_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_shortener_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_shortener_proto_rawDesc), len(file_api_shortener_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_api_shortener_proto_rawDescData</span>
}

var file_api_shortener_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_api_shortener_proto_goTypes = []any{
        (*CreateRequest)(nil),       // 0: shortener.CreateRequest
        (*CreateResponse)(nil),      // 1: shortener.CreateResponse
        (*GetRequest)(nil),          // 2: shortener.GetRequest
        (*GetResponse)(nil),         // 3: shortener.GetResponse
        (*PingRequest)(nil),         // 4: shortener.PingRequest
        (*PingResponse)(nil),        // 5: shortener.PingResponse
        (*StatsRequest)(nil),        // 6: shortener.StatsRequest
        (*StatsResponse)(nil),       // 7: shortener.StatsResponse
        (*UserURLsRequest)(nil),     // 8: shortener.UserURLsRequest
        (*UserURLsResponse)(nil),    // 9: shortener.UserURLsResponse
        (*UserURL)(nil),             // 10: shortener.UserURL
        (*DeleteRequest)(nil),       // 11: shortener.DeleteRequest
        (*DeleteResponse)(nil),      // 12: shortener.DeleteResponse
        (*BatchCreateRequest)(nil),  // 13: shortener.BatchCreateRequest
        (*BatchCreateItem)(nil),     // 14: shortener.BatchCreateItem
        (*BatchCreateResponse)(nil), // 15: shortener.BatchCreateResponse
        (*BatchCreateResult)(nil),   // 16: shortener.BatchCreateResult
}
var file_api_shortener_proto_depIdxs = []int32{
        10, // 0: shortener.UserURLsResponse.urls:type_name -&gt; shortener.UserURL
        14, // 1: shortener.BatchCreateRequest.items:type_name -&gt; shortener.BatchCreateItem
        16, // 2: shortener.BatchCreateResponse.items:type_name -&gt; shortener.BatchCreateResult
        0,  // 3: shortener.Shortener.CreateShortURL:input_type -&gt; shortener.CreateRequest
        2,  // 4: shortener.Shortener.GetOriginalURL:input_type -&gt; shortener.GetRequest
        4,  // 5: shortener.Shortener.Ping:input_type -&gt; shortener.PingRequest
        6,  // 6: shortener.Shortener.GetStats:input_type -&gt; shortener.StatsRequest
        8,  // 7: shortener.Shortener.GetUserURLs:input_type -&gt; shortener.UserURLsRequest
        11, // 8: shortener.Shortener.DeleteUserURLs:input_type -&gt; shortener.DeleteRequest
        13, // 9: shortener.Shortener.BatchCreate:input_type -&gt; shortener.BatchCreateRequest
        1,  // 10: shortener.Shortener.CreateShortURL:output_type -&gt; shortener.CreateResponse
        3,  // 11: shortener.Shortener.GetOriginalURL:output_type -&gt; shortener.GetResponse
        5,  // 12: shortener.Shortener.Ping:output_type -&gt; shortener.PingResponse
        7,  // 13: shortener.Shortener.GetStats:output_type -&gt; shortener.StatsResponse
        9,  // 14: shortener.Shortener.GetUserURLs:output_type -&gt; shortener.UserURLsResponse
        12, // 15: shortener.Shortener.DeleteUserURLs:output_type -&gt; shortener.DeleteResponse
        15, // 16: shortener.Shortener.BatchCreate:output_type -&gt; shortener.BatchCreateResponse
        10, // [10:17] is the sub-list for method output_type
        3,  // [3:10] is the sub-list for method input_type
        3,  // [3:3] is the sub-list for extension type_name
        3,  // [3:3] is the sub-list for extension extendee
        0,  // [0:3] is the sub-list for field type_name
}

func init() <span class="cov8" title="14">{ file_api_shortener_proto_init() }</span>
func file_api_shortener_proto_init() <span class="cov8" title="14">{
        if File_api_shortener_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="14">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_shortener_proto_rawDesc), len(file_api_shortener_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   17,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_shortener_proto_goTypes,
                DependencyIndexes: file_api_shortener_proto_depIdxs,
                MessageInfos:      file_api_shortener_proto_msgTypes,
        }.Build()
        File_api_shortener_proto = out.File
        file_api_shortener_proto_goTypes = nil
        file_api_shortener_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: api/shortener.proto

package api

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Shortener_CreateShortURL_FullMethodName = "/shortener.Shortener/CreateShortURL"
        Shortener_GetOriginalURL_FullMethodName = "/shortener.Shortener/GetOriginalURL"
        Shortener_Ping_FullMethodName           = "/shortener.Shortener/Ping"
        Shortener_GetStats_FullMethodName       = "/shortener.Shortener/GetStats"
        Shortener_GetUserURLs_FullMethodName    = "/shortener.Shortener/GetUserURLs"
        Shortener_DeleteUserURLs_FullMethodName = "/shortener.Shortener/DeleteUserURLs"
        Shortener_BatchCreate_FullMethodName    = "/shortener.Shortener/BatchCreate"
)

// ShortenerClient is the client API for Shortener service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShortenerClient interface {
        CreateShortURL(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
        GetOriginalURL(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
        Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
        GetStats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error)
        GetUserURLs(ctx context.Context, in *UserURLsRequest, opts ...grpc.CallOption) (*UserURLsResponse, error)
        DeleteUserURLs(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
        BatchCreate(ctx context.Context, in *BatchCreateRequest, opts ...grpc.CallOption) (*BatchCreateResponse, error)
}

type shortenerClient struct {
        cc grpc.ClientConnInterface
}

func NewShortenerClient(cc grpc.ClientConnInterface) ShortenerClient <span class="cov10" title="10">{
        return &amp;shortenerClient{cc}
}</span>

func (c *shortenerClient) CreateShortURL(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) <span class="cov5" title="3">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateResponse)
        err := c.cc.Invoke(ctx, Shortener_CreateShortURL_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return out, nil</span>
}

func (c *shortenerClient) GetOriginalURL(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) <span class="cov8" title="7">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetResponse)
        err := c.cc.Invoke(ctx, Shortener_GetOriginalURL_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov7" title="5">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return out, nil</span>
}

func (c *shortenerClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) <span class="cov3" title="2">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PingResponse)
        err := c.cc.Invoke(ctx, Shortener_Ping_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return out, nil</span>
}

func (c *shortenerClient) GetStats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error) <span class="cov6" title="4">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatsResponse)
        err := c.cc.Invoke(ctx, Shortener_GetStats_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov5" title="3">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return out, nil</span>
}

func (c *shortenerClient) GetUserURLs(ctx context.Context, in *UserURLsRequest, opts ...grpc.CallOption) (*UserURLsResponse, error) <span class="cov3" title="2">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UserURLsResponse)
        err := c.cc.Invoke(ctx, Shortener_GetUserURLs_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return out, nil</span>
}

func (c *shortenerClient) DeleteUserURLs(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) <span class="cov6" title="4">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteResponse)
        err := c.cc.Invoke(ctx, Shortener_DeleteUserURLs_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="4">return out, nil</span>
}

func (c *shortenerClient) BatchCreate(ctx context.Context, in *BatchCreateRequest, opts ...grpc.CallOption) (*BatchCreateResponse, error) <span class="cov1" title="1">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(BatchCreateResponse)
        err := c.cc.Invoke(ctx, Shortener_BatchCreate_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return out, nil</span>
}

// ShortenerServer is the server API for Shortener service.
// All implementations must embed UnimplementedShortenerServer
// for forward compatibility.
type ShortenerServer interface {
        CreateShortURL(context.Context, *CreateRequest) (*CreateResponse, error)
        GetOriginalURL(context.Context, *GetRequest) (*GetResponse, error)
        Ping(context.Context, *PingRequest) (*PingResponse, error)
        GetStats(context.Context, *StatsRequest) (*StatsResponse, error)
        GetUserURLs(context.Context, *UserURLsRequest) (*UserURLsResponse, error)
        DeleteUserURLs(context.Context, *DeleteRequest) (*DeleteResponse, error)
        BatchCreate(context.Context, *BatchCreateRequest) (*BatchCreateResponse, error)
        mustEmbedUnimplementedShortenerServer()
}

// UnimplementedShortenerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedShortenerServer struct{}

func (UnimplementedShortenerServer) CreateShortURL(context.Context, *CreateRequest) (*CreateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateShortURL not implemented")
}</span>
func (UnimplementedShortenerServer) GetOriginalURL(context.Context, *GetRequest) (*GetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOriginalURL not implemented")
}</span>
func (UnimplementedShortenerServer) Ping(context.Context, *PingRequest) (*PingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}</span>
func (UnimplementedShortenerServer) GetStats(context.Context, *StatsRequest) (*StatsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}</span>
func (UnimplementedShortenerServer) GetUserURLs(context.Context, *UserURLsRequest) (*UserURLsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserURLs not implemented")
}</span>
func (UnimplementedShortenerServer) DeleteUserURLs(context.Context, *DeleteRequest) (*DeleteResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteUserURLs not implemented")
}</span>
func (UnimplementedShortenerServer) BatchCreate(context.Context, *BatchCreateRequest) (*BatchCreateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}</span>
func (UnimplementedShortenerServer) mustEmbedUnimplementedShortenerServer() {<span class="cov0" title="0">}</span>
func (UnimplementedShortenerServer) testEmbeddedByValue()                   {<span class="cov10" title="10">}</span>

// UnsafeShortenerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShortenerServer will
// result in compilation errors.
type UnsafeShortenerServer interface {
        mustEmbedUnimplementedShortenerServer()
}

func RegisterShortenerServer(s grpc.ServiceRegistrar, srv ShortenerServer) <span class="cov10" title="10">{
        // If the following call pancis, it indicates UnimplementedShortenerServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov10" title="10">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov10" title="10">s.RegisterService(&amp;Shortener_ServiceDesc, srv)</span>
}

func _Shortener_CreateShortURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov5" title="3">{
        in := new(CreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="3">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).CreateShortURL(ctx, in)
        }</span>
        <span class="cov5" title="3">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_CreateShortURL_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov5" title="3">{
                return srv.(ShortenerServer).CreateShortURL(ctx, req.(*CreateRequest))
        }</span>
        <span class="cov5" title="3">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_GetOriginalURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="7">{
        in := new(GetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="7">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).GetOriginalURL(ctx, in)
        }</span>
        <span class="cov8" title="7">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_GetOriginalURL_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="7">{
                return srv.(ShortenerServer).GetOriginalURL(ctx, req.(*GetRequest))
        }</span>
        <span class="cov8" title="7">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov3" title="2">{
        in := new(PingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).Ping(ctx, in)
        }</span>
        <span class="cov3" title="2">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_Ping_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov3" title="2">{
                return srv.(ShortenerServer).Ping(ctx, req.(*PingRequest))
        }</span>
        <span class="cov3" title="2">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov6" title="4">{
        in := new(StatsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="4">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).GetStats(ctx, in)
        }</span>
        <span class="cov6" title="4">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_GetStats_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov5" title="3">{
                return srv.(ShortenerServer).GetStats(ctx, req.(*StatsRequest))
        }</span>
        <span class="cov6" title="4">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_GetUserURLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov3" title="2">{
        in := new(UserURLsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).GetUserURLs(ctx, in)
        }</span>
        <span class="cov3" title="2">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_GetUserURLs_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov3" title="2">{
                return srv.(ShortenerServer).GetUserURLs(ctx, req.(*UserURLsRequest))
        }</span>
        <span class="cov3" title="2">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_DeleteUserURLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov6" title="4">{
        in := new(DeleteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="4">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).DeleteUserURLs(ctx, in)
        }</span>
        <span class="cov6" title="4">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_DeleteUserURLs_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov6" title="4">{
                return srv.(ShortenerServer).DeleteUserURLs(ctx, req.(*DeleteRequest))
        }</span>
        <span class="cov6" title="4">return interceptor(ctx, in, info, handler)</span>
}

func _Shortener_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov1" title="1">{
        in := new(BatchCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ShortenerServer).BatchCreate(ctx, in)
        }</span>
        <span class="cov1" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Shortener_BatchCreate_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov1" title="1">{
                return srv.(ShortenerServer).BatchCreate(ctx, req.(*BatchCreateRequest))
        }</span>
        <span class="cov1" title="1">return interceptor(ctx, in, info, handler)</span>
}

// Shortener_ServiceDesc is the grpc.ServiceDesc for Shortener service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Shortener_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "shortener.Shortener",
        HandlerType: (*ShortenerServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateShortURL",
                        Handler:    _Shortener_CreateShortURL_Handler,
                },
                {
                        MethodName: "GetOriginalURL",
                        Handler:    _Shortener_GetOriginalURL_Handler,
                },
                {
                        MethodName: "Ping",
                        Handler:    _Shortener_Ping_Handler,
                },
                {
                        MethodName: "GetStats",
                        Handler:    _Shortener_GetStats_Handler,
                },
                {
                        MethodName: "GetUserURLs",
                        Handler:    _Shortener_GetUserURLs_Handler,
                },
                {
                        MethodName: "DeleteUserURLs",
                        Handler:    _Shortener_DeleteUserURLs_Handler,
                },
                {
                        MethodName: "BatchCreate",
                        Handler:    _Shortener_BatchCreate_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/shortener.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bufio"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "strings"
)

func main() <span class="cov0" title="0">{
        endpoint := "http://localhost:8080/"
        //    
        data := url.Values{}
        //   
        fmt.Println("  URL")
        //     
        reader := bufio.NewReader(os.Stdin)
        //    
        long, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">long = strings.TrimSuffix(long, "\n")
        long = strings.TrimSuffix(long, "\r")
        //   
        data.Set("url", long)
        //  HTTP-
        client := &amp;http.Client{}
        //  
        //   POST ,  ,  
        //       io.Reader
        request, err := http.NewRequest(http.MethodPost, endpoint, strings.NewReader(long))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        //     
        // request.Header.Add("Content-Type", "application/x-www-form-urlencoded")
        //     
        <span class="cov0" title="0">response, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        //   
        <span class="cov0" title="0">fmt.Println("- ", response.Status)
        defer response.Body.Close()
        //     
        body, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        //   
        <span class="cov0" title="0">fmt.Println(string(body))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bufio"
        "fmt"
        "log"
        "os"
        "regexp"
        "strings"
        "text/template"
)

type Method struct {
        Name       string
        Request    string
        Response   string
        HandlerVar string
}

const tmpl = `// Code generated by genserver from proto; DO NOT EDIT.

package grpchandlers

import (
        "context"

        "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type ServerOption func(s *Server)

{{range .}}
type {{.Name}}Endpoint interface {
        {{.Name}}(ctx context.Context, req *api.{{.Request}}) (*api.{{.Response}}, error)
}

func With{{.Name}}Endpoint(h {{.Name}}Endpoint) ServerOption {
        return func(s *Server) {
                s.{{.HandlerVar}} = h
        }
}
{{end}}

type Server struct {
        api.UnimplementedShortenerServer
        *base.BaseHandler

        {{range .}}{{.HandlerVar}} {{.Name}}Endpoint
        {{end}}
}

func NewServer(baseHandler *base.BaseHandler, opts ...ServerOption) *Server {
        s := &amp;Server{BaseHandler: baseHandler}
        for _, opt := range opts {
                opt(s)
        }
        return s
}

{{range .}}
func (s *Server) {{.Name}}(ctx context.Context, req *api.{{.Request}}) (*api.{{.Response}}, error) {
        if s.{{.HandlerVar}} == nil {
                return nil, status.Error(codes.Unimplemented, "{{.Name}} handler not provided")
        }
        return s.{{.HandlerVar}}.{{.Name}}(ctx, req)
}
{{end}}
`

func main() <span class="cov0" title="0">{
        protoFile := "./api/shortener.proto"

        f, err := os.Open(protoFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to open proto file: %v", err)
        }</span>
        <span class="cov0" title="0">defer f.Close()

        rpcRe := regexp.MustCompile(`rpc\s+(\w+)\s*\(\s*(\w+)\s*\)\s+returns\s*\(\s*(\w+)\s*\);`)
        serviceStartRe := regexp.MustCompile(`service\s+(\w+)\s*{`)

        var inService bool
        var methods []Method

        scanner := bufio.NewScanner(f)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                if !inService </span><span class="cov0" title="0">{
                        if serviceStartRe.MatchString(line) </span><span class="cov0" title="0">{
                                inService = true
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if line == "}" </span><span class="cov0" title="0">{
                        inService = false
                        break</span>
                }

                <span class="cov0" title="0">matches := rpcRe.FindStringSubmatch(line)
                if len(matches) == 4 </span><span class="cov0" title="0">{
                        name := matches[1]
                        req := matches[2]
                        resp := matches[3]

                        methods = append(methods, Method{
                                Name:       name,
                                Request:    req,
                                Response:   resp,
                                HandlerVar: name + "Handler",
                        })
                }</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("reading proto file error: %v", err)
        }</span>

        //  
        <span class="cov0" title="0">t := template.Must(template.New("server").Parse(tmpl))
        outFile := "./internal/app/handlers/grpc/server_gen.go"
        out, err := os.Create(outFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot create output file: %v", err)
        }</span>
        <span class="cov0" title="0">defer out.Close()

        if err := t.Execute(out, methods); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("template execution failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("server_gen.go  : %s\n", outFile)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//  main       URL.
//
//  :
//
//   -   
//   -  
//   -  HTTP 
package main

import (
        "fmt"
        "os"

        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/logger"
        "github.com/ryabkov82/shortener/internal/app/server"
)

var (
        buildVersion string
        buildDate    string
        buildCommit  string
)

func main() <span class="cov0" title="0">{

        printBuildInfo()

        cfg := config.Load()

        if err := logger.Initialize(cfg.LogLevel); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        //     
        // log.Printf("Starting server on %s with base URL %s", cfg.HTTPServerAddr, cfg.BaseURL)
        <span class="cov0" title="0">server.StartServers(logger.Log, cfg)</span>

}

func printBuildInfo() <span class="cov0" title="0">{
        // Set default value "N/A" if variables are empty
        if buildVersion == "" </span><span class="cov0" title="0">{
                buildVersion = "N/A"
        }</span>
        <span class="cov0" title="0">if buildDate == "" </span><span class="cov0" title="0">{
                buildDate = "N/A"
        }</span>
        <span class="cov0" title="0">if buildCommit == "" </span><span class="cov0" title="0">{
                buildCommit = "N/A"
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(os.Stdout, "Build version: %s\n", buildVersion)
        fmt.Fprintf(os.Stdout, "Build date: %s\n", buildDate)
        fmt.Fprintf(os.Stdout, "Build commit: %s\n", buildCommit)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package staticlint        Shortener.
//  :
// -   go/analysis
// -  staticcheck
// -   
//
//  :
//
//        go run cmd/staticlint/main.go ./...
//
//      standalone-:
//
//        go install github.com/ryabkov82/shortener/cmd/staticlint
//        staticlint ./...
package main

import (
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/asmdecl"
        "golang.org/x/tools/go/analysis/passes/assign"
        "golang.org/x/tools/go/analysis/passes/atomic"
        "golang.org/x/tools/go/analysis/passes/bools"
        "golang.org/x/tools/go/analysis/passes/buildtag"
        "golang.org/x/tools/go/analysis/passes/cgocall"
        "golang.org/x/tools/go/analysis/passes/composite"
        "golang.org/x/tools/go/analysis/passes/copylock"
        "golang.org/x/tools/go/analysis/passes/deepequalerrors"
        "golang.org/x/tools/go/analysis/passes/errorsas"
        "golang.org/x/tools/go/analysis/passes/fieldalignment"
        "golang.org/x/tools/go/analysis/passes/httpresponse"
        "golang.org/x/tools/go/analysis/passes/ifaceassert"
        "golang.org/x/tools/go/analysis/passes/loopclosure"
        "golang.org/x/tools/go/analysis/passes/lostcancel"
        "golang.org/x/tools/go/analysis/passes/nilfunc"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/shift"
        "golang.org/x/tools/go/analysis/passes/sigchanyzer"
        "golang.org/x/tools/go/analysis/passes/stdmethods"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "golang.org/x/tools/go/analysis/passes/testinggoroutine"
        "golang.org/x/tools/go/analysis/passes/unmarshal"
        "golang.org/x/tools/go/analysis/passes/unreachable"
        "golang.org/x/tools/go/analysis/passes/unsafeptr"
        "golang.org/x/tools/go/analysis/passes/unusedresult"

        "honnef.co/go/tools/quickfix"
        "honnef.co/go/tools/simple"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck"

        "github.com/go-critic/go-critic/checkers/analyzer"
        "github.com/timakin/bodyclose/passes/bodyclose"

        "github.com/ryabkov82/shortener/cmd/staticlint/noosexit"
)

func main() <span class="cov0" title="0">{
        analyzers := setupAnalyzers()
        multichecker.Main(analyzers...)
}</span>

func setupAnalyzers() []*analysis.Analyzer <span class="cov1" title="1">{

        //    golang.org/x/tools/go/analysis/passes
        standardAnalyzers := []*analysis.Analyzer{
                asmdecl.Analyzer,          //     
                assign.Analyzer,           //   
                atomic.Analyzer,           //    sync/atomic
                bools.Analyzer,            //      
                buildtag.Analyzer,         //   build 
                cgocall.Analyzer,          //    CGO
                composite.Analyzer,        //     
                copylock.Analyzer,         //   
                deepequalerrors.Analyzer,  //   deep equal  
                errorsas.Analyzer,         //    errors.As
                fieldalignment.Analyzer,   //     
                httpresponse.Analyzer,     //   HTTP response bodies
                ifaceassert.Analyzer,      //   type assertions
                loopclosure.Analyzer,      //     
                lostcancel.Analyzer,       //   
                nilfunc.Analyzer,          //     nil
                printf.Analyzer,           //     Printf-
                shadow.Analyzer,           //   
                shift.Analyzer,            //     
                sigchanyzer.Analyzer,      //      signal.Notify
                stdmethods.Analyzer,       //    
                structtag.Analyzer,        //    
                testinggoroutine.Analyzer, //     
                unmarshal.Analyzer,        //      Unmarshal
                unreachable.Analyzer,      //   
                unsafeptr.Analyzer,        //    unsafe.Pointer
                unusedresult.Analyzer,     //    
        }

        //   SA  staticcheck.io (Static Analysis)
        var saAnalyzers []*analysis.Analyzer
        for _, v := range staticcheck.Analyzers </span><span class="cov10" title="90">{
                if v.Analyzer.Name[:2] == "SA" </span><span class="cov10" title="90">{
                        saAnalyzers = append(saAnalyzers, v.Analyzer)
                }</span>
        }

        //      staticcheck
        <span class="cov1" title="1">var otherStaticcheckAnalyzers []*analysis.Analyzer

        //    stylecheck
        for _, a := range stylecheck.Analyzers </span><span class="cov3" title="3">{
                if a.Analyzer.Name == "ST1000" </span><span class="cov1" title="1">{ //   
                        otherStaticcheckAnalyzers = append(otherStaticcheckAnalyzers, a.Analyzer)
                        break</span>
                }
        }

        //    simple
        <span class="cov1" title="1">for _, a := range simple.Analyzers </span><span class="cov7" title="33">{
                if a.Analyzer.Name == "S1002" </span><span class="cov1" title="1">{ //    
                        otherStaticcheckAnalyzers = append(otherStaticcheckAnalyzers, a.Analyzer)
                        break</span>
                }
        }

        //    quickfix
        <span class="cov1" title="1">for _, a := range quickfix.Analyzers </span><span class="cov4" title="7">{
                if a.Analyzer.Name == "QF1001" </span><span class="cov1" title="1">{ //    
                        otherStaticcheckAnalyzers = append(otherStaticcheckAnalyzers, a.Analyzer)
                        break</span>
                }
        }

        //  
        <span class="cov1" title="1">externalAnalyzers := []*analysis.Analyzer{
                bodyclose.Analyzer, //   response.Body
                analyzer.Analyzer,  // go-critic,   ,     
        }

        //  
        customAnalyzers := []*analysis.Analyzer{
                noosexit.NoOsExitAnalyzer,
        }

        //   
        var analyzers []*analysis.Analyzer
        analyzers = append(analyzers, standardAnalyzers...)
        analyzers = append(analyzers, saAnalyzers...)
        analyzers = append(analyzers, otherStaticcheckAnalyzers...)
        analyzers = append(analyzers, externalAnalyzers...)
        analyzers = append(analyzers, customAnalyzers...)

        return analyzers</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package noosexit     os.Exit   main  main
package noosexit

import (
        "go/ast"
        "path/filepath"
        "strings"

        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/ast/inspector"
)

const doc = `noosexit     os.Exit   main  main

   os.Exit()   main()  ,
       log.Fatal().`

// NoOsExitAnalyzer     os.Exit
var NoOsExitAnalyzer = &amp;analysis.Analyzer{
        Name:     "noosexit",
        Doc:      doc,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
        Run:      run,
}

func run(pass *analysis.Pass) (interface{}, error) <span class="cov10" title="2">{

        // ,      cmd
        if !isCmdPackage(pass.Pkg.Path()) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        //  inspector     AST
        <span class="cov10" title="2">inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

        //    
        nodeFilter := []ast.Node{
                (*ast.CallExpr)(nil),
        }

        // ,      main   main
        inspect.Preorder(nodeFilter, func(n ast.Node) </span><span class="cov10" title="2">{
                call := n.(*ast.CallExpr)
                fun, ok := call.Fun.(*ast.SelectorExpr)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                //     os.Exit
                <span class="cov10" title="2">if ident, ok := fun.X.(*ast.Ident); ok </span><span class="cov10" title="2">{
                        if ident.Name == "os" &amp;&amp; fun.Sel.Name == "Exit" </span><span class="cov1" title="1">{
                                //      main  main
                                if pass.Pkg.Name() == "main" </span><span class="cov1" title="1">{
                                        //      main
                                        for _, f := range pass.Files </span><span class="cov1" title="1">{
                                                for _, decl := range f.Decls </span><span class="cov10" title="2">{
                                                        if fd, ok := decl.(*ast.FuncDecl); ok &amp;&amp; fd.Name.Name == "main" </span><span class="cov1" title="1">{
                                                                pass.Reportf(call.Pos(), "  os.Exit   main ,  log.Fatal()   ")
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        })

        <span class="cov10" title="2">return nil, nil</span>
}

// isCmdPackage ,      cmd
var isCmdPackage = func(pkgPath string) bool <span class="cov0" title="0">{
        return strings.Contains(filepath.ToSlash(pkgPath), "/cmd/")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Package config      .

   :
-   
-  
- JSON- 
-   

  (   ):
1.   
2.  
3. JSON-  ( )
4.   

 JSON-:

        {
            "server_address": "localhost:8080",
            "base_url": "http://localhost",
            "file_storage_path": "/path/to/file.db",
            "database_dsn": "",
            "enable_https": true,
            "jwt_secret": "secret_key",
            "pprof": {
                "enabled": true,
                "auth_user": "admin",
                "auth_pass": "password"
            }
        }

  JSON-   :
-   -c  --config
-    CONFIG
*/
package config

import (
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "log"
        "net"
        "net/url"
        "os"
        "strconv"
        "strings"
)

// Config     .
type Config struct {
        HTTPServerAddr string      `json:"server_address"`      //  HTTP-   host:port
        GRPCServerAddr string      `json:"grpc_server_address"` //  gRPC-
        BaseURL        string      `json:"base_url"`            //  URL   
        LogLevel       string      `json:"log_level"`           //   (debug, info, warn, error)
        FileStorage    string      `json:"file_storage_path"`   //    
        DBConnect      string      `json:"database_dsn"`        //    
        JwtKey         string      `json:"jwt_secret"`          //    JWT
        ConfigPProf    PProfConfig `json:"pprof"`               //  pprof
        EnableHTTPS    bool        `json:"enable_https"`        //  HTTPS
        SSLCertFile    string      `json:"ssl_cert_file"`       //   SSL 
        SSLKeyFile     string      `json:"ssl_key_file"`        //   SSL 
        TrustedSubnet  string      `json:"trusted_subnet"`      //  
}

// PProfConfig    pprof.
type PProfConfig struct {
        AuthUser string `json:"auth_user"`
        AuthPass string `json:"auth_pass"`
        Endpoint string `json:"endpoint"`
        BindAddr string `json:"bind_addr"`
        Enabled  bool   `json:"enabled"`
}

// validateHTTPServerAddr    .
//
//  : host:port
//  port     1  65535
//
// :
//
//        error -    nil
func validateHTTPServerAddr(addr string) error <span class="cov10" title="7">{
        hp := strings.Split(addr, ":")
        if len(hp) != 2 </span><span class="cov1" title="1">{
                return errors.New("address must be in host:port format")
        }</span>

        <span class="cov9" title="6">port, err := strconv.Atoi(hp[1])
        if err != nil || port &lt; 1 || port &gt; 65535 </span><span class="cov1" title="1">{
                return errors.New("port must be a number between 1 and 65535")
        }</span>

        <span class="cov8" title="5">return nil</span>
}

// validateBaseURL    URL.
//
// URL  :
// -  ( )
// -   net/url.Parse
//
// :
//
//        error -    nil
func validateBaseURL(baseURL string) error <span class="cov6" title="3">{
        u, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="3">if u.Scheme == "" || u.Host == "" </span><span class="cov1" title="1">{
                return errors.New("URL must be absolute with scheme and host")
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// validateCertFiles    .
// :
//
//        error -   nil
func validateCertFiles(certFile, keyFile string) error <span class="cov6" title="3">{
        if _, err := os.Stat(certFile); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return errors.New("SSL certificate file not found")
        }</span>
        <span class="cov4" title="2">if _, err := os.Stat(keyFile); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return errors.New("SSL key file not found")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func validateGRPCServerAddr(addr string) error <span class="cov10" title="7">{
        if addr == "" </span><span class="cov1" title="1">{
                return errors.New("gRPC server address cannot be empty")
        }</span>

        <span class="cov9" title="6">_, port, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid address format: %w", err)
        }</span>

        //  
        <span class="cov8" title="5">portNum, err := strconv.Atoi(port)
        if err != nil || portNum &lt; 1 || portNum &gt; 65535 </span><span class="cov1" title="1">{
                return errors.New("port must be between 1 and 65535")
        }</span>

        <span class="cov7" title="4">return nil</span>
}

// Load     .
//
//  :
// 1.    
// 2.  JSON- ( )
// 3.    
// 4.   
//
// :
// *Config -  
func Load() *Config <span class="cov10" title="7">{
        cfg := &amp;Config{
                HTTPServerAddr: "localhost:8080",
                GRPCServerAddr: "localhost:50051",
                BaseURL:        "http://localhost:8080",
                LogLevel:       "info",
                FileStorage:    "storage.dat",
                JwtKey:         "your_strong_secret_here",
                EnableHTTPS:    false,
                SSLCertFile:    "cert.pem",
                SSLKeyFile:     "key.pem",
                ConfigPProf: PProfConfig{
                        Enabled:  true,
                        AuthUser: "admin",
                        AuthPass: "admin",
                        Endpoint: "/debug/pprof",
                        BindAddr: ":6060",
                },
        }

        //   JSON-  
        configFile := getConfigFilePath()
        if configFile != "" </span><span class="cov6" title="3">{
                fileCfg, err := loadFromJSON(configFile)
                if err != nil </span><span class="cov1" title="1">{
                        log.Printf("  JSON-: %v", err)
                }</span> else<span class="cov4" title="2"> {
                        //  ,       
                        mergeConfigs(cfg, fileCfg)
                }</span>
        }

        //     
        <span class="cov10" title="7">loadFromFlags(cfg)

        //   
        loadFromEnv(cfg)

        //  
        cfg.BaseURL = strings.TrimSuffix(cfg.BaseURL, "/")

        //  SSL   HTTPS 
        if cfg.EnableHTTPS </span><span class="cov0" title="0">{
                if err := validateCertFiles(cfg.SSLCertFile, cfg.SSLKeyFile); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("HTTPS configuration error: %v", err)
                }</span>
        }

        <span class="cov10" title="7">return cfg</span>
}

// getConfigFilePath          
func getConfigFilePath() string <span class="cov10" title="7">{

        for i, arg := range os.Args[1:] </span><span class="cov9" title="6">{
                if arg == "-c" || arg == "--config" </span><span class="cov0" title="0">{
                        if i+1 &lt; len(os.Args) </span><span class="cov0" title="0">{
                                return os.Args[i+2]
                        }</span>
                }
                <span class="cov9" title="6">if strings.HasPrefix(arg, "-c=") </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(arg, "-c=")
                }</span>
                <span class="cov9" title="6">if strings.HasPrefix(arg, "--config=") </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(arg, "--config=")
                }</span>
        }

        <span class="cov10" title="7">if envConfig := os.Getenv("CONFIG"); envConfig != "" </span><span class="cov6" title="3">{
                return envConfig
        }</span>
        <span class="cov7" title="4">return ""</span>
}

// loadFromJSON    JSON-
func loadFromJSON(path string) (*Config, error) <span class="cov6" title="3">{
        file, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">var cfg Config
        if err := json.Unmarshal(file, &amp;cfg); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;cfg, nil</span>
}

// mergeConfigs   ,      
func mergeConfigs(original, new *Config) <span class="cov6" title="3">{
        if new.HTTPServerAddr != "" </span><span class="cov6" title="3">{
                original.HTTPServerAddr = new.HTTPServerAddr
        }</span>
        <span class="cov6" title="3">if new.BaseURL != "" </span><span class="cov4" title="2">{
                original.BaseURL = new.BaseURL
        }</span>
        <span class="cov6" title="3">if new.LogLevel != "" </span><span class="cov6" title="3">{
                original.LogLevel = new.LogLevel
        }</span>
        <span class="cov6" title="3">if new.FileStorage != "" </span><span class="cov4" title="2">{
                original.FileStorage = new.FileStorage
        }</span>
        <span class="cov6" title="3">if new.DBConnect != "" </span><span class="cov0" title="0">{
                original.DBConnect = new.DBConnect
        }</span>
        <span class="cov6" title="3">if new.JwtKey != "" </span><span class="cov4" title="2">{
                original.JwtKey = new.JwtKey
        }</span>
        <span class="cov6" title="3">if new.EnableHTTPS </span><span class="cov0" title="0">{
                original.EnableHTTPS = new.EnableHTTPS
        }</span>
        <span class="cov6" title="3">if new.SSLCertFile != "" </span><span class="cov0" title="0">{
                original.SSLCertFile = new.SSLCertFile
        }</span>
        <span class="cov6" title="3">if new.SSLKeyFile != "" </span><span class="cov0" title="0">{
                original.SSLKeyFile = new.SSLKeyFile
        }</span>
        <span class="cov6" title="3">if new.TrustedSubnet != "" </span><span class="cov0" title="0">{
                original.TrustedSubnet = new.TrustedSubnet
        }</span>
        <span class="cov6" title="3">if new.GRPCServerAddr != "" </span><span class="cov0" title="0">{
                original.GRPCServerAddr = new.GRPCServerAddr
        }</span>

        //  PProfConfig
        <span class="cov6" title="3">if new.ConfigPProf.AuthUser != "" </span><span class="cov4" title="2">{
                original.ConfigPProf.AuthUser = new.ConfigPProf.AuthUser
        }</span>
        <span class="cov6" title="3">if new.ConfigPProf.AuthPass != "" </span><span class="cov0" title="0">{
                original.ConfigPProf.AuthPass = new.ConfigPProf.AuthPass
        }</span>
        <span class="cov6" title="3">if new.ConfigPProf.Endpoint != "" </span><span class="cov0" title="0">{
                original.ConfigPProf.Endpoint = new.ConfigPProf.Endpoint
        }</span>
        <span class="cov6" title="3">if new.ConfigPProf.BindAddr != "" </span><span class="cov0" title="0">{
                original.ConfigPProf.BindAddr = new.ConfigPProf.BindAddr
        }</span>
        <span class="cov6" title="3">if new.ConfigPProf.Enabled </span><span class="cov4" title="2">{
                original.ConfigPProf.Enabled = new.ConfigPProf.Enabled
        }</span>
}

// loadFromFlags      
func loadFromFlags(cfg *Config) <span class="cov10" title="7">{
        flag.Func("a", "Server address in host:port format", func(flagValue string) error </span><span class="cov4" title="2">{
                if err := validateHTTPServerAddr(flagValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="2">cfg.HTTPServerAddr = flagValue
                return nil</span>
        })

        <span class="cov10" title="7">flag.Func("b", "Base URL for shortened links (e.g. http://example.com)", func(flagValue string) error </span><span class="cov0" title="0">{
                if err := validateBaseURL(flagValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cfg.BaseURL = strings.TrimSuffix(flagValue, "/")
                return nil</span>
        })

        <span class="cov10" title="7">flag.StringVar(&amp;cfg.LogLevel, "l", cfg.LogLevel, "Log level (debug, info, warn, error)")
        flag.StringVar(&amp;cfg.FileStorage, "f", cfg.FileStorage, "Path to file storage")
        flag.StringVar(&amp;cfg.DBConnect, "d", cfg.DBConnect, "Database connection string")
        flag.BoolVar(&amp;cfg.EnableHTTPS, "s", cfg.EnableHTTPS, "Enable HTTPS server")
        flag.StringVar(&amp;cfg.TrustedSubnet, "t", "", "trusted subnet in CIDR notation")

        flag.Func("ga", "gRPC server address in host:port format", func(flagValue string) error </span><span class="cov0" title="0">{
                if err := validateGRPCServerAddr(flagValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cfg.GRPCServerAddr = flagValue
                return nil</span>
        })

        <span class="cov10" title="7">flag.Parse()</span>
}

// loadFromEnv     .
func loadFromEnv(cfg *Config) <span class="cov10" title="7">{
        if envAddr := os.Getenv("SERVER_ADDRESS"); envAddr != "" </span><span class="cov4" title="2">{
                if err := validateHTTPServerAddr(envAddr); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("invalid SERVER_ADDRESS: %v", err)
                }</span>
                <span class="cov4" title="2">cfg.HTTPServerAddr = envAddr</span>
        }

        <span class="cov10" title="7">if envURL := os.Getenv("BASE_URL"); envURL != "" </span><span class="cov0" title="0">{
                if err := validateBaseURL(envURL); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("invalid BASE_URL: %v", err)
                }</span>
                <span class="cov0" title="0">cfg.BaseURL = envURL</span>
        }

        <span class="cov10" title="7">if envFile := os.Getenv("FILE_STORAGE_PATH"); envFile != "" </span><span class="cov0" title="0">{
                cfg.FileStorage = envFile
        }</span>

        <span class="cov10" title="7">if envDB := os.Getenv("DATABASE_DSN"); envDB != "" </span><span class="cov10" title="7">{
                cfg.DBConnect = envDB
        }</span>

        <span class="cov10" title="7">if envJWT := os.Getenv("JWT_SECRET"); envJWT != "" </span><span class="cov1" title="1">{
                if len(envJWT) &lt; 32 </span><span class="cov0" title="0">{
                        log.Fatal("JWT_SECRET must be at least 32 characters long")
                }</span>
                <span class="cov1" title="1">cfg.JwtKey = envJWT</span>
        }

        <span class="cov10" title="7">if envLogLevel := os.Getenv("LOG_LEVEL"); envLogLevel != "" </span><span class="cov1" title="1">{
                cfg.LogLevel = envLogLevel
        }</span>

        //  HTTPS 
        <span class="cov10" title="7">if envEnableHTTPS := os.Getenv("SSL_ENABLE"); envEnableHTTPS != "" </span><span class="cov0" title="0">{
                if v, err := strconv.ParseBool(envEnableHTTPS); err == nil </span><span class="cov0" title="0">{
                        cfg.EnableHTTPS = v
                }</span>
        }

        <span class="cov10" title="7">if envCert := os.Getenv("SSL_CERT_FILE"); envCert != "" </span><span class="cov10" title="7">{
                cfg.SSLCertFile = envCert
        }</span>

        <span class="cov10" title="7">if envKey := os.Getenv("SSL_KEY_FILE"); envKey != "" </span><span class="cov10" title="7">{
                cfg.SSLKeyFile = envKey
        }</span>

        <span class="cov10" title="7">if envSubnet := os.Getenv("TRUSTED_SUBNET"); envSubnet != "" </span><span class="cov10" title="7">{
                cfg.TrustedSubnet = envSubnet
        }</span>

        <span class="cov10" title="7">if envGRPCAddr := os.Getenv("GRPC_SERVER_ADDRESS"); envGRPCAddr != "" </span><span class="cov0" title="0">{
                if err := validateGRPCServerAddr(envGRPCAddr); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("invalid GRPC_SERVER_ADDRESS: %v", err)
                }</span>
                <span class="cov0" title="0">cfg.GRPCServerAddr = envGRPCAddr</span>
        }

        //  pprof 
        <span class="cov10" title="7">if user := os.Getenv("PPROF_USER"); user != "" </span><span class="cov1" title="1">{
                cfg.ConfigPProf.AuthUser = user
        }</span>
        <span class="cov10" title="7">if pass := os.Getenv("PPROF_PASS"); pass != "" </span><span class="cov1" title="1">{
                cfg.ConfigPProf.AuthPass = pass
        }</span>
        <span class="cov10" title="7">if enabled := os.Getenv("PPROF_ENABLED"); enabled != "" </span><span class="cov1" title="1">{
                if v, err := strconv.ParseBool(enabled); err == nil </span><span class="cov1" title="1">{
                        cfg.ConfigPProf.Enabled = v
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package base

import (
        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/server/grpc/interceptors"
        "google.golang.org/grpc"

        "go.uber.org/zap"
)

// BaseHandler      
type BaseHandler struct {
        Logger *zap.Logger //  
}

// NewBaseHandler   
func NewBaseHandler(logger *zap.Logger) *BaseHandler <span class="cov0" title="0">{
        return &amp;BaseHandler{
                Logger: logger,
        }
}</span>

// CommonInterceptors    
func (h *BaseHandler) CommonInterceptors(cfg *config.Config) []grpc.UnaryServerInterceptor <span class="cov10" title="5">{
        return []grpc.UnaryServerInterceptor{
                interceptors.LoggingInterceptor(h.Logger),
                interceptors.JWTAutoIssueGRPC([]byte(cfg.JwtKey)),
                interceptors.TrustedSubnetInterceptor(interceptors.TrustedSubnetConfig{
                        TrustedSubnet: cfg.TrustedSubnet,
                        ProtectedMethods: map[string]bool{
                                "/shortener.Shortener/GetStats": true,
                        },
                        DenyIfNotConfigured: true, //     
                }),
        }

}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package batch

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/models"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler      .
type URLHandler interface {
        Batch(ctx context.Context, requests []models.BatchRequest, baseURL string) ([]models.BatchResponse, error)
}

type Handler struct {
        *base.BaseHandler //   
        service           URLHandler
        baseURL           string
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
        baseURL string,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, //   
                service:     service,
                baseURL:     baseURL,
        }
}</span>

func (h *Handler) BatchCreate(
        ctx context.Context,
        req *pb.BatchCreateRequest,
) (*pb.BatchCreateResponse, error) <span class="cov1" title="1">{
        if len(req.Items) == 0 </span><span class="cov0" title="0">{
                h.Logger.Error("Empty batch request")
                return nil, status.Error(codes.InvalidArgument, "Request contains no items")
        }</span>

        //   []models.BatchRequest
        <span class="cov1" title="1">batchReq := make([]models.BatchRequest, 0, len(req.Items))
        for _, item := range req.Items </span><span class="cov10" title="2">{
                batchReq = append(batchReq, models.BatchRequest{
                        CorrelationID: item.CorrelationId,
                        OriginalURL:   item.OriginalUrl,
                })
        }</span>

        // 
        <span class="cov1" title="1">batchResp, err := h.service.Batch(ctx, batchReq, h.baseURL)
        if err != nil </span><span class="cov0" title="0">{
                h.Logger.Error("Failed to process batch create", zap.Error(err))
                return nil, status.Error(codes.Internal, "Failed to process batch create")
        }</span>

        //  
        <span class="cov1" title="1">resp := &amp;pb.BatchCreateResponse{}
        for _, item := range batchResp </span><span class="cov10" title="2">{
                resp.Items = append(resp.Items, &amp;pb.BatchCreateResult{
                        CorrelationId: item.CorrelationID,
                        ShortUrl:      item.ShortURL,
                })
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("Batch create processed", zap.Int("count", len(resp.Items)))
        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package deluserurls

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler      URL.
type URLHandler interface {
        DeleteUserUrls(ctx context.Context, ids []string) error
}

type Handler struct {
        *base.BaseHandler //   
        service           URLHandler
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, //   
                service:     service,
        }
}</span>

func (h *Handler) DeleteUserURLs(
        ctx context.Context,
        req *pb.DeleteRequest,
) (*pb.DeleteResponse, error) <span class="cov10" title="4">{
        if len(req.ShortUrls) == 0 </span><span class="cov0" title="0">{
                h.Logger.Error("No short URLs provided for deletion")
                return nil, status.Error(codes.InvalidArgument, "No short URLs provided")
        }</span>

        <span class="cov10" title="4">h.Logger.Debug("Processing DeleteUserURLs request",
                zap.Int("url_count", len(req.ShortUrls)))

        err := h.service.DeleteUserUrls(ctx, req.ShortUrls)
        if err != nil </span><span class="cov0" title="0">{
                h.Logger.Error("Failed to delete user URLs", zap.Error(err))
                return nil, status.Error(codes.Internal, "Failed to delete user URLs")
        }</span>

        // 202 Accepted,   gRPC  -   HTTP    OK
        <span class="cov10" title="4">return &amp;pb.DeleteResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package ping

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler       .
type URLHandler interface {
        // Ping     .
        //
        // :
        //   ctx -    
        //
        // :
        //   error -    nil  
        Ping(ctx context.Context) error
}

type Handler struct {
        *base.BaseHandler //   
        service           URLHandler
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, //   
                service:     service,
        }
}</span>

func (h *Handler) Ping(
        ctx context.Context,
        req *pb.PingRequest,
) (*pb.PingResponse, error) <span class="cov10" title="2">{
        err := h.service.Ping(ctx)
        if err != nil </span><span class="cov1" title="1">{
                h.Logger.Error("Failed to connect to database",
                        zap.Error(err),
                )
                return nil, status.Error(codes.Internal, "Failed to connect to database")
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("Database connection check successful")

        return &amp;pb.PingResponse{
                Ok: true,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package redirect

import (
        "context"
        "errors"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/storage"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler      URL.
type URLHandler interface {
        // GetRedirectURL   URL  .
        //
        // :
        //   ctx -  
        //   id -   URL
        //
        // :
        //   string -  URL
        //   error -  :
        //     - storage.ErrURLNotFound: URL  
        //     - storage.ErrURLDeleted: URL  
        //     -   
        GetRedirectURL(ctx context.Context, id string) (string, error)
}

type Handler struct {
        *base.BaseHandler //   
        service           URLHandler
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, //   
                service:     service,
        }
}</span>

// GetOriginalURL  gRPC    URL
func (h *Handler) GetOriginalURL(
        ctx context.Context,
        req *pb.GetRequest,
) (*pb.GetResponse, error) <span class="cov10" title="2">{
        //  ID
        if req.ShortUrl == "" </span><span class="cov0" title="0">{
                h.Logger.Error("Empty ID in request")
                return nil, status.Error(codes.InvalidArgument, "ID parameter is missing")
        }</span>

        <span class="cov10" title="2">h.Logger.Debug("Processing URL lookup",
                zap.String("shortID", req.ShortUrl))

        //   URL
        originalURL, err := h.service.GetRedirectURL(ctx, req.ShortUrl)
        if err != nil </span><span class="cov1" title="1">{
                switch </span>{
                case errors.Is(err, storage.ErrURLNotFound):<span class="cov1" title="1">
                        h.Logger.Info("Shortened key not found",
                                zap.String("shortKey", req.ShortUrl))
                        return nil, status.Error(codes.NotFound, "Shortened key not found")</span>
                case errors.Is(err, storage.ErrURLDeleted):<span class="cov0" title="0">
                        h.Logger.Info("URL has been deleted",
                                zap.String("shortKey", req.ShortUrl))
                        return nil, status.Error(codes.NotFound, "URL has been deleted")</span>
                default:<span class="cov0" title="0">
                        h.Logger.Error("Failed to get redirect URL",
                                zap.Error(err),
                                zap.String("shortKey", req.ShortUrl))
                        return nil, status.Error(codes.Internal, "Failed to get redirect URL")</span>
                }
        }

        <span class="cov1" title="1">h.Logger.Info("Shortened key found",
                zap.String("shortKey", req.ShortUrl),
                zap.String("redirect", originalURL))

        //  
        return &amp;pb.GetResponse{
                OriginalUrl: originalURL,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by genserver from proto; DO NOT EDIT.

package grpchandlers

import (
        "context"

        "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type ServerOption func(s *Server)


type CreateShortURLEndpoint interface {
        CreateShortURL(ctx context.Context, req *api.CreateRequest) (*api.CreateResponse, error)
}

func WithCreateShortURLEndpoint(h CreateShortURLEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.CreateShortURLHandler = h
        }</span>
}

type GetOriginalURLEndpoint interface {
        GetOriginalURL(ctx context.Context, req *api.GetRequest) (*api.GetResponse, error)
}

func WithGetOriginalURLEndpoint(h GetOriginalURLEndpoint) ServerOption <span class="cov3" title="2">{
        return func(s *Server) </span><span class="cov3" title="2">{
                s.GetOriginalURLHandler = h
        }</span>
}

type PingEndpoint interface {
        Ping(ctx context.Context, req *api.PingRequest) (*api.PingResponse, error)
}

func WithPingEndpoint(h PingEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.PingHandler = h
        }</span>
}

type GetStatsEndpoint interface {
        GetStats(ctx context.Context, req *api.StatsRequest) (*api.StatsResponse, error)
}

func WithGetStatsEndpoint(h GetStatsEndpoint) ServerOption <span class="cov6" title="4">{
        return func(s *Server) </span><span class="cov6" title="4">{
                s.GetStatsHandler = h
        }</span>
}

type GetUserURLsEndpoint interface {
        GetUserURLs(ctx context.Context, req *api.UserURLsRequest) (*api.UserURLsResponse, error)
}

func WithGetUserURLsEndpoint(h GetUserURLsEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.GetUserURLsHandler = h
        }</span>
}

type DeleteUserURLsEndpoint interface {
        DeleteUserURLs(ctx context.Context, req *api.DeleteRequest) (*api.DeleteResponse, error)
}

func WithDeleteUserURLsEndpoint(h DeleteUserURLsEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.DeleteUserURLsHandler = h
        }</span>
}

type BatchCreateEndpoint interface {
        BatchCreate(ctx context.Context, req *api.BatchCreateRequest) (*api.BatchCreateResponse, error)
}

func WithBatchCreateEndpoint(h BatchCreateEndpoint) ServerOption <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.BatchCreateHandler = h
        }</span>
}


type Server struct {
        api.UnimplementedShortenerServer
        *base.BaseHandler

        CreateShortURLHandler CreateShortURLEndpoint
        GetOriginalURLHandler GetOriginalURLEndpoint
        PingHandler PingEndpoint
        GetStatsHandler GetStatsEndpoint
        GetUserURLsHandler GetUserURLsEndpoint
        DeleteUserURLsHandler DeleteUserURLsEndpoint
        BatchCreateHandler BatchCreateEndpoint
        
}

func NewServer(baseHandler *base.BaseHandler, opts ...ServerOption) *Server <span class="cov9" title="10">{
        s := &amp;Server{BaseHandler: baseHandler}
        for _, opt := range opts </span><span class="cov10" title="11">{
                opt(s)
        }</span>
        <span class="cov9" title="10">return s</span>
}


func (s *Server) CreateShortURL(ctx context.Context, req *api.CreateRequest) (*api.CreateResponse, error) <span class="cov5" title="3">{
        if s.CreateShortURLHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "CreateShortURL handler not provided")
        }</span>
        <span class="cov5" title="3">return s.CreateShortURLHandler.CreateShortURL(ctx, req)</span>
}

func (s *Server) GetOriginalURL(ctx context.Context, req *api.GetRequest) (*api.GetResponse, error) <span class="cov8" title="7">{
        if s.GetOriginalURLHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "GetOriginalURL handler not provided")
        }</span>
        <span class="cov8" title="7">return s.GetOriginalURLHandler.GetOriginalURL(ctx, req)</span>
}

func (s *Server) Ping(ctx context.Context, req *api.PingRequest) (*api.PingResponse, error) <span class="cov3" title="2">{
        if s.PingHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "Ping handler not provided")
        }</span>
        <span class="cov3" title="2">return s.PingHandler.Ping(ctx, req)</span>
}

func (s *Server) GetStats(ctx context.Context, req *api.StatsRequest) (*api.StatsResponse, error) <span class="cov5" title="3">{
        if s.GetStatsHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "GetStats handler not provided")
        }</span>
        <span class="cov5" title="3">return s.GetStatsHandler.GetStats(ctx, req)</span>
}

func (s *Server) GetUserURLs(ctx context.Context, req *api.UserURLsRequest) (*api.UserURLsResponse, error) <span class="cov3" title="2">{
        if s.GetUserURLsHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "GetUserURLs handler not provided")
        }</span>
        <span class="cov3" title="2">return s.GetUserURLsHandler.GetUserURLs(ctx, req)</span>
}

func (s *Server) DeleteUserURLs(ctx context.Context, req *api.DeleteRequest) (*api.DeleteResponse, error) <span class="cov6" title="4">{
        if s.DeleteUserURLsHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "DeleteUserURLs handler not provided")
        }</span>
        <span class="cov6" title="4">return s.DeleteUserURLsHandler.DeleteUserURLs(ctx, req)</span>
}

func (s *Server) BatchCreate(ctx context.Context, req *api.BatchCreateRequest) (*api.BatchCreateResponse, error) <span class="cov1" title="1">{
        if s.BatchCreateHandler == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unimplemented, "BatchCreate handler not provided")
        }</span>
        <span class="cov1" title="1">return s.BatchCreateHandler.BatchCreate(ctx, req)</span>
}

</pre>
		
		<pre class="file" id="file14" style="display: none">package shorturl

import (
        "context"
        "errors"
        "net/url"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/storage"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler      URL.
type URLHandler interface {
        // GetShortKey      URL.
        //
        // :
        //   ctx -   (  )
        //   originalURL -  URL  
        //
        // :
        //   string -  
        //   error -  :
        //     - storage.ErrURLExists: URL  
        //     -   
        GetShortKey(ctx context.Context, originalURL string) (string, error)
}

type Handler struct {
        *base.BaseHandler //   
        service           URLHandler
        baseURL           string
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
        baseURL string,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, //   
                service:     service,
                baseURL:     baseURL,
        }
}</span>

// CreateShortURL  gRPC    
func (h *Handler) CreateShortURL(
        ctx context.Context,
        req *pb.CreateRequest,
) (*pb.CreateResponse, error) <span class="cov10" title="3">{
        //  URL
        if req.OriginalUrl == "" </span><span class="cov0" title="0">{
                h.Logger.Error("Empty URL in request")
                return nil, status.Error(codes.InvalidArgument, "URL parameter is missing")
        }</span>

        <span class="cov10" title="3">if _, err := url.ParseRequestURI(req.OriginalUrl); err != nil </span><span class="cov1" title="1">{
                h.Logger.Error("Invalid URL in request",
                        zap.String("url", req.OriginalUrl),
                        zap.Error(err))
                return nil, status.Error(codes.InvalidArgument, "Invalid URL format")
        }</span>

        <span class="cov6" title="2">h.Logger.Debug("Processing URL shortening",
                zap.String("originalURL", req.OriginalUrl))

        //   
        shortKey, err := h.service.GetShortKey(ctx, req.OriginalUrl)
        if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                h.Logger.Error("Short URL generation failed",
                        zap.Error(err),
                        zap.String("originalURL", req.OriginalUrl))
                return nil, status.Error(codes.Internal, "Failed to generate short URL")
        }</span>

        //  
        <span class="cov6" title="2">response := &amp;pb.CreateResponse{
                ShortUrl: h.baseURL + "/" + shortKey,
        }

        if errors.Is(err, storage.ErrURLExists) </span><span class="cov1" title="1">{
                h.Logger.Debug("URL already exists",
                        zap.String("shortKey", shortKey),
                        zap.String("originalURL", req.OriginalUrl))
                return response, status.Error(codes.AlreadyExists, "URL already exists")
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("URL successfully shortened",
                zap.String("shortKey", shortKey),
                zap.String("originalURL", req.OriginalUrl))

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package stats

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/models"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler      .
//         URL  .
type URLHandler interface {
        // GetStats   .
        // :
        //   - models.StatsResponse   URL  
        //   - error      
        GetStats(ctx context.Context) (models.StatsResponse, error)
}

type Handler struct {
        *base.BaseHandler //   
        service           URLHandler
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
) *Handler <span class="cov10" title="4">{
        return &amp;Handler{
                BaseHandler: baseHandler, //   
                service:     service,
        }
}</span>

// GetStats  gRPC   
func (h *Handler) GetStats(
        ctx context.Context,
        _ *pb.StatsRequest,
) (*pb.StatsResponse, error) <span class="cov8" title="3">{

        //    
        stats, err := h.service.GetStats(ctx)
        if err != nil </span><span class="cov5" title="2">{
                h.Logger.Error("Failed to get stats", zap.Error(err))
                return nil, status.Error(codes.Internal, "failed to get stats")
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("Stats received successfully")

        //    
        return &amp;pb.StatsResponse{
                Urls:  int64(stats.URLs),
                Users: int64(stats.Users),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package userurls

import (
        "context"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/models"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// URLHandler     URL .
type URLHandler interface {
        GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error)
}

type Handler struct {
        *base.BaseHandler //   
        service           URLHandler
        baseURL           string
}

func New(
        baseHandler *base.BaseHandler,
        service URLHandler,
        baseURL string,
) *Handler <span class="cov1" title="1">{
        return &amp;Handler{
                BaseHandler: baseHandler, //   
                service:     service,
                baseURL:     baseURL,
        }
}</span>

func (h *Handler) GetUserURLs(
        ctx context.Context,
        _ *pb.UserURLsRequest,
) (*pb.UserURLsResponse, error) <span class="cov10" title="2">{

        h.Logger.Debug("Processing GetUserURLs request")

        //  URL 
        urls, err := h.service.GetUserUrls(ctx, h.baseURL)
        if err != nil </span><span class="cov0" title="0">{
                h.Logger.Error("Failed to retrieve user URLs",
                        zap.Error(err))
                return nil, status.Error(codes.Internal, "Failed to retrieve user URLs")
        }</span>

        //       
        <span class="cov10" title="2">if len(urls) == 0 </span><span class="cov1" title="1">{
                h.Logger.Debug("No URLs found for user")
                return &amp;pb.UserURLsResponse{Urls: []*pb.UserURL{}}, nil
        }</span>

        //  
        <span class="cov1" title="1">var pbUrls []*pb.UserURL
        for _, u := range urls </span><span class="cov10" title="2">{
                pbUrls = append(pbUrls, &amp;pb.UserURL{
                        ShortUrl:    u.ShortURL,
                        OriginalUrl: u.OriginalURL,
                })
        }</span>

        <span class="cov1" title="1">h.Logger.Debug("Successfully returned user URLs", zap.Int("count", len(pbUrls)))

        return &amp;pb.UserURLsResponse{
                Urls: pbUrls,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package batch       URL.
//
//  :
// -   URL  JSON-
// -   
// -     
package batch

import (
        "context"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/models"
)

// URLHandler      .
type URLHandler interface {
        // Batch      URL.
        //
        // :
        //   ctx -  
        //   requests -  
        //   baseURL -  URL    
        //
        // :
        //   []models.BatchResponse -  
        //   error -  
        Batch(ctx context.Context, requests []models.BatchRequest, baseURL string) ([]models.BatchResponse, error)
}

// GetHandler  HTTP-    URL.
//
//  API:
//
//        : POST
//        Content-Type: application/json
//        : /api/shorten/batch
//
//  :
//
//        [
//          {
//            "correlation_id": "_",
//            "original_url": "https://example.com"
//          },
//          ...
//        ]
//
//  :
//
//        [
//          {
//            "correlation_id": "_",
//            "short_url": "http://short.ly/abc"
//          },
//          ...
//        ]
//
//  :
//   - 201 Created -  
//   - 400 Bad Request -  JSON
//   - 500 Internal Server Error -   
//
// :
//
//        urlHandler -    URL
//        baseURL -     
//        log -    
//
// :
//
//        http.HandlerFunc - HTTP-
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov5" title="2">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="4">{
                //   
                var requestData []models.BatchRequest
                decoder := json.NewDecoder(req.Body)
                err := decoder.Decode(&amp;requestData)
                if err != nil </span><span class="cov5" title="2">{
                        http.Error(res, "Failed to read request body", http.StatusBadRequest)
                        log.Error("Failed to read request body", zap.Error(err))
                        return
                }</span>

                <span class="cov5" title="2">responseData, err := urlHandler.Batch(req.Context(), requestData, baseURL)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to proccessing request data", http.StatusBadRequest)
                        log.Error("Failed to proccessing request data", zap.Error(err))
                        return
                }</span>

                <span class="cov5" title="2">res.Header().Set("content-type", "application/json")
                //   201
                res.WriteHeader(http.StatusCreated)
                //   
                resp, err := json.Marshal(responseData)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        log.Error("Failed to encode response data", zap.Error(err))
                        return
                }</span>
                <span class="cov5" title="2">res.Write(resp)</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package deluserurls      URL .
//
//  :
// -   URL    JSON-
// -   URL
// -   
package deluserurls

import (
        "context"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"
)

// URLHandler      URL.
type URLHandler interface {
        // DeleteUserUrls   URL,  .
        //
        // :
        //   ctx -  
        //   urls -   URL   ( )
        //
        // :
        //   error -   (   HTTP- )
        DeleteUserUrls(ctx context.Context, urls []string) error
}

// GetHandler  HTTP-    URL .
//
//  API:
//
//        : DELETE
//        Content-Type: application/json
//        : /api/user/urls
//
//  :
//
//        ["url1", "url2", ...]
//
//  :
//
//          
//
//  :
//   - 202 Accepted -    
//   - 400 Bad Request -  JSON
//   - 401 Unauthorized -   
//   - 500 Internal Server Error -   
//
// :
//   -   
//   -  202    
//   -    JWT-  Cookie
//
// :
//
//        urlHandler -    URL
//        baseURL -    (    )
//        log -    
//
// :
//
//        http.HandlerFunc - HTTP-
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="4">{
                var shortURLs []string
                if err := json.NewDecoder(req.Body).Decode(&amp;shortURLs); err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Invalid request body", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov10" title="4">err := urlHandler.DeleteUserUrls(req.Context(), shortURLs)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to delete user urls", http.StatusBadRequest)
                        log.Error("Failed to delete user urls", zap.Error(err))
                        return
                }</span>

                <span class="cov10" title="4">res.WriteHeader(http.StatusAccepted)</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package ping       .
//
//  :
// -     
// -    
// -   
package ping

import (
        "context"
        "net/http"

        "go.uber.org/zap"
)

// URLHandler       .
type URLHandler interface {
        // Ping     .
        //
        // :
        //   ctx -    
        //
        // :
        //   error -    nil  
        Ping(ctx context.Context) error
}

// GetHandler  HTTP-    .
//
//  API:
//
//        : GET
//        : /ping
//
//  :
//   -  :  "Connect to database is successful"
//   -  :  
//
//  :
//   - 200 OK -    
//   - 500 Internal Server Error -    
//   - 503 Service Unavailable -   (    )
//
// :
//
//        urlHandler -    
//        log -    
//
// :
//
//        http.HandlerFunc - HTTP-
func GetHandler(urlHandler URLHandler, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="2">{
                err := urlHandler.Ping(req.Context())
                if err != nil </span><span class="cov1" title="1">{
                        http.Error(res, "Failed to connect to database", http.StatusInternalServerError)
                        log.Error("Failed to connect to database",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov1" title="1">log.Debug("Database connection check successful",
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                res.WriteHeader(http.StatusOK)
                res.Write([]byte("Connect to database is successful"))</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package redirect       URL.
//
//  :
// -   URL   
// -    URL (, ,  )
// -    
package redirect

import (
        "context"
        "errors"
        "net/http"

        "go.uber.org/zap"

        "github.com/go-chi/chi/v5"

        "github.com/ryabkov82/shortener/internal/app/storage"
)

// URLHandler      URL.
type URLHandler interface {
        // GetRedirectURL   URL  .
        //
        // :
        //   ctx -  
        //   id -   URL
        //
        // :
        //   string -  URL
        //   error -  :
        //     - storage.ErrURLNotFound: URL  
        //     - storage.ErrURLDeleted: URL  
        //     -   
        GetRedirectURL(ctx context.Context, id string) (string, error)
}

// GetHandler  HTTP-     URL.
//
//  API:
//
//        : GET
//        : /{id}
//
//  :
//
//        id -   URL (a-z, A-Z, 0-9)
//
// :
//   - 307 Temporary Redirect:   ( Location header)
//   - 404 Not Found:  URL  
//   - 410 Gone: URL  
//   - 500 Internal Server Error:   
//
// :
//   -      shortKey
//   -   URL    410
//   -     
//
// :
//
//        urlHandler -    URL
//        log -    
//
// :
//
//        http.HandlerFunc - HTTP-
func GetHandler(urlHandler URLHandler, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="2">{
                id := chi.URLParam(req, "id")

                //   
                originalURL, err := urlHandler.GetRedirectURL(req.Context(), id)
                if err != nil </span><span class="cov1" title="1">{
                        if errors.Is(err, storage.ErrURLNotFound) </span><span class="cov1" title="1">{
                                http.Error(res, "Shortened key not found", http.StatusNotFound)
                                log.Info("Shortened key not found",
                                        zap.String("shortKey", id),
                                        zap.String("method", req.Method),
                                        zap.String("path", req.URL.Path))
                                return
                        }</span>
                        <span class="cov0" title="0">if errors.Is(err, storage.ErrURLDeleted) </span><span class="cov0" title="0">{
                                http.Error(res, "URL has been deleted", http.StatusGone)
                                log.Info("URL has been deleted",
                                        zap.String("shortKey", id),
                                        zap.String("method", req.Method),
                                        zap.String("path", req.URL.Path))
                                return
                        }</span>
                        <span class="cov0" title="0">http.Error(res, "failed get redirect URL", http.StatusInternalServerError)
                        log.Error("failed get redirect URL",
                                zap.Error(err),
                                zap.String("shortKey", id),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return</span>
                }

                <span class="cov1" title="1">log.Info("Shortened key found",
                        zap.String("shortKey", id),
                        zap.String("redirect", originalURL),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                //    Location
                res.Header().Set("Location", originalURL)
                //   307
                res.WriteHeader(http.StatusTemporaryRedirect)</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package shortenapi  JSON API    URL.
//
//  :
// -   URL  JSON-
// -   URL
// -   
// -     JSON-
package shortenapi

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"
        "net/url"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/storage"
)

// URLHandler      URL.
type URLHandler interface {
        // GetShortKey      URL.
        //
        // :
        //   ctx -  
        //   originalURL - URL   (  )
        //
        // :
        //   string -  
        //   error -  :
        //     - storage.ErrURLExists: URL  
        //     -   
        GetShortKey(ctx context.Context, originalURL string) (string, error)
}

// Request    JSON-.
type Request struct {
        URL string `json:"url"` //  URL  
}

// Response    JSON-.
type Response struct {
        Result string `json:"result"` //   URL
}

// GetHandler  HTTP-  API  URL.
//
//  API:
//
//        : POST
//        Content-Type: application/json
//        : /api/shorten
//
//  :
//
//        {
//          "url": "https://example.com/very/long/url"
//        }
//
//  :
//
//        {
//          "result": "http://short.ly/abc123"
//        }
//
//  :
//   - 201 Created: URL  
//   - 400 Bad Request:  
//   - 409 Conflict: URL  
//   - 500 Internal Server Error:   
//
// :
//
//        urlHandler -     
//        baseURL -       URL
//        log -    
//
// :
//
//        http.HandlerFunc - HTTP-
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="3">{
                var request Request

                //  JSON- 
                if err := json.NewDecoder(req.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to read request body", http.StatusBadRequest)
                        log.Error("Failed to decode request body",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov10" title="3">originalURL := request.URL

                //    URL
                if originalURL == "" </span><span class="cov0" title="0">{
                        http.Error(res, "URL parameter is missing", http.StatusBadRequest)
                        log.Error("Empty URL in request",
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                //   URL
                <span class="cov10" title="3">if _, err := url.ParseRequestURI(originalURL); err != nil </span><span class="cov1" title="1">{
                        http.Error(res, "Invalid URL format", http.StatusBadRequest)
                        log.Error("Invalid URL in request",
                                zap.String("url", originalURL),
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov6" title="2">log.Debug("Processing URL shortening",
                        zap.String("originalURL", originalURL),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                //   
                shortKey, err := urlHandler.GetShortKey(req.Context(), originalURL)

                //  
                if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to generate short URL", http.StatusInternalServerError)
                        log.Error("Short URL generation failed",
                                zap.Error(err),
                                zap.String("originalURL", originalURL),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                //  
                <span class="cov6" title="2">response := Response{
                        Result: baseURL + "/" + shortKey,
                }

                res.Header().Set("Content-Type", "application/json")

                //   HTTP-
                if errors.Is(err, storage.ErrURLExists) </span><span class="cov1" title="1">{
                        res.WriteHeader(http.StatusConflict)
                        log.Debug("URL already exists",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span> else<span class="cov1" title="1"> {
                        res.WriteHeader(http.StatusCreated)
                        log.Debug("URL successfully shortened",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span>

                //    
                <span class="cov6" title="2">if err := json.NewEncoder(res).Encode(response); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to encode response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package shorturl      URL   .
//
//  :
// -   URL   
// -   URL
// -   
// -     
package shorturl

import (
        "context"
        "errors"
        "io"
        "net/http"
        "net/url"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/storage"
)

// URLHandler      URL.
type URLHandler interface {
        // GetShortKey      URL.
        //
        // :
        //   ctx -   (  )
        //   originalURL -  URL  
        //
        // :
        //   string -  
        //   error -  :
        //     - storage.ErrURLExists: URL  
        //     -   
        GetShortKey(ctx context.Context, originalURL string) (string, error)
}

// GetHandler  HTTP-     URL.
//
//  API:
//
//        : POST
//        Content-Type: text/plain
//        : /
//
//  :
//
//            URL (: "https://example.com/long/url")
//
//  :
//
//            URL (: "http://short.ly/abc123")
//
//  :
//   - 201 Created: URL  
//   - 400 Bad Request:  
//   - 409 Conflict: URL  
//   - 500 Internal Server Error:   
//
// :
//
//        urlHandler -     
//        baseURL -       URL
//        log -    
//
// :
//
//        http.HandlerFunc - HTTP-
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="3">{
                //     
                //  io.LimitReader,  
                body, err := io.ReadAll(io.LimitReader(req.Body, 1&lt;&lt;20)) //  1MB
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to read request body", http.StatusBadRequest)
                        log.Error("Failed to read request body",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>
                <span class="cov10" title="3">defer req.Body.Close()

                originalURL := string(body)
                if originalURL == "" </span><span class="cov0" title="0">{
                        http.Error(res, "URL parameter is missing", http.StatusBadRequest)
                        log.Error("Empty URL in request",
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                //  URL
                <span class="cov10" title="3">if _, err = url.ParseRequestURI(originalURL); err != nil </span><span class="cov1" title="1">{
                        http.Error(res, "Invalid URL format", http.StatusBadRequest)
                        log.Error("Invalid URL in request",
                                zap.String("url", originalURL),
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov6" title="2">log.Debug("Processing URL shortening",
                        zap.String("originalURL", originalURL),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                //   
                shortKey, err := urlHandler.GetShortKey(req.Context(), originalURL)
                if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to generate short URL", http.StatusInternalServerError)
                        log.Error("Short URL generation failed",
                                zap.Error(err),
                                zap.String("originalURL", originalURL),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                //  
                <span class="cov6" title="2">res.Header().Set("Content-Type", "text/plain; charset=utf-8")
                shortURL := baseURL + "/" + shortKey

                if errors.Is(err, storage.ErrURLExists) </span><span class="cov1" title="1">{
                        res.WriteHeader(http.StatusConflict)
                        log.Debug("URL already exists",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span> else<span class="cov1" title="1"> {
                        res.WriteHeader(http.StatusCreated)
                        log.Debug("URL successfully shortened",
                                zap.String("shortKey", shortKey),
                                zap.String("originalURL", originalURL))
                }</span>

                <span class="cov6" title="2">if _, err := res.Write([]byte(shortURL)); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to write response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package stats   HTTP    .
package stats

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/ryabkov82/shortener/internal/app/models"
        "go.uber.org/zap"
)

// URLHandler      .
//         URL  .
type URLHandler interface {
        // GetStats   .
        // :
        //   - models.StatsResponse   URL  
        //   - error      
        GetStats(ctx context.Context) (models.StatsResponse, error)
}

// GetHandler  HTTP-    .
//
// :
//   - urlHandler:   URLHandler    
//   - log:      
//
// :
//   - http.HandlerFunc,   GET-   /api/internal/stats
//
//  :
//   -    trusted_subnet (    middleware)
//   - :
//   - 200 OK  JSON     
//   - 403 Forbidden  IP    
//   - 500 Internal Server Error    
//   -      
//
//    :
//
//        {
//          "urls": 100,
//          "users": 50
//        }
//
// Middleware:
//   -    trustednet.CheckTrustedSubnet   
//   -   mwlogger.RequestLogging   
func GetHandler(urlHandler URLHandler, log *zap.Logger) http.HandlerFunc <span class="cov6" title="2">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="3">{

                ctx := req.Context()

                stats, err := urlHandler.GetStats(ctx)

                if err != nil </span><span class="cov6" title="2">{
                        http.Error(res, "Failed to get stats", http.StatusInternalServerError)
                        log.Error("Failed to get stats",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                <span class="cov1" title="1">log.Debug("Stats received successfully",
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))

                res.Header().Set("Content-Type", "application/json")
                res.WriteHeader(http.StatusOK)
                //    
                if err := json.NewEncoder(res).Encode(stats); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to encode response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package userurls      URL .
//
//  :
// -    URL  
// -    JSON-
// -    URL
package userurls

import (
        "context"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/models"
)

// URLHandler     URL .
type URLHandler interface {
        // GetUserUrls    URL .
        //
        // :
        //   ctx -   (   )
        //   baseURL -       URL
        //
        // :
        //   []models.URLMapping -      URL
        //   error -   (,   )
        GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error)
}

// GetHandler  HTTP-   URL .
//
//  API:
//
//        : GET
//        : /api/user/urls
//        : JWT-
//
//  :
//
//        [
//          {
//            "short_url": "http://short.ly/abc123",
//            "original_url": "https://example.com/long/url"
//          },
//          ...
//        ]
//
//  :
//   - 200 OK:   (  URL)
//   - 204 No Content:     URL
//   - 400 Bad Request:  
//   - 500 Internal Server Error:   
//
// :
//
//        urlHandler -    URL
//        baseURL -   
//        log -    
//
// :
//
//        http.HandlerFunc - HTTP-
func GetHandler(urlHandler URLHandler, baseURL string, log *zap.Logger) http.HandlerFunc <span class="cov1" title="1">{
        return func(res http.ResponseWriter, req *http.Request) </span><span class="cov10" title="2">{
                //    
                responseData, err := urlHandler.GetUserUrls(req.Context(), baseURL)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Failed to get user URLs", http.StatusInternalServerError)
                        log.Error("Failed to retrieve user URLs",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                //    URL
                <span class="cov10" title="2">if len(responseData) == 0 </span><span class="cov1" title="1">{
                        res.WriteHeader(http.StatusNoContent)
                        log.Debug("No URLs found for user",
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                        return
                }</span>

                //  JSON-
                <span class="cov1" title="1">res.Header().Set("Content-Type", "application/json")
                res.WriteHeader(http.StatusOK)

                encoder := json.NewEncoder(res)
                encoder.SetIndent("", "  ") //  JSON  
                if err := encoder.Encode(responseData); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to encode response",
                                zap.Error(err),
                                zap.String("method", req.Method),
                                zap.String("path", req.URL.Path))
                }</span>

                <span class="cov1" title="1">log.Debug("Successfully returned user URLs",
                        zap.Int("count", len(responseData)),
                        zap.String("method", req.Method),
                        zap.String("path", req.URL.Path))</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package httpgzip       HTTP-   gzip.
//    gzip.Writer  gzip.Reader   .
package httpgzip

import (
        "compress/gzip"
        "io"
        "net/http"
        "sync"
)

//  gzip.Writer    
var writerPool = sync.Pool{
        New: func() interface{} <span class="cov10" title="105">{
                return gzip.NewWriter(io.Discard)
        }</span>,
}

//  gzip.Reader    
var readerPool = sync.Pool{
        New: func() interface{} <span class="cov9" title="101">{
                return new(gzip.Reader)
        }</span>,
}

// init     .
//
//       
//        .
func init() <span class="cov5" title="9">{
        for i := 0; i &lt; 10; i++ </span><span class="cov9" title="90">{
                writerPool.Put(writerPool.New())
                readerPool.Put(readerPool.New())
        }</span>
}

// PutWriter  gzip.Writer     .
//
// :
//   - zw: gzip.Writer    
func PutWriter(zw *gzip.Writer) <span class="cov8" title="48">{
        writerPool.Put(zw)
}</span>

// PutReader  gzip.Reader     .
//
// :
//   - zr: gzip.Reader    
func PutReader(zr *gzip.Reader) <span class="cov6" title="20">{
        readerPool.Put(zr)
}</span>

// compressWriter  http.ResponseWriter   gzip-.
type compressWriter struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

// NewCompressWriter   compressWriter.
//
// :
//   - w:  http.ResponseWriter
//
// :
//   - *compressWriter:    
func NewCompressWriter(w http.ResponseWriter) *compressWriter <span class="cov8" title="48">{
        zw := writerPool.Get().(*gzip.Writer)
        zw.Reset(w)
        return &amp;compressWriter{
                w:  w,
                zw: zw,
        }
}</span>

// Header  HTTP- .
func (c *compressWriter) Header() http.Header <span class="cov8" title="43">{
        return c.w.Header()
}</span>

// Write     .
func (c *compressWriter) Write(p []byte) (int, error) <span class="cov7" title="34">{
        c.w.Header().Del("Content-Length")
        return c.zw.Write(p)
}</span>

// WriteHeader      .
func (c *compressWriter) WriteHeader(statusCode int) <span class="cov8" title="48">{
        c.w.Header().Set("Content-Encoding", "gzip")
        c.w.WriteHeader(statusCode)
}</span>

// Close  writer     .
func (c *compressWriter) Close() error <span class="cov8" title="48">{
        err := c.zw.Close()
        PutWriter(c.zw)
        return err
}</span>

// compressReader  io.ReadCloser   gzip-.
type compressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

// NewCompressReader   compressReader.
//
// :
//   - r:  io.ReadCloser
//
// :
//   - *compressReader:    
//   - error:  
func NewCompressReader(r io.ReadCloser) (*compressReader, error) <span class="cov6" title="20">{
        zr := readerPool.Get().(*gzip.Reader)
        if err := zr.Reset(r); err != nil </span><span class="cov0" title="0">{
                readerPool.Put(zr)
                return nil, err
        }</span>
        <span class="cov6" title="20">return &amp;compressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

// Read    .
func (c compressReader) Read(p []byte) (n int, err error) <span class="cov6" title="20">{
        return c.zr.Read(p)
}</span>

// Close  reader     .
func (c *compressReader) Close() error <span class="cov6" title="20">{
        err := c.r.Close()
        PutReader(c.zr)
        return err
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package jwtauth      JWT  .
package jwtauth

import (
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// Claims   claims JWT .
//      claims.
type Claims struct {
        UserID               string `json:"user_id"` //   
        jwt.RegisteredClaims        //  claims JWT
}

// ContextKey    .
//        context.Context.
type ContextKey string

// UserIDContextKey    ID   .
const UserIDContextKey ContextKey = "userID"

// GenerateNewToken   JWT   .
//
// :
//   - jwtKey:     
//
// :
//   - string:  JWT 
//   - string:  ID 
//   - error:   
//
//  :
//
//        token, userID, err := GenerateNewToken([]byte("secret"))
func GenerateNewToken(jwtKey []byte) (string, string, error) <span class="cov10" title="30">{
        userID := uuid.New().String() //   ID 

        claims := &amp;Claims{
                UserID: userID,
                //      :
                // RegisteredClaims: jwt.RegisteredClaims{
                //     ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
                // },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString(jwtKey)
        return tokenString, userID, err
}</span>

// CreateToken  JWT  userID
func CreateToken(jwtKey []byte, userID string) (string, error) <span class="cov5" title="6">{

        claims := &amp;Claims{
                UserID: userID,
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtKey)

}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package logger      
//   zap.Logger.        .
package logger

import (
        "go.uber.org/zap"
)

// Log -   ,  no-op   .
// No-op         .
var Log *zap.Logger = zap.NewNop()

// Initialize       .
//
// :
//   - level: ,    (debug, info, warn, error, dpanic, panic, fatal)
//
// :
//   - error: ,           
//
//  :
//
//        err := logger.Initialize("debug")
//        if err != nil {
//            //   
//        }
//        logger.Log.Info("  ")
func Initialize(level string) error <span class="cov10" title="13">{
        //     zap.AtomicLevel
        lvl, err := zap.ParseAtomicLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //    production- (JSON-, stacktrace  )
        <span class="cov10" title="13">cfg := zap.NewProductionConfig()

        //   
        cfg.Level = lvl

        //     
        zl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //   
        <span class="cov10" title="13">Log = zl
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package pprof  HTTP-   
//     net/http/pprof.
package pprof

import (
        "net/http"
        "net/http/pprof"

        "go.uber.org/zap"

        "github.com/go-chi/chi/v5"

        "github.com/ryabkov82/shortener/internal/app/config"
)

// StartPProf  HTTP-   .
//
// :
//   - log:    
//   - config:   
//   - Enabled:   
//   - BindAddr:    (, "localhost:6060")
//   - Endpoint:  URL   (, "/debug/pprof")
//   - AuthUser:   HTTP Basic Auth
//   - AuthPass:   HTTP Basic Auth
//
//  :
//
//        cfg := config.PProfConfig{
//            Enabled:  true,
//            BindAddr: "localhost:6060",
//            Endpoint: "/debug/pprof",
//            AuthUser: "admin",
//            AuthPass: "secret",
//        }
//        pprof.StartPProf(logger.Log, cfg)
func StartPProf(log *zap.Logger, config config.PProfConfig) <span class="cov1" title="1">{
        if !config.Enabled </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov0" title="0">r := chi.NewRouter()

        registerPProfRoutes(r, config)

        server := &amp;http.Server{
                Addr:    config.BindAddr,
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error("failed to serve pprof server", zap.Error(err))
                }</span>
        }()
}

// basicAuthMiddleware  middleware  HTTP Basic Authentication.
//
// :
//   - expectedUser:   
//   - expectedPass:  
//
// :
//   - middleware   chi.Router
func basicAuthMiddleware(expectedUser, expectedPass string) func(http.Handler) http.Handler <span class="cov3" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov3" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="14">{
                        user, password, ok := r.BasicAuth()

                        if !ok || user != expectedUser || password != expectedPass </span><span class="cov4" title="3">{
                                w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov9" title="11">next.ServeHTTP(w, r)</span>
                })
        }
}

//    pprof
func registerPProfRoutes(r *chi.Mux, config config.PProfConfig) <span class="cov1" title="1">{
        if !config.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">r.Route(config.Endpoint, func(r chi.Router) </span><span class="cov1" title="1">{
                //     -
                r.Use(basicAuthMiddleware(config.AuthUser, config.AuthPass))

                //    pprof
                r.Get("/", http.HandlerFunc(pprof.Index))
                r.Get("/cmdline", http.HandlerFunc(pprof.Cmdline))
                r.Get("/profile", http.HandlerFunc(pprof.Profile))
                r.Get("/symbol", http.HandlerFunc(pprof.Symbol))
                r.Get("/trace", http.HandlerFunc(pprof.Trace))

                //   
                r.Handle("/goroutine", pprof.Handler("goroutine"))
                r.Handle("/heap", pprof.Handler("heap"))
                r.Handle("/allocs", pprof.Handler("allocs"))
                r.Handle("/threadcreate", pprof.Handler("threadcreate"))
                r.Handle("/block", pprof.Handler("block"))
                r.Handle("/mutex", pprof.Handler("mutex"))
        }</span>)
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package interceptors

import (
        "context"
        "fmt"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"

        "github.com/golang-jwt/jwt/v5"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// JWTAutoIssueGRPC  gRPC-  JWT-    .
//
//  :
//   -  JWT-   gRPC- ( "token")
//   -      , :
//   -  
//   -  
//   -    UserID
//   -  UserID      
//   -      (. isPublicMethod)
//
// :
//   - jwtKey:     JWT-
//
// :
//   - grpc.UnaryServerInterceptor:   
//
//  :
//   -      gRPC (metadata)
//   -       (grpc.SetHeader)
//   -     isPublicMethod
//   -   UserID ( jwtauth.UserIDContextKey)
//
//  :
//
//        server := grpc.NewServer(
//            grpc.ChainUnaryInterceptor(
//                interceptor.JWTAutoIssueGRPC([]byte("secret")),
//            ),
//        )
//
//  :
//  1.    isPublicMethod
//  2.    metadata["token"]
//  3.     claims
//  4.     
//  5.  UserID  
//  6.   
func JWTAutoIssueGRPC(jwtKey []byte) grpc.UnaryServerInterceptor <span class="cov7" title="10">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov10" title="23">{
                //     
                if isPublicMethod(info.FullMethod) </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                //  r.Cookie()  HTTP -    
                <span class="cov10" title="23">md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return issueNewTokenAndHandle(ctx, req, handler, jwtKey)
                }</span>

                <span class="cov10" title="23">tokens := md.Get("token")
                if len(tokens) == 0 </span><span class="cov6" title="7">{
                        return issueNewTokenAndHandle(ctx, req, handler, jwtKey)
                }</span>

                //     ( HTTP)
                <span class="cov8" title="16">claims := &amp;jwtauth.Claims{}

                token, err := jwt.ParseWithClaims(tokens[0], claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="16">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov8" title="16">return jwtKey, nil</span>
                })

                <span class="cov8" title="16">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        return issueNewTokenAndHandle(ctx, req, handler, jwtKey)
                }</span>

                //   ,  userID  
                <span class="cov8" title="16">userID := claims.UserID
                if userID == "" </span><span class="cov0" title="0">{
                        return issueNewTokenAndHandle(ctx, req, handler, jwtKey)
                }</span>

                <span class="cov8" title="16">newCtx := context.WithValue(ctx, jwtauth.UserIDContextKey, claims.UserID)
                return handler(newCtx, req)</span>
        }
}

func StrictJWTAutoIssueGRPC(jwtKey []byte) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov0" title="0">{
                //     
                if isPublicMethod(info.FullMethod) </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{

                        err := issueNewToken(ctx, jwtKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, "failed to generate token")
                        }</span>
                        <span class="cov0" title="0">return nil, status.Error(codes.Unauthenticated, "status unauthenticated")</span>
                }

                <span class="cov0" title="0">tokens := md.Get("token")
                if len(tokens) == 0 </span><span class="cov0" title="0">{
                        err := issueNewToken(ctx, jwtKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, "failed to generate token")
                        }</span>
                        <span class="cov0" title="0">return nil, status.Error(codes.Unauthenticated, "status unauthenticated")</span>
                }

                //     ( HTTP)
                <span class="cov0" title="0">claims := &amp;jwtauth.Claims{}

                token, err := jwt.ParseWithClaims(tokens[0], claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return jwtKey, nil</span>
                })

                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        err := issueNewToken(ctx, jwtKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, "failed to generate token")
                        }</span>
                        <span class="cov0" title="0">return nil, status.Error(codes.Unauthenticated, "status unauthenticated")</span>
                }

                //   ,  userID  
                <span class="cov0" title="0">userID := claims.UserID
                if userID == "" </span><span class="cov0" title="0">{
                        err := issueNewToken(ctx, jwtKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, "failed to generate token")
                        }</span>
                        <span class="cov0" title="0">return nil, status.Error(codes.Unauthenticated, "status unauthenticated")</span>
                }

                <span class="cov0" title="0">newCtx := context.WithValue(ctx, jwtauth.UserIDContextKey, claims.UserID)
                return handler(newCtx, req)</span>
        }
}

func issueNewToken(
        ctx context.Context,
        jwtKey []byte,
) error <span class="cov0" title="0">{
        //   
        token, _, err := jwtauth.GenerateNewToken(jwtKey)
        if err != nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.Internal, "failed to create token")
        }</span>

        //      ( Set-Cookie)
        <span class="cov0" title="0">header := metadata.Pairs("token", token)
        grpc.SetHeader(ctx, header)

        return nil</span>
}

//  issueNewToken  HTTP-
func issueNewTokenAndHandle(
        ctx context.Context,
        req interface{},
        handler grpc.UnaryHandler,
        jwtKey []byte,
) (interface{}, error) <span class="cov6" title="7">{
        //   
        token, userID, err := jwtauth.GenerateNewToken(jwtKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to create token")
        }</span>

        //      ( Set-Cookie)
        <span class="cov6" title="7">header := metadata.Pairs("token", token)
        grpc.SetHeader(ctx, header)

        //  userID  
        newCtx := context.WithValue(ctx, jwtauth.UserIDContextKey, userID)
        return handler(newCtx, req)</span>
}

func isPublicMethod(method string) bool <span class="cov10" title="23">{
        publicMethods := map[string]bool{
                "/grpc.health.v1.Health/Check": true,
                //   
        }
        return publicMethods[method]
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package interceptors

import (
        "context"
        "time"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/status"
)

// LoggingInterceptor  gRPC-    .
//
//  :
//   -     (info.FullMethod)
//   -   (req)
//   -   (   )
//   -   
//
// :
//   - log:  zap    (   )
//
// :
//   - grpc.UnaryServerInterceptor:   
//
//  :
//   -      
//   -      
//   -    gRPC-   
//   -     INFO
//
//  :
//
//        logger, _ := zap.NewProduction()
//        server := grpc.NewServer(
//            grpc.ChainUnaryInterceptor(
//                LoggingInterceptor(logger),
//            ),
//        )
//
//  :
//
//        {
//          "method": "/service.Name/MethodName",
//          "request": {...},
//          "status_code": 2,
//          "status": "UNKNOWN",
//          "duration": "12.345ms"
//        }
func LoggingInterceptor(log *zap.Logger) grpc.UnaryServerInterceptor <span class="cov7" title="10">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (resp interface{}, err error) </span><span class="cov10" title="23">{
                //    
                startTime := time.Now()

                //    
                defer func() </span><span class="cov10" title="23">{
                        duration := time.Since(startTime)
                        st, _ := status.FromError(err)

                        log.Info("gRPC request completed",
                                zap.String("method", info.FullMethod),     //    ( /shortener.Shortener/CreateShortURL)
                                zap.Any("request", req),                   //  
                                zap.Int("status_code", int(st.Code())),    //   gRPC
                                zap.String("status", st.Code().String()),  //  
                                zap.String("duration", duration.String()), //  
                        )
                }</span>()

                //   
                <span class="cov10" title="23">return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// internal/server/grpc/interceptors/trusted_subnet.go
package interceptors

import (
        "context"
        "net"
        "strings"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/peer"
        "google.golang.org/grpc/status"
)

// TrustedSubnetConfig       .
//
//      gRPC-    IP-.
//   TrustedSubnetInterceptor.
//
// :
//
//   - TrustedSubnet:   CIDR-,   .
//     : "IPv4/"  "IPv6/" ( "192.168.1.0/24").
//          .
//
//   - ProtectedMethods: map[string]bool,   -   gRPC-,
//        .   :
//
//   -    ( "/shortener.Shortener/Stats")
//
//   -   ( "/shortener.Admin/"    )
//     :  .
//
//   - DenyIfNotConfigured: ,      .
//
//   - true -   PermissionDenied
//
//   - false -    
//        production: true.
type TrustedSubnetConfig struct {
        TrustedSubnet string
        // ,   (: ["/shortener.Shortener/Stats"])
        ProtectedMethods map[string]bool
        //      (true)   (false)
        DenyIfNotConfigured bool
}

// TrustedSubnetInterceptor  gRPC-      .
//
//  :
//   -   IP-     
//   -        (. TrustedSubnetConfig)
//   -       
//
// :
//   - cfg:   (TrustedSubnetConfig):
//   - TrustedSubnet: CIDR-  ( "192.168.1.0/24")
//   - ProtectedMethods:   gRPC-
//   - DenyIfNotConfigured:      
//
// :
//   - grpc.UnaryServerInterceptor:    
//
//  :
//  1.      ProtectedMethods
//  2.    :
//     - DenyIfNotConfigured=true:  PermissionDenied
//     - DenyIfNotConfigured=false:  
//  3.  IP-  (X-Forwarded-For  X-Real-IP  peer)
//  4.   IP   
//  5.  :  PermissionDenied   
//
//  :
//
//        interceptor := TrustedSubnetInterceptor(TrustedSubnetConfig{
//            TrustedSubnet: "10.0.0.0/8",
//            ProtectedMethods: map[string]bool{
//                "/shortener.Shortener/Stats": true,
//            },
//            DenyIfNotConfigured: true,
//        })
//        server := grpc.NewServer(grpc.ChainUnaryInterceptor(interceptor))
//
// :
//   -  CIDR-  IPv4/IPv6
//   -    (X-Forwarded-For/X-Real-IP)
//   -    ProtectedMethods ( wildcards)
//   -    
//
// :
//   -       ProtectedMethods
//   -  production   DenyIfNotConfigured=true
//   -     
func TrustedSubnetInterceptor(cfg TrustedSubnetConfig) grpc.UnaryServerInterceptor <span class="cov9" title="5">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov10" title="6">{
                // ,      
                if !cfg.isMethodProtected(info.FullMethod) </span><span class="cov4" title="2">{
                        return handler(ctx, req)
                }</span>

                //    
                <span class="cov7" title="4">if cfg.TrustedSubnet == "" </span><span class="cov0" title="0">{
                        if cfg.DenyIfNotConfigured </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.PermissionDenied, "trusted subnet not configured")
                        }</span>
                        <span class="cov0" title="0">return handler(ctx, req)</span>
                }

                //  IP 
                <span class="cov7" title="4">clientIP, err := getClientIP(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.PermissionDenied, err.Error())
                }</span>

                //   
                <span class="cov7" title="4">_, subnet, err := net.ParseCIDR(cfg.TrustedSubnet)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, "invalid trusted subnet configuration")
                }</span>

                //   IP  
                <span class="cov7" title="4">ip := net.ParseIP(clientIP)
                if ip == nil || !subnet.Contains(ip) </span><span class="cov1" title="1">{
                        return nil, status.Error(codes.PermissionDenied, "access denied: IP not in trusted subnet")
                }</span>

                <span class="cov6" title="3">return handler(ctx, req)</span>
        }
}

func (c *TrustedSubnetConfig) isMethodProtected(method string) bool <span class="cov10" title="6">{
        //    
        if c.ProtectedMethods[method] </span><span class="cov7" title="4">{
                return true
        }</span>

        //     (  )
        <span class="cov4" title="2">for m := range c.ProtectedMethods </span><span class="cov4" title="2">{
                if strings.HasPrefix(method, m) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov4" title="2">return false</span>
}

func getClientIP(ctx context.Context) (string, error) <span class="cov7" title="4">{
        // 1.    X-Forwarded-For (  )
        if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov7" title="4">{
                if forwardedIPs := md.Get("x-forwarded-for"); len(forwardedIPs) &gt; 0 </span><span class="cov0" title="0">{
                        return strings.Split(forwardedIPs[0], ",")[0], nil
                }</span>
                <span class="cov7" title="4">if realIPs := md.Get("x-real-ip"); len(realIPs) &gt; 0 </span><span class="cov7" title="4">{
                        return realIPs[0], nil
                }</span>
        }

        // 2.   peer 
        <span class="cov0" title="0">if p, ok := peer.FromContext(ctx); ok </span><span class="cov0" title="0">{
                switch addr := p.Addr.(type) </span>{
                case *net.TCPAddr:<span class="cov0" title="0">
                        return addr.IP.String(), nil</span>
                case *net.UDPAddr:<span class="cov0" title="0">
                        return addr.IP.String(), nil</span>
                default:<span class="cov0" title="0">
                        return addr.String(), nil</span>
                }
        }

        <span class="cov0" title="0">return "", status.Error(codes.PermissionDenied, "could not determine client IP")</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package grpcserver

import (
        "net"

        "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/config"
        grpchandlers "github.com/ryabkov82/shortener/internal/app/handlers/grpc"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/base"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/batch"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/deluserurls"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/ping"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/redirect"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/shorturl"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/stats"
        "github.com/ryabkov82/shortener/internal/app/handlers/grpc/userurls"
        "github.com/ryabkov82/shortener/internal/app/service"
        "go.uber.org/zap"
        "google.golang.org/grpc"
)

// StartGRPCServer    gRPC 
func StartGRPCServer(log *zap.Logger, cfg *config.Config, srv *service.Service) *grpc.Server <span class="cov0" title="0">{

        //      
        baseHandler := base.NewBaseHandler(log)

        //   
        shorturlHandler := shorturl.New(
                baseHandler,
                srv,
                cfg.BaseURL,
        )

        redirectHandler := redirect.New(
                baseHandler,
                srv,
        )

        batchHandler := batch.New(
                baseHandler,
                srv,
                cfg.BaseURL,
        )

        deluserurlsHandler := deluserurls.New(
                baseHandler,
                srv,
        )

        userurlsHandler := userurls.New(
                baseHandler,
                srv,
                cfg.BaseURL,
        )

        statsHandler := stats.New(
                baseHandler,
                srv,
        )

        pingHandler := ping.New(
                baseHandler,
                srv,
        )

        //   
        aggregateHandler := grpchandlers.NewServer(
                baseHandler,
                grpchandlers.WithCreateShortURLEndpoint(shorturlHandler),
                grpchandlers.WithGetOriginalURLEndpoint(redirectHandler),
                grpchandlers.WithBatchCreateEndpoint(batchHandler),
                grpchandlers.WithDeleteUserURLsEndpoint(deluserurlsHandler),
                grpchandlers.WithGetUserURLsEndpoint(userurlsHandler),
                grpchandlers.WithGetStatsEndpoint(statsHandler),
                grpchandlers.WithPingEndpoint(pingHandler),
        )

        commonInterceptors := baseHandler.CommonInterceptors(cfg)

        grpcServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(commonInterceptors...),
        )

        //  gRPC 
        api.RegisterShortenerServer(grpcServer, aggregateHandler)

        lis, err := net.Listen("tcp", cfg.GRPCServerAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to listen gRPC", zap.Error(err))
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info("Starting gRPC server", zap.String("address", cfg.GRPCServerAddr))
                if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Error("gRPC server failed", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">return grpcServer</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package auth  middleware    JWT.
package auth

import (
        "context"
        "fmt"
        "net/http"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ryabkov82/shortener/internal/app/jwtauth"
)

// JWTAutoIssue  middleware    JWT .
//
// Middleware    JWT   cookies:
// -      -   
// -    -  userID    
//
// :
//
//        jwtKey -    JWT 
//
// :
//
//        func(next http.Handler) http.Handler - middleware 
func JWTAutoIssue(jwtKey []byte) func(next http.Handler) http.Handler <span class="cov5" title="6">{
        return func(next http.Handler) http.Handler </span><span class="cov7" title="10">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="27">{
                        cookie, err := r.Cookie("token")
                        if err != nil || cookie == nil </span><span class="cov4" title="4">{
                                userID := issueNewToken(w, jwtKey)
                                ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, userID)
                                r = r.WithContext(ctx)
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov9" title="23">tokenStr := cookie.Value
                        claims := &amp;jwtauth.Claims{}

                        token, err := jwt.ParseWithClaims(tokenStr, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov9" title="23">{
                                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                                }</span>
                                <span class="cov9" title="23">return jwtKey, nil</span>
                        })

                        <span class="cov9" title="23">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                                userID := issueNewToken(w, jwtKey)
                                ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, userID)
                                r = r.WithContext(ctx)
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov9" title="23">ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, claims.UserID)
                        r = r.WithContext(ctx)
                        next.ServeHTTP(w, r)</span>
                }

                <span class="cov7" title="10">return http.HandlerFunc(fn)</span>
        }
}

// StrictJWTAutoIssue   middleware   JWT .
//
//    JWTAutoIssue:
// -      / 
// -  401 Unauthorized    
//
// :
//
//        jwtKey -    JWT 
//
// :
//
//        func(next http.Handler) http.Handler - middleware 
func StrictJWTAutoIssue(jwtKey []byte) func(next http.Handler) http.Handler <span class="cov4" title="3">{
        return func(next http.Handler) http.Handler </span><span class="cov4" title="4">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov9" title="19">{
                        cookie, err := r.Cookie("token")
                        if err != nil || cookie == nil </span><span class="cov2" title="2">{
                                _ = issueNewToken(w, jwtKey)
                                http.Error(w, "Status unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="17">tokenStr := cookie.Value
                        claims := &amp;jwtauth.Claims{}

                        token, err := jwt.ParseWithClaims(tokenStr, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="17">{
                                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                                }</span>
                                <span class="cov8" title="17">return jwtKey, nil</span>
                        })

                        <span class="cov8" title="17">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                                _ = issueNewToken(w, jwtKey)
                                http.Error(w, "Status unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="17">ctx := context.WithValue(r.Context(), jwtauth.UserIDContextKey, claims.UserID)
                        r = r.WithContext(ctx)
                        next.ServeHTTP(w, r)</span>
                }

                <span class="cov4" title="4">return http.HandlerFunc(fn)</span>
        }
}

// issueNewToken     JWT .
//
// :
//
//        w - http.ResponseWriter   cookie
//        jwtKey -    JWT
//
// :
//
//        string -   (userID)
func issueNewToken(w http.ResponseWriter, jwtKey []byte) string <span class="cov5" title="6">{
        token, userID, err := jwtauth.GenerateNewToken(jwtKey)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate token", http.StatusInternalServerError)
                return ""
        }</span>
        <span class="cov5" title="6">setTokenCookie(w, token)
        return userID</span>
}

// setTokenCookie  JWT   cookie.
//
// :
//
//        w - http.ResponseWriter   cookie
//        token - JWT   
func setTokenCookie(w http.ResponseWriter, token string) <span class="cov5" title="6">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "token",
                Value:    token,
                HttpOnly: true,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
        })
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package logger  middleware   HTTP-.
package logger

import (
        "net/http"
        "time"

        "github.com/go-chi/chi/v5/middleware"
        "go.uber.org/zap"
)

// RequestLogging  middleware   HTTP-.
//
// Middleware :
// - HTTP-
// -  
// -  
// -    
// -   
//
// :
//
//        log -  zap   
//
// :
//
//        func(next http.Handler) http.Handler - middleware 
func RequestLogging(log *zap.Logger) func(next http.Handler) http.Handler <span class="cov6" title="11">{
        return func(next http.Handler) http.Handler </span><span class="cov6" title="11">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="53">{
                        //    ResponseWriter    
                        ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        //     
                        t1 := time.Now()

                        //      
                        defer func() </span><span class="cov10" title="53">{
                                log.Info("request completed",
                                        zap.String("method", r.Method),                  // HTTP- (GET, POST  ..)
                                        zap.String("path", r.URL.Path),                  //  
                                        zap.Int("status", ww.Status()),                  // HTTP- 
                                        zap.Int("bytes", ww.BytesWritten()),             //    
                                        zap.String("duration", time.Since(t1).String()), //  
                                )
                        }</span>()

                        //    
                        <span class="cov10" title="53">next.ServeHTTP(ww, r)</span>
                }

                <span class="cov6" title="11">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package mwgzip  middleware     HTTP-   gzip.
package mwgzip

import (
        "net/http"
        "strings"

        "github.com/ryabkov82/shortener/internal/app/httpgzip"
)

// Gzip  middleware   gzip  HTTP-  .
//
// Middleware :
// -    gzip,      
// -   ,    gzip
// -   ,  gzip  
//
// :
//
//        func(next http.Handler) http.Handler - middleware 
func Gzip(next http.Handler) http.Handler <span class="cov6" title="9">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="48">{
                //   ResponseWriter  
                ow := w

                //   gzip   
                acceptEncoding := r.Header.Get("Accept-Encoding")
                supportsGzip := strings.Contains(acceptEncoding, "gzip")
                if supportsGzip </span><span class="cov10" title="48">{
                        //     
                        cw := httpgzip.NewCompressWriter(w)
                        ow = cw
                        //   
                        defer cw.Close()
                }</span>

                //    
                <span class="cov10" title="48">contentEncoding := r.Header.Get("Content-Encoding")
                sendsGzip := strings.Contains(contentEncoding, "gzip")
                if sendsGzip </span><span class="cov7" title="20">{
                        //  reader   
                        cr, err := httpgzip.NewCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov7" title="20">r.Body = cr
                        defer cr.Close()</span>
                }

                //    
                <span class="cov10" title="48">next.ServeHTTP(ow, r)</span>
        }

        <span class="cov6" title="9">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Package trustednet  security-  HTTP-.

    IP-   
  .   :

1.   API 
2.     

  nginx   :

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_pass http://backend;
        }
*/
package trustednet

import (
        "net"
        "net/http"
)

// CheckTrustedSubnet  middleware      .
//
// :
//   - trustedSubnet:    CIDR (, "192.168.1.0/24"),
//       .    -    .
//
// :
//   - Middleware   chi.Router   http.Handler
//
//  :
//  1.  trustedSubnet  -     403 Forbidden
//  2.    X-Real-IP
//  3.   IP-
//  4.   IP   
//
//  :
//   - 403 Forbidden:
//   - trustedSubnet 
//   -  X-Real-IP
//   - IP     
//   - 500 Internal Server Error:   trustedSubnet
//
//  :
//
//        r := chi.NewRouter()
//        r.Use(CheckTrustedSubnet("192.168.1.0/24"))
//        r.Get("/admin", adminHandler)
//
// :
//   -  middleware    proxy (, nginx), 
//       X-Real-IP   IP 
//   -  trustedSubnet    CIDR
func CheckTrustedSubnet(trustedSubnet string) func(http.Handler) http.Handler <span class="cov4" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov4" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="5">{
                        if trustedSubnet == "" </span><span class="cov1" title="1">{
                                http.Error(w, "Access denied", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov8" title="4">realIP := r.Header.Get("X-Real-IP")
                        if realIP == "" </span><span class="cov0" title="0">{
                                http.Error(w, "X-Real-IP header required", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov8" title="4">_, subnet, err := net.ParseCIDR(trustedSubnet)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Invalid trusted subnet configuration", http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="4">ip := net.ParseIP(realIP)
                        if ip == nil || !subnet.Contains(ip) </span><span class="cov1" title="1">{
                                http.Error(w, "Access denied", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov7" title="3">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package httpserver

import (
        "net/http"

        "go.uber.org/zap"

        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/batch"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/deluserurls"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/ping"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/redirect"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/shortenapi"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/shorturl"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/stats"
        "github.com/ryabkov82/shortener/internal/app/handlers/http/userurls"
        "github.com/ryabkov82/shortener/internal/app/server/http/middleware/auth"
        mwlogger "github.com/ryabkov82/shortener/internal/app/server/http/middleware/logger"
        "github.com/ryabkov82/shortener/internal/app/server/http/middleware/mwgzip"
        "github.com/ryabkov82/shortener/internal/app/server/http/middleware/trustednet"
        "github.com/ryabkov82/shortener/internal/app/service"

        "github.com/go-chi/chi/v5"
)

// StartHTTPServer  HTTP-.
func StartHTTPServer(log *zap.Logger, cfg *config.Config, srv *service.Service) *http.Server <span class="cov0" title="0">{

        log.Info("Starting http server", zap.String("address", cfg.HTTPServerAddr), zap.String("BaseURL", cfg.BaseURL))

        router := setupRouter(log, cfg, srv)

        server := &amp;http.Server{
                Addr:    cfg.HTTPServerAddr,
                Handler: router,
        }

        go runServer(log, server, cfg)
        return server

}</span>

//   
func setupRouter(log *zap.Logger, cfg *config.Config, srv *service.Service) http.Handler <span class="cov0" title="0">{

        router := chi.NewRouter()
        //  middleware  
        router.Use(mwlogger.RequestLogging(log))
        router.Use(mwgzip.Gzip)

        router.Use(auth.JWTAutoIssue([]byte(cfg.JwtKey)))

        router.Post("/", shorturl.GetHandler(srv, cfg.BaseURL, log))
        router.Get("/{id}", redirect.GetHandler(srv, log))

        router.Post("/api/shorten", shortenapi.GetHandler(srv, cfg.BaseURL, log))

        router.Get("/ping", ping.GetHandler(srv, log))
        router.Post("/api/shorten/batch", batch.GetHandler(srv, cfg.BaseURL, log))
        router.Get("/api/user/urls", userurls.GetHandler(srv, cfg.BaseURL, log))
        router.Delete("/api/user/urls", deluserurls.GetHandler(srv, cfg.BaseURL, log))

        router.Group(func(router chi.Router) </span><span class="cov0" title="0">{
                router.Use(trustednet.CheckTrustedSubnet(cfg.TrustedSubnet))
                router.Get("/api/internal/stats", stats.GetHandler(srv, log))
        }</span>)

        <span class="cov0" title="0">return router</span>
}

func runServer(log *zap.Logger, server *http.Server, cfg *config.Config) <span class="cov0" title="0">{

        if cfg.EnableHTTPS </span><span class="cov0" title="0">{
                //    HTTPS
                go func() </span><span class="cov0" title="0">{
                        if err := server.ListenAndServeTLS(cfg.SSLCertFile, cfg.SSLKeyFile); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                log.Error("failed to serve server", zap.Error(err))
                        }</span>
                }()
        } else<span class="cov0" title="0"> {
                go func() </span><span class="cov0" title="0">{
                        if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                log.Error("failed to serve server", zap.Error(err))
                        }</span>
                }()
        }

        <span class="cov0" title="0">log.Info("Server started", zap.String("address", cfg.HTTPServerAddr))</span>

}
</pre>
		
		<pre class="file" id="file38" style="display: none">// internal/server/run.go
package server

import (
        "context"
        "net/http"
        _ "net/http/pprof"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/ryabkov82/shortener/internal/app/config"
        "github.com/ryabkov82/shortener/internal/app/pprof"
        grpcserver "github.com/ryabkov82/shortener/internal/app/server/grpc"
        httpserver "github.com/ryabkov82/shortener/internal/app/server/http"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/internal/app/storage/inmemory"
        "github.com/ryabkov82/shortener/internal/app/storage/postgres"
        "google.golang.org/grpc"

        "go.uber.org/zap"
)

func StartServers(log *zap.Logger, cfg *config.Config) <span class="cov0" title="0">{

        pprof.StartPProf(log, cfg.ConfigPProf)

        // 1.    
        storage, err := initStorage(cfg, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to initialize storage", zap.Error(err))
        }</span>

        <span class="cov0" title="0">appService := service.NewService(storage)

        // 2.  
        httpServer := httpserver.StartHTTPServer(log, cfg, appService)
        grpcServer := grpcserver.StartGRPCServer(log, cfg, appService)

        // 3. Graceful shutdown
        waitForShutdown(log, httpServer, grpcServer, appService)</span>
}

//  
func initStorage(cfg *config.Config, log *zap.Logger) (service.Repository, error) <span class="cov0" title="0">{
        if cfg.DBConnect != "" </span><span class="cov0" title="0">{
                pg, err := postgres.NewPostgresStorage(cfg.DBConnect)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Info("Using PostgreSQL storage")
                return pg, nil</span>
        }

        <span class="cov0" title="0">mem, err := inmemory.NewInMemoryStorage(cfg.FileStorage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := mem.Load(cfg.FileStorage); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Info("Using in-memory storage", zap.String("file", cfg.FileStorage))
        return mem, nil</span>
}

func waitForShutdown(
        log *zap.Logger,
        httpServer *http.Server,
        grpcServer *grpc.Server,
        service *service.Service,
) <span class="cov0" title="0">{
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("Shutting down servers...")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        //  HTTP 
        if err := httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error("HTTP server shutdown error", zap.Error(err))
        }</span>

        //  gRPC 
        <span class="cov0" title="0">grpcServer.GracefulStop()

        //   
        service.GracefulStop(5 * time.Second)
        if err := service.Close(); err != nil </span><span class="cov0" title="0">{
                log.Error("Storage close error", zap.Error(err))
        }</span>

        <span class="cov0" title="0">log.Info("Servers stopped gracefully")</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ryabkov82/shortener/internal/app/service (interfaces: Repository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        models "github.com/ryabkov82/shortener/internal/app/models"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov6" title="6">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov10" title="16">{
        return m.recorder
}</span>

// BatchMarkAsDeleted mocks base method.
func (m *MockRepository) BatchMarkAsDeleted(arg0 string, arg1 []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BatchMarkAsDeleted", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BatchMarkAsDeleted indicates an expected call of BatchMarkAsDeleted.
func (mr *MockRepositoryMockRecorder) BatchMarkAsDeleted(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchMarkAsDeleted", reflect.TypeOf((*MockRepository)(nil).BatchMarkAsDeleted), arg0, arg1)
}</span>

// Close mocks base method.
func (m *MockRepository) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockRepositoryMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRepository)(nil).Close))
}</span>

// CountURLs mocks base method.
func (m *MockRepository) CountURLs(arg0 context.Context) (int, error) <span class="cov6" title="6">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CountURLs", arg0)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CountURLs indicates an expected call of CountURLs.
func (mr *MockRepositoryMockRecorder) CountURLs(arg0 interface{}) *gomock.Call <span class="cov6" title="6">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountURLs", reflect.TypeOf((*MockRepository)(nil).CountURLs), arg0)
}</span>

// CountUsers mocks base method.
func (m *MockRepository) CountUsers(arg0 context.Context) (int, error) <span class="cov5" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CountUsers", arg0)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CountUsers indicates an expected call of CountUsers.
func (mr *MockRepositoryMockRecorder) CountUsers(arg0 interface{}) *gomock.Call <span class="cov5" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountUsers", reflect.TypeOf((*MockRepository)(nil).CountUsers), arg0)
}</span>

// GetExistingURLs mocks base method.
func (m *MockRepository) GetExistingURLs(arg0 context.Context, arg1 []string) (map[string]string, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetExistingURLs", arg0, arg1)
        ret0, _ := ret[0].(map[string]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetExistingURLs indicates an expected call of GetExistingURLs.
func (mr *MockRepositoryMockRecorder) GetExistingURLs(arg0, arg1 interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExistingURLs", reflect.TypeOf((*MockRepository)(nil).GetExistingURLs), arg0, arg1)
}</span>

// GetRedirectURL mocks base method.
func (m *MockRepository) GetRedirectURL(arg0 context.Context, arg1 string) (models.URLMapping, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRedirectURL", arg0, arg1)
        ret0, _ := ret[0].(models.URLMapping)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetRedirectURL indicates an expected call of GetRedirectURL.
func (mr *MockRepositoryMockRecorder) GetRedirectURL(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRedirectURL", reflect.TypeOf((*MockRepository)(nil).GetRedirectURL), arg0, arg1)
}</span>

// GetShortKey mocks base method.
func (m *MockRepository) GetShortKey(arg0 context.Context, arg1 string) (models.URLMapping, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetShortKey", arg0, arg1)
        ret0, _ := ret[0].(models.URLMapping)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetShortKey indicates an expected call of GetShortKey.
func (mr *MockRepositoryMockRecorder) GetShortKey(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetShortKey", reflect.TypeOf((*MockRepository)(nil).GetShortKey), arg0, arg1)
}</span>

// GetUserUrls mocks base method.
func (m *MockRepository) GetUserUrls(arg0 context.Context, arg1 string) ([]models.URLMapping, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserUrls", arg0, arg1)
        ret0, _ := ret[0].([]models.URLMapping)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserUrls indicates an expected call of GetUserUrls.
func (mr *MockRepositoryMockRecorder) GetUserUrls(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserUrls", reflect.TypeOf((*MockRepository)(nil).GetUserUrls), arg0, arg1)
}</span>

// Ping mocks base method.
func (m *MockRepository) Ping(arg0 context.Context) error <span class="cov5" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockRepositoryMockRecorder) Ping(arg0 interface{}) *gomock.Call <span class="cov5" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockRepository)(nil).Ping), arg0)
}</span>

// SaveNewURLs mocks base method.
func (m *MockRepository) SaveNewURLs(arg0 context.Context, arg1 []models.URLMapping) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveNewURLs", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveNewURLs indicates an expected call of SaveNewURLs.
func (mr *MockRepositoryMockRecorder) SaveNewURLs(arg0, arg1 interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveNewURLs", reflect.TypeOf((*MockRepository)(nil).SaveNewURLs), arg0, arg1)
}</span>

// SaveURL mocks base method.
func (m *MockRepository) SaveURL(arg0 context.Context, arg1 *models.URLMapping) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveURL", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveURL indicates an expected call of SaveURL.
func (mr *MockRepositoryMockRecorder) SaveURL(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveURL", reflect.TypeOf((*MockRepository)(nil).SaveURL), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package service  -   URL.
//
//  :
// -   
// -   URL
// -   
// -   URL
package service

import (
        "context"
        "math/rand"
        "time"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/workers/deleteurls"
)

// Repository       URL.
type Repository interface {
        GetShortKey(context.Context, string) (models.URLMapping, error)
        GetRedirectURL(context.Context, string) (models.URLMapping, error)
        SaveURL(context.Context, *models.URLMapping) error
        Ping(context.Context) error
        SaveNewURLs(context.Context, []models.URLMapping) error
        GetExistingURLs(context.Context, []string) (map[string]string, error)
        GetUserUrls(context.Context, string) ([]models.URLMapping, error)
        BatchMarkAsDeleted(userID string, urls []string) error
        Close() error
        CountURLs(ctx context.Context) (int, error)
        CountUsers(ctx context.Context) (int, error)
}

// Service    .
type Service struct {
        repo         Repository               //  
        deleteworker *deleteurls.DeleteWorker //    
}

// NewService    .
//
// :
//
//        storage -   Repository
//
// :
//
//        *Service -  
func NewService(storage Repository) *Service <span class="cov5" title="18">{
        //    :
        // - 1 
        // -   10 
        // -  500  
        delworker := deleteurls.NewDeleteWorker(1, 10, 500*time.Millisecond, storage)
        delworker.Start()

        return &amp;Service{
                repo:         storage,
                deleteworker: delworker,
        }
}</span>

// GetShortKey       URL.
//
// :
//
//        ctx -    
//        originalURL - URL  
//
// :
//
//        string -   
//        error -   :
//          - storage.ErrURLExists  URL  
func (s *Service) GetShortKey(ctx context.Context, originalURL string) (string, error) <span class="cov6" title="34">{
        shortKey := generateShortKey()
        mapping := models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }

        err := s.repo.SaveURL(ctx, &amp;mapping)
        return mapping.ShortURL, err
}</span>

// GetRedirectURL   URL  .
//
// :
//
//        ctx -  
//        shortKey -   URL
//
// :
//
//        string -  URL
//        error:
//          - storage.ErrURLNotFound  URL  
//          - storage.ErrURLDeleted  URL   
func (s *Service) GetRedirectURL(ctx context.Context, shortKey string) (string, error) <span class="cov5" title="21">{
        mapping, err := s.repo.GetRedirectURL(ctx, shortKey)
        return mapping.OriginalURL, err
}</span>

// Ping   .
func (s *Service) Ping(ctx context.Context) error <span class="cov3" title="4">{
        return s.repo.Ping(ctx)
}</span>

// Batch      URL.
//
// :
//
//        ctx -    
//        batchRequest -  URL  
//        baseURL -       URL
//
// :
//
//        []models.BatchResponse -  
//        error -   
func (s *Service) Batch(ctx context.Context, batchRequest []models.BatchRequest, baseURL string) ([]models.BatchResponse, error) <span class="cov3" title="4">{
        originalURLs := make([]string, len(batchRequest))
        for i, item := range batchRequest </span><span class="cov4" title="8">{
                originalURLs[i] = item.OriginalURL
        }</span>

        <span class="cov3" title="4">existingURLs, err := s.repo.GetExistingURLs(ctx, originalURLs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="4">var newURLs []models.URLMapping
        batchResponse := make([]models.BatchResponse, 0, len(batchRequest))

        for _, item := range batchRequest </span><span class="cov4" title="8">{
                if shortURL, ok := existingURLs[item.OriginalURL]; ok </span><span class="cov0" title="0">{
                        batchResponse = append(batchResponse, models.BatchResponse{
                                CorrelationID: item.CorrelationID,
                                ShortURL:      baseURL + "/" + shortURL,
                        })
                        continue</span>
                }

                <span class="cov4" title="8">shortURL := generateShortKey()
                newURLs = append(newURLs, models.URLMapping{
                        OriginalURL: item.OriginalURL,
                        ShortURL:    shortURL,
                })

                batchResponse = append(batchResponse, models.BatchResponse{
                        CorrelationID: item.CorrelationID,
                        ShortURL:      baseURL + "/" + shortURL,
                })</span>
        }

        <span class="cov3" title="4">if err := s.repo.SaveNewURLs(ctx, newURLs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="4">return batchResponse, nil</span>
}

// GetUserUrls    URL .
//
// :
//
//        ctx -    
//        baseURL -       URL
//
// :
//
//        []models.URLMapping -  URL 
//        error -   
func (s *Service) GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error) <span class="cov3" title="6">{
        return s.repo.GetUserUrls(ctx, baseURL)
}</span>

// GetStats      URL  .
//
// :
//   - ctx:  ,     
//
// :
//   - models.StatsResponse:   :
//   - URLs:    URL  
//   - Users:     
//   - error: ,     :
//   -      CountURLs
//   -      CountUsers
//
//  :
//  1.    URL  s.repo.CountURLs
//  2.        
//  3.     s.repo.CountUsers
//  4.       
//  5.     StatsResponse   
//
//  :
//
//        stats, err := service.GetStats(context.Background())
//        if err != nil {
//            //  
//        }
//        fmt.Printf("Stats: %d URLs, %d Users\n", stats.URLs, stats.Users)
//
// :
//   -   -        
//   -      s.repo
//   -     
//
//    :
//   -   stats.GetHandler   HTTP-
//   -     Repository
func (s *Service) GetStats(ctx context.Context) (models.StatsResponse, error) <span class="cov3" title="6">{

        urlCount, err := s.repo.CountURLs(ctx)
        if err != nil </span><span class="cov2" title="2">{
                return models.StatsResponse{}, err
        }</span>

        <span class="cov3" title="4">userCount, err := s.repo.CountUsers(ctx)
        if err != nil </span><span class="cov2" title="2">{
                return models.StatsResponse{}, err
        }</span>

        <span class="cov2" title="2">return models.StatsResponse{URLs: urlCount, Users: userCount}, nil</span>

}

// DeleteUserUrls  URL    ().
//
// :
//
//        ctx -    
//        shortURLs -   URL  
//
// :
//
//        error -      
func (s *Service) DeleteUserUrls(ctx context.Context, shortURLs []string) error <span class="cov4" title="12">{
        userID := ctx.Value(jwtauth.UserIDContextKey).(string)
        return s.deleteworker.Submit(deleteurls.DeleteTask{
                UserID:    userID,
                ShortURLs: shortURLs,
        })
}</span>

// GracefulStop   .
//
// :
//
//        timeout -     
func (s *Service) GracefulStop(timeout time.Duration) <span class="cov0" title="0">{
        s.deleteworker.GracefulStop(timeout)
}</span>

// Close  
func (s *Service) Close() error <span class="cov0" title="0">{
        return s.repo.Close()
}</span>

// generateShortKey    .
//
// :
//
//        string - 8-   [a-zA-Z0-9]
func generateShortKey() string <span class="cov6" title="42">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        const keyLength = 8

        rand.New(rand.NewSource(time.Now().UnixNano()))
        shortKey := make([]byte, keyLength)
        for i := range shortKey </span><span class="cov10" title="336">{
                shortKey[i] = charset[rand.Intn(len(charset))]
        }</span>
        <span class="cov6" title="42">return string(shortKey)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package inmemory  in-memory     URL    .
//
//  :
// -        RWMutex
// -       JSON (append-only )
// -   
// -     
package inmemory

import (
        "bufio"
        "context"
        "encoding/json"
        "errors"
        "os"
        "sync"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/storage"
)

// InMemoryStorage     in-memory    .
//
//  :
// - userURLIndex:         URL
// - shortCodeMap:   
// - countRecords:     UUID
// - file/encoder:   
// - mu: RWMutex   
type InMemoryStorage struct {
        userURLIndex map[string]map[string]string
        shortCodeMap map[string]models.UserURLMapping
        file         *os.File
        encoder      *json.Encoder
        countRecords uint64
        mu           sync.RWMutex
}

// NewInMemoryStorage   in-memory    .
//
// :
//
//        fileStoragePath -      
//
// :
//
//        *InMemoryStorage -  
//        error -    
//
// :
//
//        storage, err := NewInMemoryStorage("data/storage.json")
func NewInMemoryStorage(fileStoragePath string) (*InMemoryStorage, error) <span class="cov7" title="11">{
        file, err := os.OpenFile(fileStoragePath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="11">return &amp;InMemoryStorage{
                userURLIndex: make(map[string]map[string]string),
                shortCodeMap: make(map[string]models.UserURLMapping),
                countRecords: 0,
                file:         file,
                encoder:      json.NewEncoder(file),
        }, nil</span>
}

// Load      .
//
//  : JSON- (   )
//       ,   
//
// :
//
//        fileStoragePath -     
//
// :
//
//        error -   
func (s *InMemoryStorage) Load(fileStoragePath string) error <span class="cov0" title="0">{
        file, err := os.OpenFile(fileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        var countRecords uint64

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Bytes()
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var url models.UserURLMapping
                if err := json.Unmarshal(line, &amp;url); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if url.UserID == "" || url.OriginalURL == "" || url.ShortURL == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if _, ok := s.userURLIndex[url.UserID]; !ok </span><span class="cov0" title="0">{
                        s.userURLIndex[url.UserID] = make(map[string]string)
                }</span>

                <span class="cov0" title="0">s.userURLIndex[url.UserID][url.OriginalURL] = url.ShortURL
                s.shortCodeMap[url.ShortURL] = url
                countRecords++</span>
        }

        <span class="cov0" title="0">s.countRecords = countRecords
        return scanner.Err()</span>
}

// GetShortKey      URL .
//
// :
//
//        ctx -   userID
//        originalURL - URL  
//
// :
//
//        models.URLMapping -  
//        error -   (storage.ErrURLNotFound   )
func (s *InMemoryStorage) GetShortKey(ctx context.Context, originalURL string) (models.URLMapping, error) <span class="cov4" title="4">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        userID := ctx.Value(jwtauth.UserIDContextKey)
        if userID == nil </span><span class="cov0" title="0">{
                return models.URLMapping{}, errors.New("userID is not set")
        }</span>

        <span class="cov4" title="4">shortKey, found := s.userURLIndex[userID.(string)][originalURL]
        if !found </span><span class="cov4" title="4">{
                return models.URLMapping{}, storage.ErrURLNotFound
        }</span>

        <span class="cov0" title="0">return models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }, nil</span>
}

// GetRedirectURL   URL  .
//
// :
//
//        ctx -  
//        shortKey -   URL
//
// :
//
//        models.URLMapping -  
//        error:
//          - storage.ErrURLNotFound  URL  
//          - storage.ErrURLDeleted  URL   
func (s *InMemoryStorage) GetRedirectURL(ctx context.Context, shortKey string) (models.URLMapping, error) <span class="cov8" title="14">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        url, found := s.shortCodeMap[shortKey]
        if !found </span><span class="cov4" title="4">{
                return models.URLMapping{}, storage.ErrURLNotFound
        }</span>

        <span class="cov7" title="10">if url.DeletedFlag </span><span class="cov5" title="6">{
                return models.URLMapping{}, storage.ErrURLDeleted
        }</span>

        <span class="cov4" title="4">return models.URLMapping{
                ShortURL:    url.ShortURL,
                OriginalURL: url.OriginalURL,
        }, nil</span>
}

// SaveURL    URL.
//
// :
//
//        ctx -   userID
//        mapping -   URL
//
// :
//
//        error:
//          - storage.ErrShortURLExists  shortURL  
//          - storage.ErrURLExists  originalURL  
func (s *InMemoryStorage) SaveURL(ctx context.Context, mapping *models.URLMapping) error <span class="cov10" title="28">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, found := s.shortCodeMap[mapping.ShortURL]; found </span><span class="cov0" title="0">{
                return storage.ErrShortURLExists
        }</span>

        <span class="cov10" title="28">userID := ctx.Value(jwtauth.UserIDContextKey)
        if userID == nil </span><span class="cov0" title="0">{
                return errors.New("userID is not set")
        }</span>

        <span class="cov10" title="28">if _, ok := s.userURLIndex[userID.(string)]; !ok </span><span class="cov8" title="15">{
                s.userURLIndex[userID.(string)] = make(map[string]string)
        }</span>

        <span class="cov10" title="28">if shortURL, exists := s.userURLIndex[userID.(string)][mapping.OriginalURL]; exists </span><span class="cov3" title="3">{
                mapping.ShortURL = shortURL
                return storage.ErrURLExists
        }</span>

        <span class="cov9" title="25">s.userURLIndex[userID.(string)][mapping.OriginalURL] = mapping.ShortURL
        s.countRecords++

        userURLMapping := models.UserURLMapping{
                UUID:        s.countRecords,
                ShortURL:    mapping.ShortURL,
                OriginalURL: mapping.OriginalURL,
                UserID:      userID.(string),
                DeletedFlag: false,
        }
        s.shortCodeMap[mapping.ShortURL] = userURLMapping

        return s.encoder.Encode(userURLMapping)</span>
}

// Ping    (  nil).
func (s *InMemoryStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// GetExistingURLs   URL  .
//
// :
//
//        ctx -   userID
//        originalURLs -  URL  
//
// :
//
//        map[string]string -   URL (originalURL -&gt; shortURL)
//        error -  
func (s *InMemoryStorage) GetExistingURLs(ctx context.Context, originalURLs []string) (map[string]string, error) <span class="cov2" title="2">{
        existing := make(map[string]string)

        if len(originalURLs) == 0 </span><span class="cov0" title="0">{
                return existing, nil
        }</span>

        <span class="cov2" title="2">for _, originalURL := range originalURLs </span><span class="cov4" title="4">{
                mapping, err := s.GetShortKey(ctx, originalURL)
                if err != nil &amp;&amp; !errors.Is(err, storage.ErrURLNotFound) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="4">if err == nil </span><span class="cov0" title="0">{
                        existing[mapping.OriginalURL] = mapping.ShortURL
                }</span>
        }

        <span class="cov2" title="2">return existing, nil</span>
}

// SaveNewURLs    URL.
//
// :
//
//        ctx -   userID
//        urls -  URL  
//
// :
//
//        error -    
func (s *InMemoryStorage) SaveNewURLs(ctx context.Context, urls []models.URLMapping) error <span class="cov2" title="2">{
        for _, url := range urls </span><span class="cov4" title="4">{
                if err := s.SaveURL(ctx, &amp;url); err != nil &amp;&amp; !errors.Is(err, storage.ErrURLExists) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// GetUserUrls   URL .
//
// :
//
//        ctx -   userID
//        baseURL -  URL     URL
//
// :
//
//        []models.URLMapping -  URL 
//        error -  
func (s *InMemoryStorage) GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error) <span class="cov4" title="4">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        userID := ctx.Value(jwtauth.UserIDContextKey)
        if userID == nil </span><span class="cov0" title="0">{
                return nil, errors.New("userID is not set")
        }</span>

        <span class="cov4" title="4">userURLs, exists := s.userURLIndex[userID.(string)]
        if !exists </span><span class="cov2" title="2">{
                return nil, nil
        }</span>

        <span class="cov2" title="2">var result []models.URLMapping
        for originalURL, shortCode := range userURLs </span><span class="cov4" title="4">{
                result = append(result, models.URLMapping{
                        OriginalURL: originalURL,
                        ShortURL:    baseURL + "/" + shortCode,
                })
        }</span>
        <span class="cov2" title="2">return result, nil</span>
}

// CountURLs    URL  .
//
// :
//
//        ctx - 
//
// :
//
//         int -   URL  
//                error -  
func (s *InMemoryStorage) CountURLs(ctx context.Context) (int, error) <span class="cov0" title="0">{
        count := len(s.shortCodeMap)
        return count, nil
}</span>

// CountUsers     .
//
// :
//
//        ctx - 
//
// :
//
//         int -    
//                error -  
func (s *InMemoryStorage) CountUsers(ctx context.Context) (int, error) <span class="cov0" title="0">{
        count := len(s.userURLIndex)
        return count, nil
}</span>

// BatchMarkAsDeleted  URL   .
//
// :
//
//        userID -  
//        urls -   URL  
//
// :
//
//        error -  
func (s *InMemoryStorage) BatchMarkAsDeleted(userID string, urls []string) error <span class="cov6" title="8">{
        s.mu.Lock()
        defer s.mu.Unlock()

        for _, code := range urls </span><span class="cov7" title="10">{
                if mapping, exists := s.shortCodeMap[code]; exists &amp;&amp; mapping.UserID == userID </span><span class="cov5" title="6">{
                        mapping.DeletedFlag = true
                        s.shortCodeMap[code] = mapping
                        if err := s.encoder.Encode(mapping); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov6" title="8">return nil</span>
}

// FilePath    ,  .
//    ,   .
func (s *InMemoryStorage) FilePath() string <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        if s.file == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return s.file.Name()</span>
}

// Close  
func (s *InMemoryStorage) Close() error <span class="cov7" title="11">{
        if s.file != nil </span><span class="cov7" title="11">{
                return s.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package postgres

import (
        "database/sql"
        "embed"
        "time"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        "github.com/golang-migrate/migrate/v4/source/iofs"
)

//go:embed migrations/*.sql
var fs embed.FS

func applyMigrations(db *sql.DB) error <span class="cov8" title="1">{
        // 1.      ( embed.FS)
        sourceDriver, err := iofs.New(fs, "migrations")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 2.     
        <span class="cov8" title="1">dbDriver, err := postgres.WithInstance(db, &amp;postgres.Config{
                StatementTimeout: 5 * time.Minute, //   
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 3.  
        <span class="cov8" title="1">m, err := migrate.NewWithInstance(
                "iofs",       //   
                sourceDriver, //   
                "postgres",   //   
                dbDriver)     //   
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 4.  
        <span class="cov8" title="1">if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package postgres    URL  PostgreSQL.
//
//  :
// -   PostgreSQL    
// -  SQL-   
// -     
// -    
package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        _ "github.com/jackc/pgx/v5/stdlib"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/storage"
)

// PostgresStorage       PostgreSQL.
type PostgresStorage struct {
        db              *sql.DB
        getShortURLStmt *sql.Stmt
        getURLStmt      *sql.Stmt
        insertURLStmt   *sql.Stmt
}

// NewPostgresStorage     PostgreSQL   .
//
// :
//   - StoragePath:    PostgreSQL
//
// :
//   - *PostgresStorage:  
//   - error:     
func NewPostgresStorage(storagePath string) (*PostgresStorage, error) <span class="cov1" title="1">{
        db, err := sql.Open("pgx", storagePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if err = applyMigrations(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("migrations failed: %w", err)
        }</span>

        //   
        <span class="cov1" title="1">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(25)
        db.SetConnMaxLifetime(5 * time.Minute)

        //    
        getShortURLStmt, err := db.Prepare(`SELECT short_code FROM short_urls WHERE original_url = $1 and user_id = $2`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">getURLStmt, err := db.Prepare(`SELECT original_url, is_deleted FROM short_urls WHERE short_code = $1`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">insertURLStmt, err := db.Prepare(`
        INSERT INTO short_urls (original_url, short_code, user_id)
        VALUES ($1, $2, $3)
        ON CONFLICT (user_id, original_url) DO UPDATE SET
                original_url = EXCLUDED.original_url
        RETURNING short_code, xmax;
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;PostgresStorage{db, getShortURLStmt, getURLStmt, insertURLStmt}, nil</span>
}

// Ping     .
//
// :
//
//        ctx -  
//
// :
//
//        error -  
func (s *PostgresStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        ctxTm, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()
        return s.db.PingContext(ctxTm)
}</span>

// GetShortKey   URL  .
//
// :
//
//        ctx -  
//        originalURL -  URL
//
// :
//
//        models.URLMapping -  URL
//        error -  
func (s *PostgresStorage) GetShortKey(ctx context.Context, originalURL string) (models.URLMapping, error) <span class="cov0" title="0">{
        mapping := models.URLMapping{
                OriginalURL: originalURL,
        }

        userID := ctx.Value(jwtauth.UserIDContextKey)
        err := s.getShortURLStmt.QueryRowContext(ctx, originalURL, userID).Scan(&amp;mapping.ShortURL)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return mapping, storage.ErrURLNotFound
                }</span>
                <span class="cov0" title="0">return mapping, err</span>
        }

        <span class="cov0" title="0">return mapping, nil</span>
}

// GetRedirectURL   URL  .
//
// :
//
//        ctx -  
//        shortKey -   URL
//
// :
//
//        models.URLMapping -  URL
//        error -  
func (s *PostgresStorage) GetRedirectURL(ctx context.Context, shortKey string) (models.URLMapping, error) <span class="cov7" title="7">{
        mapping := models.URLMapping{
                ShortURL: shortKey,
        }

        var deletedFlag bool
        err := s.getURLStmt.QueryRowContext(ctx, shortKey).Scan(&amp;mapping.OriginalURL, &amp;deletedFlag)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov3" title="2">{
                        return mapping, fmt.Errorf("%w", storage.ErrURLNotFound)
                }</span>
                <span class="cov0" title="0">return mapping, fmt.Errorf("   URL: %w", err)</span>
        }

        <span class="cov6" title="5">if deletedFlag </span><span class="cov4" title="3">{
                return mapping, storage.ErrURLDeleted
        }</span>
        <span class="cov3" title="2">return mapping, nil</span>
}

// SaveURL    URL.
//
// :
//
//        ctx -  
//        mapping -  URL  
//
// :
//
//        error -  
func (s *PostgresStorage) SaveURL(ctx context.Context, mapping *models.URLMapping) error <span class="cov10" title="13">{
        var xmax int64 //     

        userID := ctx.Value(jwtauth.UserIDContextKey)
        err := s.insertURLStmt.QueryRowContext(ctx, mapping.OriginalURL, mapping.ShortURL, userID).Scan(&amp;mapping.ShortURL, &amp;xmax)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="13">if xmax &gt; 0 </span><span class="cov3" title="2">{
                err = storage.ErrURLExists
        }</span>

        <span class="cov10" title="13">return err</span>
}

// GetExistingURLs     URL.
//
// :
//
//        ctx -  
//        originalURLs -   URL
//
// :
//
//        map[string]string -  URL
//        error -  
func (s *PostgresStorage) GetExistingURLs(ctx context.Context, originalURLs []string) (map[string]string, error) <span class="cov1" title="1">{
        existing := make(map[string]string)
        if len(originalURLs) == 0 </span><span class="cov0" title="0">{
                return existing, nil
        }</span>

        <span class="cov1" title="1">query := "SELECT original_url, short_code FROM short_urls WHERE original_url = ANY($1) and user_id = $2"
        userID := ctx.Value(jwtauth.UserIDContextKey)

        rows, err := s.db.QueryContext(ctx, query, originalURLs, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var originalURL, shortURL string
                if err := rows.Scan(&amp;originalURL, &amp;shortURL); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">existing[originalURL] = shortURL</span>
        }

        <span class="cov1" title="1">return existing, rows.Err()</span>
}

// SaveNewURLs    URL.
//
// :
//
//        ctx -  
//        urls -  URL  
//
// :
//
//        error -  
func (s *PostgresStorage) SaveNewURLs(ctx context.Context, urls []models.URLMapping) error <span class="cov1" title="1">{
        if len(urls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">userID := ctx.Value(jwtauth.UserIDContextKey)

        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov1" title="1">stmt, err := tx.Prepare("INSERT INTO short_urls (original_url, short_code, user_id) VALUES($1, $2, $3)")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer stmt.Close()

        for _, url := range urls </span><span class="cov3" title="2">{
                _, err = stmt.ExecContext(ctx, url.OriginalURL, url.ShortURL, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return tx.Commit()</span>
}

// GetUserUrls   URL .
//
// :
//
//        ctx -  
//        baseURL -  URL 
//
// :
//
//        []models.URLMapping -  URL 
//        error -  
func (s *PostgresStorage) GetUserUrls(ctx context.Context, baseURL string) ([]models.URLMapping, error) <span class="cov3" title="2">{
        userID := ctx.Value(jwtauth.UserIDContextKey)
        query := "SELECT original_url, short_code FROM short_urls WHERE user_id = $1"

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var userURLs []models.URLMapping
        for rows.Next() </span><span class="cov3" title="2">{
                var originalURL, shortURL string
                if err := rows.Scan(&amp;originalURL, &amp;shortURL); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">userURLs = append(userURLs, models.URLMapping{
                        OriginalURL: originalURL,
                        ShortURL:    baseURL + "/" + shortURL,
                })</span>
        }

        <span class="cov3" title="2">return userURLs, rows.Err()</span>
}

// BatchMarkAsDeleted  URL   .
//
// :
//
//        userID -  
//        urls -   URL  
//
// :
//
//        error -  
func (s *PostgresStorage) BatchMarkAsDeleted(userID string, urls []string) error <span class="cov5" title="4">{
        if len(urls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov5" title="4">var params []interface{}
        query := "UPDATE short_urls SET is_deleted = true WHERE short_code IN ("

        for i, url := range urls </span><span class="cov6" title="5">{
                query += fmt.Sprintf("$%d,", i+1)
                params = append(params, url)
        }</span>
        <span class="cov5" title="4">query = strings.TrimSuffix(query, ",") + ") AND user_id = $" + fmt.Sprintf("%d", len(urls)+1)
        params = append(params, userID)

        _, err := s.db.Exec(query, params...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error updating batch: %w", err)
        }</span>

        <span class="cov5" title="4">return nil</span>
}

// CountURLs    URL  .
//
// :
//
//        ctx - 
//
// :
//
//         int -   URL  
//                error -  
func (s *PostgresStorage) CountURLs(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        err := s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM short_urls").Scan(&amp;count)
        return count, err
}</span>

// CountUsers     .
//
// :
//
//        ctx - 
//
// :
//
//         int -    
//                error -  
func (s *PostgresStorage) CountUsers(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        err := s.db.QueryRowContext(ctx, "SELECT COUNT(DISTINCT user_id) FROM short_urls").Scan(&amp;count)
        return count, err
}</span>

// Close  
func (s *PostgresStorage) Close() error <span class="cov0" title="0">{
        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package deleteurls       URL    .
//
//    " " :
// -    
// -      
// -      
// -    
package deleteurls

import (
        "errors"
        "log"
        "sync"
        "time"
)

// Repository   ,    DeleteWorker.
type Repository interface {
        // BatchMarkAsDeleted   URL     .
        //     .
        BatchMarkAsDeleted(userID string, urls []string) error
}

// DeleteTask       URL  .
type DeleteTask struct {
        UserID    string   // ID ,  
        ShortURLs []string //   URL    
}

// DeleteWorker      URL.
//        .
type DeleteWorker struct {
        repo        Repository
        taskChan    chan DeleteTask
        batchChan   chan map[string][]string
        stopChan    chan struct{}
        wg          sync.WaitGroup
        workerCount int
        batchSize   int
        batchWindow time.Duration
}

// NewDeleteWorker    DeleteWorker   .
//
// :
//   - workerCount:     
//   - batchSize:     
//   - batchWindow:     
//   - storage:   Repository
func NewDeleteWorker(workerCount, batchSize int, batchWindow time.Duration, storage Repository) *DeleteWorker <span class="cov7" title="18">{
        return &amp;DeleteWorker{
                taskChan:    make(chan DeleteTask, 10000),
                batchChan:   make(chan map[string][]string, 100),
                stopChan:    make(chan struct{}),
                workerCount: workerCount,
                batchSize:   batchSize,
                batchWindow: batchWindow,
                repo:        storage,
        }
}</span>

// Start     .
func (w *DeleteWorker) Start() <span class="cov7" title="18">{
        w.wg.Add(w.workerCount + 1) // +1   

        go w.batchCollector() //   

        for i := 0; i &lt; w.workerCount; i++ </span><span class="cov7" title="18">{
                go w.batchProcessor() //  
        }</span>
}

// Submit        .
//     .
func (w *DeleteWorker) Submit(task DeleteTask) error <span class="cov6" title="12">{
        select </span>{
        case w.taskChan &lt;- task:<span class="cov6" title="12">
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New(" ")</span>
        }
}

// batchCollector      .
//       batchSize    batchWindow.
func (w *DeleteWorker) batchCollector() <span class="cov7" title="18">{
        defer w.wg.Done()

        batch := make(map[string][]string)
        ticker := time.NewTicker(w.batchWindow)
        defer ticker.Stop()

        for </span><span class="cov10" title="44">{
                select </span>{
                case &lt;-w.stopChan:<span class="cov0" title="0">
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                w.batchChan &lt;- batch
                        }</span>
                        <span class="cov0" title="0">close(w.batchChan)
                        return</span>

                case task, ok := &lt;-w.taskChan:<span class="cov6" title="12">
                        if !ok </span><span class="cov0" title="0">{
                                if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                        w.batchChan &lt;- batch
                                }</span>
                                <span class="cov0" title="0">close(w.batchChan)
                                return</span>
                        }

                        <span class="cov6" title="12">if urls, exists := batch[task.UserID]; exists </span><span class="cov0" title="0">{
                                batch[task.UserID] = append(urls, task.ShortURLs...)
                        }</span> else<span class="cov6" title="12"> {
                                batch[task.UserID] = task.ShortURLs
                        }</span>

                        <span class="cov6" title="12">if len(batch) &gt;= w.batchSize </span><span class="cov0" title="0">{
                                w.batchChan &lt;- batch
                                batch = make(map[string][]string)
                                ticker.Reset(w.batchWindow)
                        }</span>

                case &lt;-ticker.C:<span class="cov7" title="14">
                        if len(batch) &gt; 0 </span><span class="cov6" title="12">{
                                w.batchChan &lt;- batch
                                batch = make(map[string][]string)
                        }</span>
                }
        }
}

// batchProcessor   ,   .
func (w *DeleteWorker) batchProcessor() <span class="cov7" title="18">{
        defer w.wg.Done()

        for batch := range w.batchChan </span><span class="cov6" title="12">{
                var batchWg sync.WaitGroup
                batchWg.Add(len(batch))

                concurrencyLimit := make(chan struct{}, w.workerCount*2)

                for userID, urls := range batch </span><span class="cov6" title="12">{
                        concurrencyLimit &lt;- struct{}{}

                        go func(userID string, urls []string) </span><span class="cov6" title="12">{
                                defer batchWg.Done()
                                defer func() </span><span class="cov6" title="12">{ &lt;-concurrencyLimit }</span>()

                                <span class="cov6" title="12">const subBatchSize = 50
                                for i := 0; i &lt; len(urls); i += subBatchSize </span><span class="cov6" title="12">{
                                        end := i + subBatchSize
                                        if end &gt; len(urls) </span><span class="cov6" title="12">{
                                                end = len(urls)
                                        }</span>
                                        <span class="cov6" title="12">subBatch := urls[i:end]

                                        if err := w.processUserBatch(userID, subBatch); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("   URL     %s: %v", userID, err)
                                        }</span>
                                }
                        }(userID, urls)
                }

                <span class="cov6" title="12">batchWg.Wait()</span>
        }
}

// processUserBatch   URL    .
func (w *DeleteWorker) processUserBatch(userID string, urls []string) error <span class="cov6" title="12">{
        if err := w.repo.BatchMarkAsDeleted(userID, urls); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="12">return nil</span>
}

// GracefulStop       .
//        .
func (w *DeleteWorker) GracefulStop(timeout time.Duration) <span class="cov0" title="0">{
        close(w.stopChan)

        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                w.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                log.Println("   ")</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                log.Println("   ")</span>
        }

        <span class="cov0" title="0">close(w.taskChan)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Package testconfig         testcontainers.
//
//  :
//   -   PostgreSQL   
//   -     
//   - -  ( sync.Once)
//   -      
//
//  :
//
//        ctx := context.Background()
//        cfg := DefaultPGConfig()
//        container, dsn, err := StartPGContainer(ctx, cfg)
//        if err != nil {
//            log.Fatal(err)
//        }
//        defer container.Terminate(ctx)
//
//        db, err := sql.Open("postgres", dsn)
//        // ...   
//
//     ,    .
package testconfig

import (
        "context"
        "fmt"
        "log"
        "os"
        "sync"
        "time"

        "github.com/docker/go-connections/nat"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/wait"
)

var (
        pgContainer testcontainers.Container
        pgDSN       string
        pgOnce      sync.Once
)

// PGConfig       PostgreSQL.
//
//  :
//   - Image:    Docker- PostgreSQL (, "postgres:13-alpine")
//   - User:          
//   - Password:   
//   - DBName:      
//   - Port:         PostgreSQL ( "5432")
//
//  :
//
//        cfg := PGConfig{
//            Image:    "postgres:13-alpine",
//            User:     "testuser",
//            Password: "testpass",
//            DBName:   "testdb",
//            Port:     "5432",
//        }
//
// :
//   -   
//   -       alpine
//   -    ,    
type PGConfig struct {
        Image    string
        User     string
        Password string
        DBName   string
        Port     string
}

// DefaultPGConfig   PostgreSQL    
//   postgres:13-alpine   test,  test   test   5432
func DefaultPGConfig() PGConfig <span class="cov1" title="1">{
        return PGConfig{
                Image:    "postgres:13-alpine",
                User:     "test",
                Password: "test",
                DBName:   "test",
                Port:     "5432",
        }
}</span>

// StartPGContainer   PostgreSQL   .
//  sync.Once     .
// :
//   - testcontainers.Container:    
//   - string: DSN     
//   - error: ,     
//
//        .
func StartPGContainer(ctx context.Context, cfg PGConfig) (testcontainers.Container, string, error) <span class="cov1" title="1">{
        var startErr error
        pgOnce.Do(func() </span><span class="cov1" title="1">{

                //    nat.Port
                pgPort := nat.Port(cfg.Port + "/tcp") // : "5432" -&gt; "5432/tcp"
                req := testcontainers.ContainerRequest{
                        Image:        cfg.Image,
                        ExposedPorts: []string{string(pgPort)},
                        Env: map[string]string{
                                "POSTGRES_USER":     cfg.User,
                                "POSTGRES_PASSWORD": cfg.Password,
                                "POSTGRES_DB":       cfg.DBName,
                        },
                        WaitingFor: wait.ForAll(
                                wait.ForLog("database system is ready"),
                                wait.ForListeningPort(pgPort),
                        ).WithDeadline(1 * time.Minute),
                }

                logger := log.New(os.Stdout, "[POSTGRES] ", log.LstdFlags)

                pgContainer, startErr = testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
                        ContainerRequest: req,
                        Started:          true,
                        Logger:           logger,
                })
                if startErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                //     
                <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                        reader, err := pgContainer.Logs(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Println("Failed to get logs:", err)
                                return
                        }</span>
                        <span class="cov1" title="1">defer reader.Close()

                        buf := make([]byte, 1024)
                        for </span><span class="cov10" title="117">{
                                n, err := reader.Read(buf)
                                if err != nil </span><span class="cov1" title="1">{
                                        return
                                }</span>
                                <span class="cov9" title="116">logger.Print(string(buf[:n]))</span>
                        }
                }()

                <span class="cov1" title="1">host, err := pgContainer.Host(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        startErr = err
                        return
                }</span>

                <span class="cov1" title="1">mappedPort, err := pgContainer.MappedPort(ctx, pgPort)
                if err != nil </span><span class="cov0" title="0">{
                        startErr = err
                        return
                }</span>

                <span class="cov1" title="1">pgDSN = fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
                        cfg.User, cfg.Password, host, mappedPort.Port(), cfg.DBName)</span>
        })

        <span class="cov1" title="1">return pgContainer, pgDSN, startErr</span>
}

// GetTestPGDSN  DSN       PostgreSQL.
//     StartPGContainer   .
func GetTestPGDSN() string <span class="cov0" title="0">{
        return pgDSN
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package testhandlers

import (
        "context"
        "encoding/json"
        "testing"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/test/testutils"
        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
        "google.golang.org/grpc/status"
)

func TestBatchGRPC(t *testing.T, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        tests := CommonBatchTestCases()

        for _, tt := range tests </span><span class="cov10" title="2">{
                t.Run("gRPC_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="2">{
                        var request []pb.BatchCreateItem
                        err := json.Unmarshal([]byte(tt.Request), &amp;request)
                        if err != nil </span><span class="cov1" title="1">{
                                //    JSON 
                                t.Skip("invalid request format for gRPC")
                        }</span>

                        <span class="cov1" title="1">var items []*pb.BatchCreateItem
                        for i := range request </span><span class="cov10" title="2">{
                                items = append(items, &amp;request[i])
                        }</span>

                        <span class="cov1" title="1">resp, err := grpcClient.BatchCreate(context.Background(), &amp;pb.BatchCreateRequest{Items: items})

                        if tt.WantStatus != testutils.StatusCreated </span><span class="cov0" title="0">{
                                require.Error(t, err)
                                st, _ := status.FromError(err)
                                assert.Equal(t, tt.WantStatus, testutils.GRPCCodeToStatusCode(st.Code()))
                                return
                        }</span>

                        <span class="cov1" title="1">require.NoError(t, err)
                        assert.Len(t, resp.Items, tt.ExpectedLength)</span>

                })
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package testhandlers

import (
        "bytes"
        "compress/gzip"
        "encoding/json"
        "testing"

        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/ryabkov82/shortener/internal/app/models"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestBatchHandler      URL (/api/shorten/batch).
//
//   :
//   -    URL   
//   -    
//   -   gzip     
//   -   JWT cookie
//   -      API
//
//    HTTP- :
//   -  Chi
//   - Middleware: , gzip, JWT-
//   -   httptest
//   -      
//
//  -:
//   -     URL ( 201 Created)
//   -  JSON ( 400 Bad Request)
//
//  :
//   - service.Service: - 
//   - logger:  
//   - testutils:     
//   - resty: HTTP-  
func TestBatch(t *testing.T, client *resty.Client) <span class="cov6" title="3">{

        //cookie, _ := testutils.CreateSignedCookie()

        tests := CommonBatchTestCases()

        for _, tt := range tests </span><span class="cov10" title="6">{
                t.Run("HTTP_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="6">{

                        buf := bytes.NewBuffer(nil)
                        zb := gzip.NewWriter(buf)
                        _, err := zb.Write([]byte(tt.Request))
                        assert.NoError(t, err)
                        err = zb.Close()
                        assert.NoError(t, err)

                        resp, err := client.R().
                                SetBody(buf).
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                Post("/api/shorten/batch")

                        assert.NoError(t, err)

                        //   
                        assert.Equal(t, tt.WantStatus, testutils.HTTPStatusToStatusCode(resp.StatusCode()))
                        if tt.WantStatus == testutils.StatusCreated </span><span class="cov6" title="3">{
                                // ,      
                                var response []models.BatchResponse
                                err = json.Unmarshal(resp.Body(), &amp;response)
                                assert.NoError(t, err)
                        }</span>

                })
        }

}
</pre>
		
		<pre class="file" id="file48" style="display: none">package testhandlers

import (
        "net/http"

        "github.com/ryabkov82/shortener/test/testutils"
)

type ShortenURLTestCase struct {
        Name        string
        OriginalURL string
        Want        testutils.StatusCode
        Cookie      *http.Cookie
}

// ShortenResult      
type ShortenResult struct {
        ShortURL string
        Status   testutils.StatusCode
}

func CommonShortenURLTestCases() []ShortenURLTestCase <span class="cov8" title="3">{

        cookie, _ := testutils.CreateSignedCookie()

        return []ShortenURLTestCase{
                {
                        Name:        "valid URL",
                        OriginalURL: "https://example.com",
                        Want:        testutils.StatusCreated,
                        Cookie:      cookie,
                },
                {
                        Name:        "valid URL",
                        OriginalURL: "https://example.com",
                        Want:        testutils.StatusConflict,
                        Cookie:      cookie,
                },
                /*
                        {
                                Name:        "invalid JWT",
                                OriginalURL: "https://example.com",
                                Want:        testutils.StatusUnauthorized,
                                Setup: func() (context.Context, error) {
                                        return testutils.ContextWithJWT(context.Background(), "bad.token"), nil
                                },
                                Cookie: &amp;http.Cookie{},
                        },
                */
                {
                        Name:        "bad URL",
                        OriginalURL: "not-a-url",
                        Want:        testutils.StatusBadRequest,
                        Cookie:      cookie,
                },
        }
}</span>

type RedirectResult struct {
        Location string
        Status   testutils.StatusCode
}

type RedirectTestCase struct {
        Name           string
        ShortKey       string
        ExpectedStatus testutils.StatusCode
        ExpectedURL    string
}

func CommonRedirectTestCases(shortKey string, originalURL string) []RedirectTestCase <span class="cov8" title="3">{
        return []RedirectTestCase{
                {
                        Name:           "valid redirect",
                        ShortKey:       shortKey,
                        ExpectedStatus: testutils.StatusTemporaryRedirect,
                        ExpectedURL:    originalURL,
                },
                {
                        Name:           "not found",
                        ShortKey:       "not_existing_key",
                        ExpectedStatus: testutils.StatusNotFound,
                        ExpectedURL:    "",
                },
        }
}</span>

type BatchTestCase struct {
        Name           string
        Request        string
        WantStatus     testutils.StatusCode
        ExpectedLength int //    
}

func CommonBatchTestCases() []BatchTestCase <span class="cov10" title="4">{
        return []BatchTestCase{
                {
                        Name: "valid batch request",
                        Request: `[
                        {"correlation_id": "123", "original_url": "https://example.com/page1"},
                        {"correlation_id": "456", "original_url": "https://example.com/page2"}
                ]`,
                        WantStatus:     testutils.StatusCreated,
                        ExpectedLength: 2,
                },
                {
                        Name:           "invalid json request",
                        Request:        `{}`,
                        WantStatus:     testutils.StatusBadRequest,
                        ExpectedLength: 0,
                },
        }
}</span>

type DelUserURLsTestCase struct {
        cookie         *http.Cookie
        name           string
        userID         string
        codesToDelete  []string
        shouldBeMarked []string
        wantStatus     testutils.StatusCode
}

func CommonDelUserURLsCases(user1URLs map[string]string) []DelUserURLsTestCase <span class="cov8" title="3">{

        user1 := "bf38c714-b8df-4f75-8578-ea6b5df32758"
        user2 := "93f3b6be-3f1c-452a-9cf9-475e160a3cb1"

        cookie1, err := testutils.CreateCookieByUserID(user1)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="3">cookie2, err := testutils.CreateCookieByUserID(user2)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="3">return []DelUserURLsTestCase{
                {
                        name:           "successful deletion",
                        userID:         user1,
                        cookie:         cookie1,
                        codesToDelete:  []string{user1URLs["url1"]},
                        wantStatus:     testutils.StatusAccepted,
                        shouldBeMarked: []string{user1URLs["url1"]},
                },
                {
                        name:           "delete multiple",
                        userID:         user1,
                        cookie:         cookie1,
                        codesToDelete:  []string{user1URLs["url2"], user1URLs["url3"]},
                        wantStatus:     testutils.StatusAccepted,
                        shouldBeMarked: []string{user1URLs["url2"], user1URLs["url3"]},
                },
                {
                        name:           "delete non-existent",
                        userID:         user1,
                        cookie:         cookie1,
                        codesToDelete:  []string{"nonexistent"},
                        wantStatus:     testutils.StatusAccepted,
                        shouldBeMarked: []string{},
                },
                {
                        name:           "delete other user's url",
                        userID:         user2,
                        cookie:         cookie2,
                        codesToDelete:  []string{user1URLs["url4"]},
                        wantStatus:     testutils.StatusAccepted,
                        shouldBeMarked: []string{}, //     
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package testhandlers

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "testing"
        "time"

        "github.com/stretchr/testify/assert"
        "google.golang.org/grpc/status"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
)

// TestDelUserUrls     URL (/api/user/urls).
//
//   :
//   -   URL   (StatusAccepted)
//   -    URL
//   -    URL
//   -   URL  
//   -    (   )
//   -   gzip   
//   -   JWT cookie
//
//  :
//   -    URL   
//   - HTTP-  middleware:
//   - 
//   - Gzip 
//   - JWT 
//   -       
//
//  -:
//   -   URL ( 202 Accepted)
//   -   ( 202 Accepted)
//   -   URL  
//   -   410 Gone  
//
// :
//   -    
//   -       GET-
//   -   gzip  
func TestDelUserUrls(t *testing.T, serv *service.Service, client *resty.Client) <span class="cov3" title="2">{

        user1URLs, _ := prepareTestURLs(serv)

        tests := CommonDelUserURLsCases(user1URLs)
        for _, tt := range tests </span><span class="cov8" title="8">{
                t.Run("HTTP"+tt.name, func(t *testing.T) </span><span class="cov8" title="8">{

                        //  
                        body, _ := json.Marshal(tt.codesToDelete)
                        buf := bytes.NewBuffer(nil)
                        zb := gzip.NewWriter(buf)
                        _, err := zb.Write([]byte(body))
                        assert.NoError(t, err)
                        err = zb.Close()
                        assert.NoError(t, err)

                        // 
                        resp, err := client.R().
                                SetBody(buf).
                                SetCookie(tt.cookie).
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                Delete("/api/user/urls")

                        // 
                        assert.NoError(t, err)
                        assert.Equal(t, tt.wantStatus, testutils.HTTPStatusToStatusCode(resp.StatusCode()))

                        time.Sleep(500 * time.Millisecond)
                        //   URL   
                        for _, code := range tt.codesToDelete </span><span class="cov9" title="10">{

                                resp, err := client.R().
                                        SetCookie(tt.cookie).
                                        Get("/" + code)

                                // 
                                assert.NoError(t, err)
                                if resp.StatusCode() == http.StatusGone </span><span class="cov7" title="6">{
                                        assert.Contains(t, tt.shouldBeMarked, code)
                                }</span> else<span class="cov6" title="4"> {
                                        assert.NotContains(t, tt.shouldBeMarked, code)
                                }</span>

                        }
                })
        }
}

func TestDelUserUrlsGRPC(t *testing.T, serv *service.Service, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        user1URLs, _ := prepareTestURLs(serv)

        tests := CommonDelUserURLsCases(user1URLs)
        for _, tt := range tests </span><span class="cov6" title="4">{
                t.Run("gRPC"+tt.name, func(t *testing.T) </span><span class="cov6" title="4">{

                        token := tt.cookie.Value
                        ctx := testutils.ContextWithJWT(context.Background(), token)

                        _, err := grpcClient.DeleteUserURLs(ctx, &amp;pb.DeleteRequest{ShortUrls: tt.codesToDelete})
                        assert.NoError(t, err)

                        time.Sleep(500 * time.Millisecond)
                        //   URL   
                        for _, code := range tt.codesToDelete </span><span class="cov6" title="5">{

                                _, err := grpcClient.GetOriginalURL(ctx, &amp;pb.GetRequest{ShortUrl: code})

                                var redirectStatus testutils.StatusCode
                                if err != nil </span><span class="cov6" title="4">{
                                        if s, ok := status.FromError(err); ok </span><span class="cov6" title="4">{
                                                redirectStatus = testutils.GRPCCodeToStatusCode(s.Code())
                                        }</span> else<span class="cov0" title="0"> {
                                                redirectStatus = testutils.StatusInternalError
                                        }</span>
                                } else<span class="cov1" title="1"> {
                                        redirectStatus = testutils.StatusTemporaryRedirect
                                }</span>

                                // 
                                <span class="cov6" title="5">if redirectStatus == testutils.StatusNotFound </span><span class="cov6" title="4">{
                                        if len(tt.shouldBeMarked) &gt; 0 </span><span class="cov4" title="3">{
                                                assert.Contains(t, tt.shouldBeMarked, code)
                                        }</span>
                                } else<span class="cov1" title="1"> {
                                        assert.NotContains(t, tt.shouldBeMarked, code)
                                }</span>
                        }

                })
        }
}

func prepareTestURLs(serv *service.Service) (map[string]string, map[string]string) <span class="cov4" title="3">{

        user1 := "bf38c714-b8df-4f75-8578-ea6b5df32758"
        user2 := "93f3b6be-3f1c-452a-9cf9-475e160a3cb1"

        //  
        user1Data := map[string]string{
                "url1": "https://example.com/1",
                "url2": "https://example.com/2",
                "url3": "https://example.com/3",
                "url4": "https://example.com/4",
        }
        user2Data := map[string]string{
                "url5": "https://example.com/5",
        }

        user1Shorts := map[string]string{}
        user2Shorts := map[string]string{}

        //  
        for key, original := range user1Data </span><span class="cov10" title="12">{
                ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, user1)
                shortKey, err := serv.GetShortKey(ctx, original)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to shorten URL %s: %v", original, err))</span>
                }
                <span class="cov10" title="12">user1Shorts[key] = shortKey</span>
        }

        <span class="cov4" title="3">for key, original := range user2Data </span><span class="cov4" title="3">{
                ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, user2)
                shortKey, err := serv.GetShortKey(ctx, original)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to shorten URL %s: %v", original, err))</span>
                }
                <span class="cov4" title="3">user2Shorts[key] = shortKey</span>
        }

        <span class="cov4" title="3">return user1Shorts, user2Shorts</span>

}
</pre>
		
		<pre class="file" id="file50" style="display: none">package testhandlers

import (
        "context"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/stretchr/testify/assert"
        "google.golang.org/grpc/status"
)

func TestRedirectGRPC(t *testing.T, repo service.Repository, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        const (
                shortKey    = "EYm7J2zF"
                originalURL = "https://practicum.yandex.ru/"
        )

        mapping := models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }

        cookie, userID := testutils.CreateSignedCookie()
        ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, userID)
        repo.SaveURL(ctx, &amp;mapping)

        tests := CommonRedirectTestCases(shortKey, originalURL)

        for _, tt := range tests </span><span class="cov10" title="2">{
                t.Run("gRPC_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="2">{

                        token := cookie.Value
                        ctx := testutils.ContextWithJWT(context.Background(), token)

                        resp, err := grpcClient.GetOriginalURL(ctx, &amp;pb.GetRequest{ShortUrl: tt.ShortKey})

                        var redirectStatus testutils.StatusCode
                        if err != nil </span><span class="cov1" title="1">{
                                if s, ok := status.FromError(err); ok </span><span class="cov1" title="1">{
                                        redirectStatus = testutils.GRPCCodeToStatusCode(s.Code())
                                }</span> else<span class="cov0" title="0"> {
                                        redirectStatus = testutils.StatusInternalError
                                }</span>
                        } else<span class="cov1" title="1"> {
                                redirectStatus = testutils.StatusTemporaryRedirect
                        }</span>

                        //   
                        <span class="cov10" title="2">assert.Equal(t, tt.ExpectedStatus, redirectStatus)
                        if tt.ExpectedStatus == testutils.StatusTemporaryRedirect </span><span class="cov1" title="1">{
                                assert.NoError(t, err)
                                assert.Equal(t, tt.ExpectedURL, resp.OriginalUrl)
                        }</span> else<span class="cov1" title="1"> {
                                assert.Error(t, err)
                        }</span>

                })
        }
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package testhandlers

import (
        "context"
        "errors"
        "net/http"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"

        "github.com/ryabkov82/shortener/internal/app/models"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestRedirect       (GET /{id}).
//
//   :
//   -     URL (StatusTemporaryRedirect)
//   -    URL (StatusNotFound)
//   -   Location  
//   -  JWT   cookie
//   -  gzip   middleware
//
//  :
//   -     URL
//   - HTTP-  middleware:
//   -  
//   -  gzip
//   - JWT 
//   -      resty
//
//  -:
//   -   URL ( 307   Location)
//   -   URL ( 404)
//
// :
//   -       Location
//   -      
//   -   ,    
func TestRedirect(t *testing.T, repo service.Repository, client *resty.Client) <span class="cov5" title="2">{

        const (
                shortKey    = "EYm7J2zF"
                originalURL = "https://practicum.yandex.ru/"
        )

        mapping := models.URLMapping{
                ShortURL:    shortKey,
                OriginalURL: originalURL,
        }

        var redirectAttemptedError = errors.New("redirect")
        redirectPolicy := resty.RedirectPolicyFunc(func(req *http.Request, via []*http.Request) error </span><span class="cov5" title="2">{
                // return nil for continue redirect otherwise return error to stop/prevent redirect
                return redirectAttemptedError
        }</span>)

        <span class="cov5" title="2">cookie, userID := testutils.CreateSignedCookie()
        ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, userID)
        repo.SaveURL(ctx, &amp;mapping)

        tests := CommonRedirectTestCases(shortKey, originalURL)

        for _, tt := range tests </span><span class="cov10" title="4">{
                t.Run("HTTP_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="4">{

                        client.SetRedirectPolicy(redirectPolicy)
                        req := client.R().SetCookie(cookie)
                        req.Method = http.MethodGet
                        req.URL = "/" + tt.ShortKey

                        resp, err := req.Send()

                        if errors.Is(err, redirectAttemptedError) </span><span class="cov5" title="2">{
                                //   
                                err = nil
                        }</span>

                        <span class="cov10" title="4">assert.NoError(t, err)

                        //   
                        assert.Equal(t, tt.ExpectedStatus, testutils.HTTPStatusToStatusCode(resp.StatusCode()))
                        if tt.ExpectedStatus == testutils.StatusTemporaryRedirect </span><span class="cov5" title="2">{
                                assert.Equal(t, tt.ExpectedURL, resp.Header().Get("Location"))
                        }</span>
                })
        }

}
</pre>
		
		<pre class="file" id="file52" style="display: none">package testhandlers

import (
        "bytes"
        "compress/gzip"
        "encoding/json"
        "net/http"
        "net/url"
        "testing"

        "github.com/ryabkov82/shortener/internal/app/handlers/http/shortenapi"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestShortenAPI  JSON API   URL (POST /api/shorten).
//
//   :
//   -     (StatusCreated)
//   -      URL (StatusConflict)
//   -   URL (StatusBadRequest)
//   -   JSON 
//   -  JWT   cookie
//   -  gzip    
//
//  :
//   -  HTTP   middleware:
//   -  
//   -  gzip
//   - JWT 
//   -       
//
//  -:
//   -  URL ( 201 Created    URL)
//   -  URL ( 409 Conflict)
//   -  URL ( 400 Bad Request)
//
// :
//   -     URL
//   -  gzip   
//   -    JWT cookie
func TestShortenAPI(t *testing.T, client *resty.Client) <span class="cov1" title="1">{

        cookie, _ := testutils.CreateSignedCookie()
        tests := []struct {
                cookie         *http.Cookie
                name           string
                request        shortenapi.Request
                wantStatusCode int
        }{
                {
                        name:           "positive test #1",
                        request:        shortenapi.Request{URL: "https://practicum.yandex.ru/"},
                        cookie:         cookie,
                        wantStatusCode: 201,
                },
                {
                        name:           "positive test #2",
                        request:        shortenapi.Request{URL: "https://practicum.yandex.ru/"},
                        cookie:         cookie,
                        wantStatusCode: 409,
                },
                {
                        name:           "negative test #2",
                        request:        shortenapi.Request{URL: "not url"},
                        cookie:         cookie,
                        wantStatusCode: 400,
                },
        }

        for _, tt := range tests </span><span class="cov10" title="3">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov10" title="3">{

                        req, err := json.Marshal(tt.request)
                        assert.NoError(t, err)

                        buf := bytes.NewBuffer(nil)
                        zb := gzip.NewWriter(buf)
                        _, err = zb.Write([]byte(req))
                        assert.NoError(t, err)
                        err = zb.Close()
                        assert.NoError(t, err)

                        resp, err := client.R().
                                SetCookie(tt.cookie).
                                SetBody(buf).
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                Post("/api/shorten")

                        assert.NoError(t, err)

                        //   
                        assert.Equal(t, tt.wantStatusCode, resp.StatusCode())
                        if tt.wantStatusCode == 201 </span><span class="cov1" title="1">{
                                var response shortenapi.Response
                                err = json.Unmarshal(resp.Body(), &amp;response)
                                assert.NoError(t, err)
                                shortURL := response.Result
                                // ,   URL
                                _, err = url.Parse(shortURL)
                                assert.NoError(t, err)
                        }</span>
                })
        }

}
</pre>
		
		<pre class="file" id="file53" style="display: none">package testhandlers

import (
        "context"
        "net/url"
        "testing"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/stretchr/testify/assert"
        "google.golang.org/grpc/status"
)

func TestShortenURLGRPC(t *testing.T, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        for _, tt := range CommonShortenURLTestCases() </span><span class="cov10" title="3">{
                t.Run("gRPC_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="3">{

                        token := tt.Cookie.Value
                        ctx := testutils.ContextWithJWT(context.Background(), token)

                        resp, err := grpcClient.CreateShortURL(ctx, &amp;pb.CreateRequest{OriginalUrl: tt.OriginalURL})
                        var shortenResult ShortenResult
                        if resp != nil </span><span class="cov1" title="1">{
                                shortenResult.ShortURL = resp.ShortUrl
                                shortenResult.Status = testutils.StatusCreated
                        }</span>

                        <span class="cov10" title="3">if err != nil </span><span class="cov6" title="2">{
                                if s, ok := status.FromError(err); ok </span><span class="cov6" title="2">{
                                        shortenResult.Status = testutils.GRPCCodeToStatusCode(s.Code())
                                }</span> else<span class="cov0" title="0"> {
                                        shortenResult.Status = testutils.StatusInternalError
                                }</span>
                        }

                        <span class="cov10" title="3">assert.Equal(t, tt.Want, shortenResult.Status)

                        if tt.Want == testutils.StatusCreated </span><span class="cov1" title="1">{
                                assert.NoError(t, err)
                                assert.NotNil(t, resp)
                                _, err = url.Parse(shortenResult.ShortURL)
                                assert.NoError(t, err)
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package testhandlers

import (
        "net/url"
        "testing"

        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestShortenURL     URL (POST /).
//
// :
//
//        t *testing.T -  
//        client *resty.Client -   HTTP  (  URL)
//
//   :
//   -     (StatusCreated)
//   -      URL (StatusConflict)
//   -   URL (StatusBadRequest)
//   -    
//   -  JWT   cookie
//   -  gzip   middleware
//
//  :
//   -  HTTP   middleware:
//   -  
//   -  gzip
//   - JWT 
//   -       
//
//  -:
//   -  URL ( 201 Created    URL   )
//   -  URL ( 409 Conflict)
//   -  URL ( 400 Bad Request)
//
// :
//   -     URL
//   -     / (   JSON API)
//   -    JWT cookie

func TestShortenURL(t *testing.T, httpClient *resty.Client) <span class="cov4" title="2">{

        for _, tt := range CommonShortenURLTestCases() </span><span class="cov10" title="6">{
                t.Run("HTTP_"+tt.Name, func(t *testing.T) </span><span class="cov10" title="6">{

                        resp, err := httpClient.R().
                                SetCookie(tt.Cookie).
                                SetBody(tt.OriginalURL).
                                Post("/")

                        assert.NoError(t, err)

                        var shortenResult ShortenResult

                        shortenResult.ShortURL = string(resp.Body())
                        shortenResult.Status = testutils.HTTPStatusToStatusCode(resp.StatusCode())

                        //   
                        assert.Equal(t, tt.Want, shortenResult.Status)
                        if tt.Want == testutils.StatusCreated </span><span class="cov4" title="2">{
                                shortURL := shortenResult.ShortURL
                                // ,   URL
                                _, err = url.Parse(string(shortURL))
                                assert.NoError(t, err)
                        }</span>

                })
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package testhandlers

import (
        "context"
        "encoding/json"
        "net/http"
        "testing"

        pb "github.com/ryabkov82/shortener/api"
        "github.com/ryabkov82/shortener/internal/app/models"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "github.com/ryabkov82/shortener/internal/app/service"
        "github.com/ryabkov82/shortener/test/testutils"

        "github.com/go-resty/resty/v2"
        "github.com/stretchr/testify/assert"
)

// TestUserUrls     URL  (GET /api/user/urls).
//
//   :
//   -    URL   (StatusOK)
//   -      (StatusNoContent)
//   -     cookie (StatusUnauthorized)
//   -   JSON 
//   -    cookie   
//   -  JWT   StrictJWTAutoIssue middleware
//
//  :
//   -    URL   
//   - HTTP-  middleware:
//   -  
//   -  gzip
//   -  JWT    
//   -       
//
//  -:
//   -    URL ( 200 OK   )
//   -    URL ( 204 NoContent)
//   -    ( 401 Unauthorized   cookie)
//
// :
//   -     StrictJWTAutoIssue
//   -    cookie   
//   -    JSON 
func TestUserUrls(t *testing.T, serv *service.Service, client *resty.Client) <span class="cov3" title="2">{

        //  
        cookie1, user1 := testutils.CreateSignedCookie()
        _, user2 := testutils.CreateSignedCookie()

        testURLs := []models.UserURLMapping{
                {UserID: user1, OriginalURL: "https://example.com/1"},
                {UserID: user1, OriginalURL: "https://example.com/2"},
                {UserID: user2, OriginalURL: "https://example.com/3"},
        }

        prepareTestUserURLs(serv, testURLs)

        t.Run("   ", func(t *testing.T) </span><span class="cov3" title="2">{

                // 
                resp, err := client.R().
                        SetCookie(cookie1).
                        Get("/api/user/urls")

                // 
                assert.NoError(t, err)
                assert.Equal(t, http.StatusOK, resp.StatusCode())

                var urls []models.URLMapping
                err = json.Unmarshal(resp.Body(), &amp;urls)
                assert.NoError(t, err)
                assert.Len(t, urls, 2) // user1  2 

        }</span>)
        <span class="cov3" title="2">t.Run("    ", func(t *testing.T) </span><span class="cov3" title="2">{
                cookie, _ := testutils.CreateSignedCookie()

                resp, err := client.R().
                        SetCookie(cookie).
                        Get("/api/user/urls")

                assert.NoError(t, err)
                assert.Equal(t, http.StatusNoContent, resp.StatusCode())

        }</span>)

        <span class="cov3" title="2">t.Run("  ", func(t *testing.T) </span><span class="cov3" title="2">{
                resp, err := client.R().
                        Get("/api/user/urls")

                assert.NoError(t, err)
                assert.Equal(t, http.StatusUnauthorized, resp.StatusCode())

                //     
                assert.NotEmpty(t, resp.Cookies())
        }</span>)

}

func TestUserUrlsGRPC(t *testing.T, serv *service.Service, grpcClient pb.ShortenerClient) <span class="cov1" title="1">{

        //  
        cookie1, user1 := testutils.CreateSignedCookie()
        _, user2 := testutils.CreateSignedCookie()

        testURLs := []models.UserURLMapping{
                {UserID: user1, OriginalURL: "https://example.com/1"},
                {UserID: user1, OriginalURL: "https://example.com/2"},
                {UserID: user2, OriginalURL: "https://example.com/3"},
        }

        prepareTestUserURLs(serv, testURLs)

        t.Run("   ", func(t *testing.T) </span><span class="cov1" title="1">{

                // 
                token := cookie1.Value
                ctx := testutils.ContextWithJWT(context.Background(), token)

                resp, err := grpcClient.GetUserURLs(ctx, &amp;pb.UserURLsRequest{})

                // 
                assert.NoError(t, err)

                statusGetUserURLs := testutils.StatusOK
                if len(resp.Urls) == 0 </span><span class="cov0" title="0">{
                        statusGetUserURLs = testutils.StatusNoContent
                }</span>

                <span class="cov1" title="1">var urls []models.URLMapping
                if statusGetUserURLs == testutils.StatusOK </span><span class="cov1" title="1">{
                        for _, u := range resp.Urls </span><span class="cov3" title="2">{
                                urls = append(urls, models.URLMapping{
                                        ShortURL:    u.ShortUrl,
                                        OriginalURL: u.OriginalUrl,
                                })
                        }</span>
                }

                <span class="cov1" title="1">assert.Equal(t, testutils.StatusOK, statusGetUserURLs)

                assert.Len(t, urls, 2)</span> // user1  2 

        })
        <span class="cov1" title="1">t.Run("    ", func(t *testing.T) </span><span class="cov1" title="1">{

                cookie, _ := testutils.CreateSignedCookie()
                ctx := testutils.ContextWithJWT(context.Background(), cookie.Value)

                resp, err := grpcClient.GetUserURLs(ctx, &amp;pb.UserURLsRequest{})

                assert.NoError(t, err)
                statusGetUserURLs := testutils.StatusOK
                if len(resp.Urls) == 0 </span><span class="cov1" title="1">{
                        statusGetUserURLs = testutils.StatusNoContent
                }</span>

                <span class="cov1" title="1">assert.Equal(t, testutils.StatusNoContent, statusGetUserURLs)</span>

        })
}

func prepareTestUserURLs(serv *service.Service, testURLs []models.UserURLMapping) <span class="cov5" title="3">{

        for _, url := range testURLs </span><span class="cov10" title="9">{
                ctx := context.WithValue(context.Background(), jwtauth.UserIDContextKey, url.UserID)
                _, err := serv.GetShortKey(ctx, url.OriginalURL)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                // url.ShortURL = shortURL
        }

}
</pre>
		
		<pre class="file" id="file56" style="display: none">package testutils

import (
        "context"
        "fmt"
        "net/http"

        "github.com/golang-jwt/jwt/v5"

        "github.com/ryabkov82/shortener/internal/app/jwtauth"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// TestSecretKey      JWT.
//     .
var TestSecretKey = []byte("test-secret-key")

// CreateSignedCookie   HTTP-   JWT-.
//       .
func CreateSignedCookie() (*http.Cookie, string) <span class="cov10" title="17">{
        tokenString, userID, err := jwtauth.GenerateNewToken(TestSecretKey)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> //    panic
        }

        <span class="cov10" title="17">return &amp;http.Cookie{
                Name:     "token",
                Value:    tokenString,
                HttpOnly: true,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
        }, userID</span>
}

// CreateJWTToken   JWT 
func CreateCookieByUserID(userID string) (*http.Cookie, error) <span class="cov6" title="6">{
        tokenString, err := jwtauth.CreateToken(TestSecretKey, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="6">return &amp;http.Cookie{
                Name:     "token",
                Value:    tokenString,
                HttpOnly: true,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
        }, nil</span>
}

// ContextWithJWT  JWT    gRPC
func ContextWithJWT(ctx context.Context, token string) context.Context <span class="cov8" title="11">{
        md := metadata.New(map[string]string{
                "token": token,
        })
        return metadata.NewOutgoingContext(ctx, md)
}</span>

// ParseUserIDFromContext  userID  
func ParseUserIDFromContext(ctx context.Context) (string, error) <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return "", status.Error(codes.Unauthenticated, "metadata not provided")
        }</span>

        <span class="cov0" title="0">tokens := md.Get("token")
        if len(tokens) == 0 </span><span class="cov0" title="0">{
                return "", status.Error(codes.Unauthenticated, "authorization token not provided")
        }</span>

        <span class="cov0" title="0">claims := &amp;jwtauth.Claims{}

        token, err := jwt.ParseWithClaims(tokens[0], claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                }</span>
                <span class="cov0" title="0">return TestSecretKey, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", status.Error(codes.Unauthenticated, "invalid token")
        }</span>

        <span class="cov0" title="0">userID := claims.UserID

        if userID != "" &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return userID, nil
        }</span>

        <span class="cov0" title="0">return "", status.Error(codes.Unauthenticated, "invalid token claims")</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package testutils

import (
        "net/http/httptest"

        "github.com/go-chi/chi/v5"
        "github.com/go-resty/resty/v2"
)

// TestClient   HTTP    .
//    HTTP     .
//
// :
//
//        Client *resty.Client -   HTTP 
//        Server *httptest.Server -  HTTP 
type TestClient struct {
        Client *resty.Client
        Server *httptest.Server
}

// NewTestClient      HTTP .
//
// :
//
//        handlers ...func(r chi.Router) -    .
//                .
//              -     .
//
// :
//
//        *TestClient -       .
//
// :
//
//  1.  :
//     tc := NewTestClient(
//     func(r chi.Router) {
//     r.Get("/ping", PingHandler)
//     },
//     )
//     defer tc.Close()
//
//  2.  middleware:
//     tc := NewTestClient(
//     func(r chi.Router) {
//     r.Use(LoggerMiddleware)
//     r.Post("/data", DataHandler)
//     },
//     )
func NewTestClient(handlers ...func(r chi.Router)) *TestClient <span class="cov10" title="8">{
        r := chi.NewRouter()
        for _, h := range handlers </span><span class="cov10" title="8">{
                h(r)
        }</span>
        <span class="cov10" title="8">srv := httptest.NewServer(r)

        return &amp;TestClient{
                Client: resty.New().SetBaseURL(srv.URL),
                Server: srv,
        }</span>
}

// Close    .
//      (  defer).
//
// :
//   -   
//   -   idle- 
func (tc *TestClient) Close() <span class="cov9" title="7">{
        tc.Server.Close()
        tc.Client.GetClient().CloseIdleConnections()
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package testutils

import (
        "context"
        "fmt"
        "net"
        "time"

        pb "github.com/ryabkov82/shortener/api"

        "google.golang.org/grpc"
        "google.golang.org/grpc/connectivity"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/test/bufconn"
)

// TestGRPCClient   gRPC    .
type TestGRPCClient struct {
        Conn   *grpc.ClientConn
        Server *grpc.Server
        Lis    *bufconn.Listener
}

// NewTestGRPCClient      gRPC .
//
// :
//   - interceptors:  gRPC 
//   - service:  gRPC 
//
// :
//   - *TestGRPCClient -       
func NewTestGRPCClient(
        interceptors []grpc.UnaryServerInterceptor,
        service pb.ShortenerServer,
) *TestGRPCClient <span class="cov7" title="10">{

        //   
        lis := bufconn.Listen(1024 * 1024)

        srv := grpc.NewServer(
                grpc.ChainUnaryInterceptor(interceptors...),
        )

        //  
        pb.RegisterShortenerServer(srv, service)

        //     
        serverErr := make(chan error, 1) //  
        ready := make(chan struct{})

        go func() </span><span class="cov7" title="10">{
                close(ready) // ,  -   Serve
                if err := srv.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        serverErr &lt;- err
                }</span>
                <span class="cov7" title="10">close(serverErr)</span>
        }()

        <span class="cov7" title="10">&lt;-ready //   

        //  dial   bufconn
        dialer := func(ctx context.Context, addr string) (net.Conn, error) </span><span class="cov7" title="10">{
                return lis.DialContext(ctx)
        }</span>

        <span class="cov7" title="10">conn, err := grpc.NewClient(
                "passthrough:///inmem",
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithContextDialer(dialer),
        )

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // 1.   
        <span class="cov7" title="10">conn.Connect()

        // 2.    
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // 3.    
        connectionReady := make(chan struct{})
        go func() </span><span class="cov7" title="10">{
                for </span><span class="cov10" title="20">{
                        state := conn.GetState()
                        if state == connectivity.Ready </span><span class="cov7" title="10">{
                                close(connectionReady)
                                return
                        }</span>

                        //   
                        <span class="cov7" title="10">if !conn.WaitForStateChange(ctx, state) </span><span class="cov0" title="0">{
                                return //    
                        }</span>
                }
        }()

        //   ,  
        <span class="cov7" title="10">select </span>{
        case &lt;-connectionReady:<span class="cov7" title="10">
                //    
                fmt.Println("Connection established successfully")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                panic("connection timeout exceeded: server not responding")</span>
        }

        <span class="cov7" title="10">return &amp;TestGRPCClient{
                Conn:   conn,
                Lis:    lis,
                Server: srv,
        }</span>
}

// Close    .
func (tc *TestGRPCClient) Close() <span class="cov7" title="10">{
        tc.Conn.Close()
        tc.Server.Stop()
        tc.Lis.Close()
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package testutils

import (
        "os"
        "path/filepath"

        storage "github.com/ryabkov82/shortener/internal/app/storage/inmemory"
)

// InitializeInMemoryStorage        .
//
//  :
//   -       
//   -     ( )
//   -   in-memory 
//   -     (  )
//
// :
//   - *storage.InMemoryStorage:  
//   - error: ,     
//
// :
//   -     
//   -     
//   -     
//
//  :
//
//        st, err := InitializeInMemoryStorage()
//        if err != nil {
//            log.Fatalf("Failed to initialize storage: %v", err)
//        }
//        defer st.Close()
func InitializeInMemoryStorage() (*storage.InMemoryStorage, error) <span class="cov10" title="11">{

        //   testdata 
        globalData, err := GetGlobalTestDataPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="11">fileStorage := filepath.Join(globalData, "test.dat")

        _ = os.Remove(fileStorage)

        st, err := storage.NewInMemoryStorage(fileStorage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //st.Load(fileStorage)

        <span class="cov10" title="11">return st, nil</span>

}
</pre>
		
		<pre class="file" id="file60" style="display: none">package testutils

import (
        "os/exec"
        "path/filepath"
        "strings"
)

// GetModuleRoot       Go-.
//   'go list -m'.   ,  
//      .
func GetModuleRoot() (string, error) <span class="cov10" title="11">{
        out, err := exec.Command("go", "list", "-m", "-f", "{{.Dir}}").Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="11">return strings.TrimSpace(string(out)), nil</span>
}

// GetGlobalTestDataPath      testdata 
func GetGlobalTestDataPath() (string, error) <span class="cov10" title="11">{
        root, err := GetModuleRoot()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="11">return filepath.Join(root, "test", "testdata"), nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package testutils

import (
        "net/http"

        "google.golang.org/grpc/codes"
)

// StatusCode   enum   .
type StatusCode int

const (
        StatusOK StatusCode = iota
        StatusCreated
        StatusBadRequest
        StatusUnauthorized
        StatusForbidden
        StatusNotFound
        StatusConflict
        StatusTemporaryRedirect
        StatusAccepted
        StatusNoContent
        StatusServiceUnavailable
        StatusGatewayTimeout
        StatusInternalError
        StatusUnknown
)

// grpcCodeToStatusCode  grpc   StatusCode
func GRPCCodeToStatusCode(code codes.Code) StatusCode <span class="cov6" title="7">{
        switch code </span>{
        case codes.OK:<span class="cov0" title="0">
                return StatusCreated</span>
        case codes.InvalidArgument:<span class="cov1" title="1">
                return StatusBadRequest</span>
        case codes.NotFound:<span class="cov5" title="5">
                return StatusNotFound</span>
        case codes.AlreadyExists:<span class="cov1" title="1">
                return StatusConflict</span>
        case codes.PermissionDenied:<span class="cov0" title="0">
                return StatusForbidden</span>
        case codes.Unauthenticated:<span class="cov0" title="0">
                return StatusUnauthorized</span>
        case codes.Unavailable:<span class="cov0" title="0">
                return StatusServiceUnavailable</span>
        case codes.DeadlineExceeded:<span class="cov0" title="0">
                return StatusGatewayTimeout</span>
        case codes.Internal:<span class="cov0" title="0">
                return StatusInternalError</span>
        default:<span class="cov0" title="0">
                return StatusUnknown</span>
        }
}

// httpStatusToStatusCode  HTTP   StatusCode
func HTTPStatusToStatusCode(code int) StatusCode <span class="cov10" title="24">{
        switch code </span>{
        case http.StatusOK:<span class="cov0" title="0">
                return StatusOK</span>
        case http.StatusCreated:<span class="cov5" title="5">
                return StatusCreated</span>
        case http.StatusBadRequest:<span class="cov5" title="5">
                return StatusBadRequest</span>
        case http.StatusUnauthorized:<span class="cov0" title="0">
                return StatusUnauthorized</span>
        case http.StatusForbidden:<span class="cov0" title="0">
                return StatusForbidden</span>
        case http.StatusNotFound:<span class="cov2" title="2">
                return StatusNotFound</span>
        case http.StatusConflict:<span class="cov2" title="2">
                return StatusConflict</span>
        case http.StatusServiceUnavailable:<span class="cov0" title="0">
                return StatusServiceUnavailable</span>
        case http.StatusGatewayTimeout:<span class="cov0" title="0">
                return StatusGatewayTimeout</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                return StatusInternalError</span>
        case http.StatusTemporaryRedirect:<span class="cov2" title="2">
                return StatusTemporaryRedirect</span>
        case http.StatusAccepted:<span class="cov6" title="8">
                return StatusAccepted</span>
        case http.StatusNoContent:<span class="cov0" title="0">
                return StatusNoContent</span>
        default:<span class="cov0" title="0">
                return StatusUnknown</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
